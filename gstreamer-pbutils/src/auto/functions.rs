// This file was generated by gir (d933f9a+) from gir-files (???)
// DO NOT EDIT

use EncodingTarget;
use ffi;
use glib::object::IsA;
use glib::translate::*;
use gst;
use std::mem;


pub fn codec_utils_aac_caps_set_level_and_profile(caps: &gst::Caps, audio_config: &[u8]) -> bool {
    assert_initialized_main_thread!();
    let len = audio_config.len() as u32;
    unsafe {
        from_glib(ffi::gst_codec_utils_aac_caps_set_level_and_profile(caps.to_glib_none().0, audio_config.to_glib_none().0, len))
    }
}

pub fn codec_utils_aac_get_channels(audio_config: &[u8]) -> u32 {
    assert_initialized_main_thread!();
    let len = audio_config.len() as u32;
    unsafe {
        ffi::gst_codec_utils_aac_get_channels(audio_config.to_glib_none().0, len)
    }
}

pub fn codec_utils_aac_get_index_from_sample_rate(rate: u32) -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gst_codec_utils_aac_get_index_from_sample_rate(rate)
    }
}

pub fn codec_utils_aac_get_level(audio_config: &[u8]) -> Option<String> {
    assert_initialized_main_thread!();
    let len = audio_config.len() as u32;
    unsafe {
        from_glib_none(ffi::gst_codec_utils_aac_get_level(audio_config.to_glib_none().0, len))
    }
}

pub fn codec_utils_aac_get_profile(audio_config: &[u8]) -> Option<String> {
    assert_initialized_main_thread!();
    let len = audio_config.len() as u32;
    unsafe {
        from_glib_none(ffi::gst_codec_utils_aac_get_profile(audio_config.to_glib_none().0, len))
    }
}

pub fn codec_utils_aac_get_sample_rate(audio_config: &[u8]) -> u32 {
    assert_initialized_main_thread!();
    let len = audio_config.len() as u32;
    unsafe {
        ffi::gst_codec_utils_aac_get_sample_rate(audio_config.to_glib_none().0, len)
    }
}

pub fn codec_utils_aac_get_sample_rate_from_index(sr_idx: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gst_codec_utils_aac_get_sample_rate_from_index(sr_idx)
    }
}

pub fn codec_utils_h264_caps_set_level_and_profile(caps: &gst::Caps, sps: &[u8]) -> bool {
    assert_initialized_main_thread!();
    let len = sps.len() as u32;
    unsafe {
        from_glib(ffi::gst_codec_utils_h264_caps_set_level_and_profile(caps.to_glib_none().0, sps.to_glib_none().0, len))
    }
}

pub fn codec_utils_h264_get_level(sps: &[u8]) -> Option<String> {
    assert_initialized_main_thread!();
    let len = sps.len() as u32;
    unsafe {
        from_glib_none(ffi::gst_codec_utils_h264_get_level(sps.to_glib_none().0, len))
    }
}

pub fn codec_utils_h264_get_level_idc(level: &str) -> u8 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gst_codec_utils_h264_get_level_idc(level.to_glib_none().0)
    }
}

pub fn codec_utils_h264_get_profile(sps: &[u8]) -> Option<String> {
    assert_initialized_main_thread!();
    let len = sps.len() as u32;
    unsafe {
        from_glib_none(ffi::gst_codec_utils_h264_get_profile(sps.to_glib_none().0, len))
    }
}

pub fn codec_utils_h265_caps_set_level_tier_and_profile(caps: &gst::Caps, profile_tier_level: &[u8]) -> bool {
    assert_initialized_main_thread!();
    let len = profile_tier_level.len() as u32;
    unsafe {
        from_glib(ffi::gst_codec_utils_h265_caps_set_level_tier_and_profile(caps.to_glib_none().0, profile_tier_level.to_glib_none().0, len))
    }
}

pub fn codec_utils_h265_get_level(profile_tier_level: &[u8]) -> Option<String> {
    assert_initialized_main_thread!();
    let len = profile_tier_level.len() as u32;
    unsafe {
        from_glib_none(ffi::gst_codec_utils_h265_get_level(profile_tier_level.to_glib_none().0, len))
    }
}

pub fn codec_utils_h265_get_level_idc(level: &str) -> u8 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gst_codec_utils_h265_get_level_idc(level.to_glib_none().0)
    }
}

pub fn codec_utils_h265_get_profile(profile_tier_level: &[u8]) -> Option<String> {
    assert_initialized_main_thread!();
    let len = profile_tier_level.len() as u32;
    unsafe {
        from_glib_none(ffi::gst_codec_utils_h265_get_profile(profile_tier_level.to_glib_none().0, len))
    }
}

pub fn codec_utils_h265_get_tier(profile_tier_level: &[u8]) -> Option<String> {
    assert_initialized_main_thread!();
    let len = profile_tier_level.len() as u32;
    unsafe {
        from_glib_none(ffi::gst_codec_utils_h265_get_tier(profile_tier_level.to_glib_none().0, len))
    }
}

pub fn codec_utils_mpeg4video_caps_set_level_and_profile(caps: &gst::Caps, vis_obj_seq: &[u8]) -> bool {
    assert_initialized_main_thread!();
    let len = vis_obj_seq.len() as u32;
    unsafe {
        from_glib(ffi::gst_codec_utils_mpeg4video_caps_set_level_and_profile(caps.to_glib_none().0, vis_obj_seq.to_glib_none().0, len))
    }
}

pub fn codec_utils_mpeg4video_get_level(vis_obj_seq: &[u8]) -> Option<String> {
    assert_initialized_main_thread!();
    let len = vis_obj_seq.len() as u32;
    unsafe {
        from_glib_none(ffi::gst_codec_utils_mpeg4video_get_level(vis_obj_seq.to_glib_none().0, len))
    }
}

pub fn codec_utils_mpeg4video_get_profile(vis_obj_seq: &[u8]) -> Option<String> {
    assert_initialized_main_thread!();
    let len = vis_obj_seq.len() as u32;
    unsafe {
        from_glib_none(ffi::gst_codec_utils_mpeg4video_get_profile(vis_obj_seq.to_glib_none().0, len))
    }
}

//pub fn codec_utils_opus_create_caps(rate: u32, channels: u8, channel_mapping_family: u8, stream_count: u8, coupled_count: u8, channel_mapping: &[u8]) -> Option<gst::Caps> {
//    unsafe { TODO: call ffi::gst_codec_utils_opus_create_caps() }
//}

pub fn codec_utils_opus_create_caps_from_header<'a, P: Into<Option<&'a gst::Buffer>>>(header: &gst::Buffer, comments: P) -> Option<gst::Caps> {
    assert_initialized_main_thread!();
    let comments = comments.into();
    let comments = comments.to_glib_none();
    unsafe {
        from_glib_full(ffi::gst_codec_utils_opus_create_caps_from_header(header.to_glib_none().0, comments.0))
    }
}

//pub fn codec_utils_opus_create_header(rate: u32, channels: u8, channel_mapping_family: u8, stream_count: u8, coupled_count: u8, channel_mapping: &[u8], pre_skip: u16, output_gain: i16) -> Option<gst::Buffer> {
//    unsafe { TODO: call ffi::gst_codec_utils_opus_create_header() }
//}

pub fn encoding_list_all_targets<'a, P: Into<Option<&'a str>>>(categoryname: P) -> Vec<EncodingTarget> {
    assert_initialized_main_thread!();
    let categoryname = categoryname.into();
    let categoryname = categoryname.to_glib_none();
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::gst_encoding_list_all_targets(categoryname.0))
    }
}

pub fn encoding_list_available_categories() -> Vec<String> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::gst_encoding_list_available_categories())
    }
}

pub fn install_plugins_installation_in_progress() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gst_install_plugins_installation_in_progress())
    }
}

pub fn install_plugins_supported() -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gst_install_plugins_supported())
    }
}

pub fn is_missing_plugin_message(msg: &gst::Message) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::gst_is_missing_plugin_message(msg.to_glib_none().0))
    }
}

pub fn missing_decoder_installer_detail_new(decode_caps: &gst::Caps) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_decoder_installer_detail_new(decode_caps.to_glib_none().0))
    }
}

pub fn missing_decoder_message_new<P: IsA<gst::Element>>(element: &P, decode_caps: &gst::Caps) -> Option<gst::Message> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_decoder_message_new(element.to_glib_none().0, decode_caps.to_glib_none().0))
    }
}

pub fn missing_element_installer_detail_new(factory_name: &str) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_element_installer_detail_new(factory_name.to_glib_none().0))
    }
}

pub fn missing_element_message_new<P: IsA<gst::Element>>(element: &P, factory_name: &str) -> Option<gst::Message> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_element_message_new(element.to_glib_none().0, factory_name.to_glib_none().0))
    }
}

pub fn missing_encoder_installer_detail_new(encode_caps: &gst::Caps) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_encoder_installer_detail_new(encode_caps.to_glib_none().0))
    }
}

pub fn missing_encoder_message_new<P: IsA<gst::Element>>(element: &P, encode_caps: &gst::Caps) -> Option<gst::Message> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_encoder_message_new(element.to_glib_none().0, encode_caps.to_glib_none().0))
    }
}

pub fn missing_plugin_message_get_description(msg: &gst::Message) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_plugin_message_get_description(msg.to_glib_none().0))
    }
}

pub fn missing_plugin_message_get_installer_detail(msg: &gst::Message) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_plugin_message_get_installer_detail(msg.to_glib_none().0))
    }
}

pub fn missing_uri_sink_installer_detail_new(protocol: &str) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_uri_sink_installer_detail_new(protocol.to_glib_none().0))
    }
}

pub fn missing_uri_sink_message_new<P: IsA<gst::Element>>(element: &P, protocol: &str) -> Option<gst::Message> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_uri_sink_message_new(element.to_glib_none().0, protocol.to_glib_none().0))
    }
}

pub fn missing_uri_source_installer_detail_new(protocol: &str) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_uri_source_installer_detail_new(protocol.to_glib_none().0))
    }
}

pub fn missing_uri_source_message_new<P: IsA<gst::Element>>(element: &P, protocol: &str) -> Option<gst::Message> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_missing_uri_source_message_new(element.to_glib_none().0, protocol.to_glib_none().0))
    }
}

pub fn pb_utils_add_codec_description_to_tag_list<'a, P: Into<Option<&'a str>>>(taglist: &gst::TagList, codec_tag: P, caps: &gst::Caps) -> bool {
    assert_initialized_main_thread!();
    let codec_tag = codec_tag.into();
    let codec_tag = codec_tag.to_glib_none();
    unsafe {
        from_glib(ffi::gst_pb_utils_add_codec_description_to_tag_list(taglist.to_glib_none().0, codec_tag.0, caps.to_glib_none().0))
    }
}

pub fn pb_utils_get_codec_description(caps: &gst::Caps) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_pb_utils_get_codec_description(caps.to_glib_none().0))
    }
}

pub fn pb_utils_get_decoder_description(caps: &gst::Caps) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_pb_utils_get_decoder_description(caps.to_glib_none().0))
    }
}

pub fn pb_utils_get_element_description(factory_name: &str) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_pb_utils_get_element_description(factory_name.to_glib_none().0))
    }
}

pub fn pb_utils_get_encoder_description(caps: &gst::Caps) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_pb_utils_get_encoder_description(caps.to_glib_none().0))
    }
}

pub fn pb_utils_get_sink_description(protocol: &str) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_pb_utils_get_sink_description(protocol.to_glib_none().0))
    }
}

pub fn pb_utils_get_source_description(protocol: &str) -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_pb_utils_get_source_description(protocol.to_glib_none().0))
    }
}

pub fn pb_utils_init() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::gst_pb_utils_init();
    }
}

pub fn plugins_base_version() -> (u32, u32, u32, u32) {
    assert_initialized_main_thread!();
    unsafe {
        let mut major = mem::uninitialized();
        let mut minor = mem::uninitialized();
        let mut micro = mem::uninitialized();
        let mut nano = mem::uninitialized();
        ffi::gst_plugins_base_version(&mut major, &mut minor, &mut micro, &mut nano);
        (major, minor, micro, nano)
    }
}

pub fn plugins_base_version_string() -> Option<String> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::gst_plugins_base_version_string())
    }
}
