// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::EncodingTarget;
use glib::translate::*;
use std::mem;

#[doc(alias = "gst_encoding_list_all_targets")]
pub fn encoding_list_all_targets(categoryname: Option<&str>) -> Vec<EncodingTarget> {
    assert_initialized_main_thread!();
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::gst_encoding_list_all_targets(
            categoryname.to_glib_none().0,
        ))
    }
}

#[doc(alias = "gst_encoding_list_available_categories")]
pub fn encoding_list_available_categories() -> Vec<glib::GString> {
    assert_initialized_main_thread!();
    unsafe { FromGlibPtrContainer::from_glib_full(ffi::gst_encoding_list_available_categories()) }
}

#[doc(alias = "gst_pb_utils_get_element_description")]
pub fn pb_utils_get_element_description(
    factory_name: &str,
) -> Result<glib::GString, glib::BoolError> {
    assert_initialized_main_thread!();
    unsafe {
        Option::<_>::from_glib_full(ffi::gst_pb_utils_get_element_description(
            factory_name.to_glib_none().0,
        ))
        .ok_or_else(|| glib::bool_error!("Failed to get element description"))
    }
}

#[doc(alias = "gst_pb_utils_get_sink_description")]
pub fn pb_utils_get_sink_description(protocol: &str) -> Result<glib::GString, glib::BoolError> {
    assert_initialized_main_thread!();
    unsafe {
        Option::<_>::from_glib_full(ffi::gst_pb_utils_get_sink_description(
            protocol.to_glib_none().0,
        ))
        .ok_or_else(|| glib::bool_error!("Failed to get sink description"))
    }
}

#[doc(alias = "gst_pb_utils_get_source_description")]
pub fn pb_utils_get_source_description(protocol: &str) -> Result<glib::GString, glib::BoolError> {
    assert_initialized_main_thread!();
    unsafe {
        Option::<_>::from_glib_full(ffi::gst_pb_utils_get_source_description(
            protocol.to_glib_none().0,
        ))
        .ok_or_else(|| glib::bool_error!("Failed to get source description"))
    }
}

#[doc(alias = "gst_plugins_base_version")]
pub fn plugins_base_version() -> (u32, u32, u32, u32) {
    skip_assert_initialized!();
    unsafe {
        let mut major = mem::MaybeUninit::uninit();
        let mut minor = mem::MaybeUninit::uninit();
        let mut micro = mem::MaybeUninit::uninit();
        let mut nano = mem::MaybeUninit::uninit();
        ffi::gst_plugins_base_version(
            major.as_mut_ptr(),
            minor.as_mut_ptr(),
            micro.as_mut_ptr(),
            nano.as_mut_ptr(),
        );
        let major = major.assume_init();
        let minor = minor.assume_init();
        let micro = micro.assume_init();
        let nano = nano.assume_init();
        (major, minor, micro, nano)
    }
}

#[doc(alias = "gst_plugins_base_version_string")]
pub fn plugins_base_version_string() -> glib::GString {
    skip_assert_initialized!();
    unsafe { from_glib_full(ffi::gst_plugins_base_version_string()) }
}
