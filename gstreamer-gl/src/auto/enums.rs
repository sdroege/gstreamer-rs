// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use ffi;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use gobject_ffi;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum GLBaseMemoryError {
    Failed,
    OldLibs,
    ResourceUnavailable,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLBaseMemoryError {
    type GlibType = ffi::GstGLBaseMemoryError;

    fn to_glib(&self) -> ffi::GstGLBaseMemoryError {
        match *self {
            GLBaseMemoryError::Failed => ffi::GST_GL_BASE_MEMORY_ERROR_FAILED,
            GLBaseMemoryError::OldLibs => ffi::GST_GL_BASE_MEMORY_ERROR_OLD_LIBS,
            GLBaseMemoryError::ResourceUnavailable => ffi::GST_GL_BASE_MEMORY_ERROR_RESOURCE_UNAVAILABLE,
            GLBaseMemoryError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstGLBaseMemoryError> for GLBaseMemoryError {
    fn from_glib(value: ffi::GstGLBaseMemoryError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLBaseMemoryError::Failed,
            1 => GLBaseMemoryError::OldLibs,
            2 => GLBaseMemoryError::ResourceUnavailable,
            value => GLBaseMemoryError::__Unknown(value),
        }
    }
}

impl ErrorDomain for GLBaseMemoryError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(ffi::gst_gl_base_memory_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(GLBaseMemoryError::Failed),
            1 => Some(GLBaseMemoryError::OldLibs),
            2 => Some(GLBaseMemoryError::ResourceUnavailable),
            _ => Some(GLBaseMemoryError::Failed),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum GLContextError {
    Failed,
    WrongConfig,
    WrongApi,
    OldLibs,
    CreateContext,
    ResourceUnavailable,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLContextError {
    type GlibType = ffi::GstGLContextError;

    fn to_glib(&self) -> ffi::GstGLContextError {
        match *self {
            GLContextError::Failed => ffi::GST_GL_CONTEXT_ERROR_FAILED,
            GLContextError::WrongConfig => ffi::GST_GL_CONTEXT_ERROR_WRONG_CONFIG,
            GLContextError::WrongApi => ffi::GST_GL_CONTEXT_ERROR_WRONG_API,
            GLContextError::OldLibs => ffi::GST_GL_CONTEXT_ERROR_OLD_LIBS,
            GLContextError::CreateContext => ffi::GST_GL_CONTEXT_ERROR_CREATE_CONTEXT,
            GLContextError::ResourceUnavailable => ffi::GST_GL_CONTEXT_ERROR_RESOURCE_UNAVAILABLE,
            GLContextError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstGLContextError> for GLContextError {
    fn from_glib(value: ffi::GstGLContextError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLContextError::Failed,
            1 => GLContextError::WrongConfig,
            2 => GLContextError::WrongApi,
            3 => GLContextError::OldLibs,
            4 => GLContextError::CreateContext,
            5 => GLContextError::ResourceUnavailable,
            value => GLContextError::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum GLFormat {
    Luminance,
    Alpha,
    LuminanceAlpha,
    Red,
    R8,
    Rg,
    Rg8,
    Rgb,
    Rgb8,
    Rgb565,
    Rgba,
    Rgba8,
    DepthComponent16,
    Depth24Stencil8,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLFormat {
    type GlibType = ffi::GstGLFormat;

    fn to_glib(&self) -> ffi::GstGLFormat {
        match *self {
            GLFormat::Luminance => ffi::GST_GL_LUMINANCE,
            GLFormat::Alpha => ffi::GST_GL_ALPHA,
            GLFormat::LuminanceAlpha => ffi::GST_GL_LUMINANCE_ALPHA,
            GLFormat::Red => ffi::GST_GL_RED,
            GLFormat::R8 => ffi::GST_GL_R8,
            GLFormat::Rg => ffi::GST_GL_RG,
            GLFormat::Rg8 => ffi::GST_GL_RG8,
            GLFormat::Rgb => ffi::GST_GL_RGB,
            GLFormat::Rgb8 => ffi::GST_GL_RGB8,
            GLFormat::Rgb565 => ffi::GST_GL_RGB565,
            GLFormat::Rgba => ffi::GST_GL_RGBA,
            GLFormat::Rgba8 => ffi::GST_GL_RGBA8,
            GLFormat::DepthComponent16 => ffi::GST_GL_DEPTH_COMPONENT16,
            GLFormat::Depth24Stencil8 => ffi::GST_GL_DEPTH24_STENCIL8,
            GLFormat::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstGLFormat> for GLFormat {
    fn from_glib(value: ffi::GstGLFormat) -> Self {
        skip_assert_initialized!();
        match value {
            6409 => GLFormat::Luminance,
            6406 => GLFormat::Alpha,
            6410 => GLFormat::LuminanceAlpha,
            6403 => GLFormat::Red,
            33321 => GLFormat::R8,
            33319 => GLFormat::Rg,
            33323 => GLFormat::Rg8,
            6407 => GLFormat::Rgb,
            32849 => GLFormat::Rgb8,
            36194 => GLFormat::Rgb565,
            6408 => GLFormat::Rgba,
            32856 => GLFormat::Rgba8,
            33189 => GLFormat::DepthComponent16,
            35056 => GLFormat::Depth24Stencil8,
            value => GLFormat::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum GLQueryType {
    None,
    TimeElapsed,
    Timestamp,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLQueryType {
    type GlibType = ffi::GstGLQueryType;

    fn to_glib(&self) -> ffi::GstGLQueryType {
        match *self {
            GLQueryType::None => ffi::GST_GL_QUERY_NONE,
            GLQueryType::TimeElapsed => ffi::GST_GL_QUERY_TIME_ELAPSED,
            GLQueryType::Timestamp => ffi::GST_GL_QUERY_TIMESTAMP,
            GLQueryType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstGLQueryType> for GLQueryType {
    fn from_glib(value: ffi::GstGLQueryType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLQueryType::None,
            1 => GLQueryType::TimeElapsed,
            2 => GLQueryType::Timestamp,
            value => GLQueryType::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum GLSLError {
    Compile,
    Link,
    Program,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLSLError {
    type GlibType = ffi::GstGLSLError;

    fn to_glib(&self) -> ffi::GstGLSLError {
        match *self {
            GLSLError::Compile => ffi::GST_GLSL_ERROR_COMPILE,
            GLSLError::Link => ffi::GST_GLSL_ERROR_LINK,
            GLSLError::Program => ffi::GST_GLSL_ERROR_PROGRAM,
            GLSLError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstGLSLError> for GLSLError {
    fn from_glib(value: ffi::GstGLSLError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLSLError::Compile,
            1 => GLSLError::Link,
            2 => GLSLError::Program,
            value => GLSLError::__Unknown(value),
        }
    }
}

impl ErrorDomain for GLSLError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(ffi::gst_glsl_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(GLSLError::Compile),
            1 => Some(GLSLError::Link),
            2 => Some(GLSLError::Program),
            value => Some(GLSLError::__Unknown(value)),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum GLSLVersion {
    None,
    _100,
    _110,
    _120,
    _130,
    _140,
    _150,
    _300,
    _310,
    _320,
    _330,
    _400,
    _410,
    _420,
    _430,
    _440,
    _450,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLSLVersion {
    type GlibType = ffi::GstGLSLVersion;

    fn to_glib(&self) -> ffi::GstGLSLVersion {
        match *self {
            GLSLVersion::None => ffi::GST_GLSL_VERSION_NONE,
            GLSLVersion::_100 => ffi::GST_GLSL_VERSION_100,
            GLSLVersion::_110 => ffi::GST_GLSL_VERSION_110,
            GLSLVersion::_120 => ffi::GST_GLSL_VERSION_120,
            GLSLVersion::_130 => ffi::GST_GLSL_VERSION_130,
            GLSLVersion::_140 => ffi::GST_GLSL_VERSION_140,
            GLSLVersion::_150 => ffi::GST_GLSL_VERSION_150,
            GLSLVersion::_300 => ffi::GST_GLSL_VERSION_300,
            GLSLVersion::_310 => ffi::GST_GLSL_VERSION_310,
            GLSLVersion::_320 => ffi::GST_GLSL_VERSION_320,
            GLSLVersion::_330 => ffi::GST_GLSL_VERSION_330,
            GLSLVersion::_400 => ffi::GST_GLSL_VERSION_400,
            GLSLVersion::_410 => ffi::GST_GLSL_VERSION_410,
            GLSLVersion::_420 => ffi::GST_GLSL_VERSION_420,
            GLSLVersion::_430 => ffi::GST_GLSL_VERSION_430,
            GLSLVersion::_440 => ffi::GST_GLSL_VERSION_440,
            GLSLVersion::_450 => ffi::GST_GLSL_VERSION_450,
            GLSLVersion::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstGLSLVersion> for GLSLVersion {
    fn from_glib(value: ffi::GstGLSLVersion) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLSLVersion::None,
            100 => GLSLVersion::_100,
            110 => GLSLVersion::_110,
            120 => GLSLVersion::_120,
            130 => GLSLVersion::_130,
            140 => GLSLVersion::_140,
            150 => GLSLVersion::_150,
            300 => GLSLVersion::_300,
            310 => GLSLVersion::_310,
            320 => GLSLVersion::_320,
            330 => GLSLVersion::_330,
            400 => GLSLVersion::_400,
            410 => GLSLVersion::_410,
            420 => GLSLVersion::_420,
            430 => GLSLVersion::_430,
            440 => GLSLVersion::_440,
            450 => GLSLVersion::_450,
            value => GLSLVersion::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum GLStereoDownmix {
    GreenMagentaDubois,
    RedCyanDubois,
    AmberBlueDubois,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLStereoDownmix {
    type GlibType = ffi::GstGLStereoDownmix;

    fn to_glib(&self) -> ffi::GstGLStereoDownmix {
        match *self {
            GLStereoDownmix::GreenMagentaDubois => ffi::GST_GL_STEREO_DOWNMIX_ANAGLYPH_GREEN_MAGENTA_DUBOIS,
            GLStereoDownmix::RedCyanDubois => ffi::GST_GL_STEREO_DOWNMIX_ANAGLYPH_RED_CYAN_DUBOIS,
            GLStereoDownmix::AmberBlueDubois => ffi::GST_GL_STEREO_DOWNMIX_ANAGLYPH_AMBER_BLUE_DUBOIS,
            GLStereoDownmix::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstGLStereoDownmix> for GLStereoDownmix {
    fn from_glib(value: ffi::GstGLStereoDownmix) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLStereoDownmix::GreenMagentaDubois,
            1 => GLStereoDownmix::RedCyanDubois,
            2 => GLStereoDownmix::AmberBlueDubois,
            value => GLStereoDownmix::__Unknown(value),
        }
    }
}

impl StaticType for GLStereoDownmix {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_gl_stereo_downmix_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GLStereoDownmix {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GLStereoDownmix {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GLStereoDownmix {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum GLTextureTarget {
    None,
    _2d,
    Rectangle,
    ExternalOes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLTextureTarget {
    type GlibType = ffi::GstGLTextureTarget;

    fn to_glib(&self) -> ffi::GstGLTextureTarget {
        match *self {
            GLTextureTarget::None => ffi::GST_GL_TEXTURE_TARGET_NONE,
            GLTextureTarget::_2d => ffi::GST_GL_TEXTURE_TARGET_2D,
            GLTextureTarget::Rectangle => ffi::GST_GL_TEXTURE_TARGET_RECTANGLE,
            GLTextureTarget::ExternalOes => ffi::GST_GL_TEXTURE_TARGET_EXTERNAL_OES,
            GLTextureTarget::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstGLTextureTarget> for GLTextureTarget {
    fn from_glib(value: ffi::GstGLTextureTarget) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLTextureTarget::None,
            1 => GLTextureTarget::_2d,
            2 => GLTextureTarget::Rectangle,
            3 => GLTextureTarget::ExternalOes,
            value => GLTextureTarget::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum GLUploadReturn {
    Done,
    Error,
    Unsupported,
    Reconfigure,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLUploadReturn {
    type GlibType = ffi::GstGLUploadReturn;

    fn to_glib(&self) -> ffi::GstGLUploadReturn {
        match *self {
            GLUploadReturn::Done => ffi::GST_GL_UPLOAD_DONE,
            GLUploadReturn::Error => ffi::GST_GL_UPLOAD_ERROR,
            GLUploadReturn::Unsupported => ffi::GST_GL_UPLOAD_UNSUPPORTED,
            GLUploadReturn::Reconfigure => ffi::GST_GL_UPLOAD_RECONFIGURE,
            GLUploadReturn::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstGLUploadReturn> for GLUploadReturn {
    fn from_glib(value: ffi::GstGLUploadReturn) -> Self {
        skip_assert_initialized!();
        match value {
            1 => GLUploadReturn::Done,
            -1 => GLUploadReturn::Error,
            -2 => GLUploadReturn::Unsupported,
            -3 => GLUploadReturn::Reconfigure,
            value => GLUploadReturn::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum GLWindowError {
    Failed,
    OldLibs,
    ResourceUnavailable,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLWindowError {
    type GlibType = ffi::GstGLWindowError;

    fn to_glib(&self) -> ffi::GstGLWindowError {
        match *self {
            GLWindowError::Failed => ffi::GST_GL_WINDOW_ERROR_FAILED,
            GLWindowError::OldLibs => ffi::GST_GL_WINDOW_ERROR_OLD_LIBS,
            GLWindowError::ResourceUnavailable => ffi::GST_GL_WINDOW_ERROR_RESOURCE_UNAVAILABLE,
            GLWindowError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstGLWindowError> for GLWindowError {
    fn from_glib(value: ffi::GstGLWindowError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLWindowError::Failed,
            1 => GLWindowError::OldLibs,
            2 => GLWindowError::ResourceUnavailable,
            value => GLWindowError::__Unknown(value),
        }
    }
}

