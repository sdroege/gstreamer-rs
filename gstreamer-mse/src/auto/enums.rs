// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// from gst-gir-files (https://gitlab.freedesktop.org/gstreamer/gir-files-rs.git)
// DO NOT EDIT

use crate::ffi;
use glib::{prelude::*, translate::*};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstMediaSourceEOSError")]
pub enum MediaSourceEOSError {
    #[doc(alias = "GST_MEDIA_SOURCE_EOS_ERROR_NONE")]
    None,
    #[doc(alias = "GST_MEDIA_SOURCE_EOS_ERROR_NETWORK")]
    Network,
    #[doc(alias = "GST_MEDIA_SOURCE_EOS_ERROR_DECODE")]
    Decode,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for MediaSourceEOSError {
    type GlibType = ffi::GstMediaSourceEOSError;

    #[inline]
    fn into_glib(self) -> ffi::GstMediaSourceEOSError {
        match self {
            Self::None => ffi::GST_MEDIA_SOURCE_EOS_ERROR_NONE,
            Self::Network => ffi::GST_MEDIA_SOURCE_EOS_ERROR_NETWORK,
            Self::Decode => ffi::GST_MEDIA_SOURCE_EOS_ERROR_DECODE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstMediaSourceEOSError> for MediaSourceEOSError {
    #[inline]
    unsafe fn from_glib(value: ffi::GstMediaSourceEOSError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_MEDIA_SOURCE_EOS_ERROR_NONE => Self::None,
            ffi::GST_MEDIA_SOURCE_EOS_ERROR_NETWORK => Self::Network,
            ffi::GST_MEDIA_SOURCE_EOS_ERROR_DECODE => Self::Decode,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for MediaSourceEOSError {
    #[inline]
    #[doc(alias = "gst_media_source_eos_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_media_source_eos_error_get_type()) }
    }
}

impl glib::HasParamSpec for MediaSourceEOSError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for MediaSourceEOSError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MediaSourceEOSError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for MediaSourceEOSError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MediaSourceEOSError> for glib::Value {
    #[inline]
    fn from(v: MediaSourceEOSError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstMediaSourceError")]
pub enum MediaSourceError {
    #[doc(alias = "GST_MEDIA_SOURCE_ERROR_INVALID_STATE")]
    InvalidState,
    #[doc(alias = "GST_MEDIA_SOURCE_ERROR_TYPE")]
    Type,
    #[doc(alias = "GST_MEDIA_SOURCE_ERROR_NOT_SUPPORTED")]
    NotSupported,
    #[doc(alias = "GST_MEDIA_SOURCE_ERROR_NOT_FOUND")]
    NotFound,
    #[doc(alias = "GST_MEDIA_SOURCE_ERROR_QUOTA_EXCEEDED")]
    QuotaExceeded,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for MediaSourceError {
    type GlibType = ffi::GstMediaSourceError;

    #[inline]
    fn into_glib(self) -> ffi::GstMediaSourceError {
        match self {
            Self::InvalidState => ffi::GST_MEDIA_SOURCE_ERROR_INVALID_STATE,
            Self::Type => ffi::GST_MEDIA_SOURCE_ERROR_TYPE,
            Self::NotSupported => ffi::GST_MEDIA_SOURCE_ERROR_NOT_SUPPORTED,
            Self::NotFound => ffi::GST_MEDIA_SOURCE_ERROR_NOT_FOUND,
            Self::QuotaExceeded => ffi::GST_MEDIA_SOURCE_ERROR_QUOTA_EXCEEDED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstMediaSourceError> for MediaSourceError {
    #[inline]
    unsafe fn from_glib(value: ffi::GstMediaSourceError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_MEDIA_SOURCE_ERROR_INVALID_STATE => Self::InvalidState,
            ffi::GST_MEDIA_SOURCE_ERROR_TYPE => Self::Type,
            ffi::GST_MEDIA_SOURCE_ERROR_NOT_SUPPORTED => Self::NotSupported,
            ffi::GST_MEDIA_SOURCE_ERROR_NOT_FOUND => Self::NotFound,
            ffi::GST_MEDIA_SOURCE_ERROR_QUOTA_EXCEEDED => Self::QuotaExceeded,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for MediaSourceError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gst_media_source_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for MediaSourceError {
    #[inline]
    #[doc(alias = "gst_media_source_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_media_source_error_get_type()) }
    }
}

impl glib::HasParamSpec for MediaSourceError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for MediaSourceError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MediaSourceError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for MediaSourceError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MediaSourceError> for glib::Value {
    #[inline]
    fn from(v: MediaSourceError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstMediaSourceReadyState")]
pub enum MediaSourceReadyState {
    #[doc(alias = "GST_MEDIA_SOURCE_READY_STATE_CLOSED")]
    Closed,
    #[doc(alias = "GST_MEDIA_SOURCE_READY_STATE_OPEN")]
    Open,
    #[doc(alias = "GST_MEDIA_SOURCE_READY_STATE_ENDED")]
    Ended,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for MediaSourceReadyState {
    type GlibType = ffi::GstMediaSourceReadyState;

    #[inline]
    fn into_glib(self) -> ffi::GstMediaSourceReadyState {
        match self {
            Self::Closed => ffi::GST_MEDIA_SOURCE_READY_STATE_CLOSED,
            Self::Open => ffi::GST_MEDIA_SOURCE_READY_STATE_OPEN,
            Self::Ended => ffi::GST_MEDIA_SOURCE_READY_STATE_ENDED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstMediaSourceReadyState> for MediaSourceReadyState {
    #[inline]
    unsafe fn from_glib(value: ffi::GstMediaSourceReadyState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_MEDIA_SOURCE_READY_STATE_CLOSED => Self::Closed,
            ffi::GST_MEDIA_SOURCE_READY_STATE_OPEN => Self::Open,
            ffi::GST_MEDIA_SOURCE_READY_STATE_ENDED => Self::Ended,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for MediaSourceReadyState {
    #[inline]
    #[doc(alias = "gst_media_source_ready_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_media_source_ready_state_get_type()) }
    }
}

impl glib::HasParamSpec for MediaSourceReadyState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for MediaSourceReadyState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MediaSourceReadyState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for MediaSourceReadyState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MediaSourceReadyState> for glib::Value {
    #[inline]
    fn from(v: MediaSourceReadyState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstMseSrcReadyState")]
pub enum MseSrcReadyState {
    #[doc(alias = "GST_MSE_SRC_READY_STATE_HAVE_NOTHING")]
    Nothing,
    #[doc(alias = "GST_MSE_SRC_READY_STATE_HAVE_METADATA")]
    Metadata,
    #[doc(alias = "GST_MSE_SRC_READY_STATE_HAVE_CURRENT_DATA")]
    CurrentData,
    #[doc(alias = "GST_MSE_SRC_READY_STATE_HAVE_FUTURE_DATA")]
    FutureData,
    #[doc(alias = "GST_MSE_SRC_READY_STATE_HAVE_ENOUGH_DATA")]
    EnoughData,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for MseSrcReadyState {
    type GlibType = ffi::GstMseSrcReadyState;

    #[inline]
    fn into_glib(self) -> ffi::GstMseSrcReadyState {
        match self {
            Self::Nothing => ffi::GST_MSE_SRC_READY_STATE_HAVE_NOTHING,
            Self::Metadata => ffi::GST_MSE_SRC_READY_STATE_HAVE_METADATA,
            Self::CurrentData => ffi::GST_MSE_SRC_READY_STATE_HAVE_CURRENT_DATA,
            Self::FutureData => ffi::GST_MSE_SRC_READY_STATE_HAVE_FUTURE_DATA,
            Self::EnoughData => ffi::GST_MSE_SRC_READY_STATE_HAVE_ENOUGH_DATA,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstMseSrcReadyState> for MseSrcReadyState {
    #[inline]
    unsafe fn from_glib(value: ffi::GstMseSrcReadyState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_MSE_SRC_READY_STATE_HAVE_NOTHING => Self::Nothing,
            ffi::GST_MSE_SRC_READY_STATE_HAVE_METADATA => Self::Metadata,
            ffi::GST_MSE_SRC_READY_STATE_HAVE_CURRENT_DATA => Self::CurrentData,
            ffi::GST_MSE_SRC_READY_STATE_HAVE_FUTURE_DATA => Self::FutureData,
            ffi::GST_MSE_SRC_READY_STATE_HAVE_ENOUGH_DATA => Self::EnoughData,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for MseSrcReadyState {
    #[inline]
    #[doc(alias = "gst_mse_src_ready_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_mse_src_ready_state_get_type()) }
    }
}

impl glib::HasParamSpec for MseSrcReadyState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for MseSrcReadyState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MseSrcReadyState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for MseSrcReadyState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MseSrcReadyState> for glib::Value {
    #[inline]
    fn from(v: MseSrcReadyState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstSourceBufferAppendMode")]
pub enum SourceBufferAppendMode {
    #[doc(alias = "GST_SOURCE_BUFFER_APPEND_MODE_SEGMENTS")]
    Segments,
    #[doc(alias = "GST_SOURCE_BUFFER_APPEND_MODE_SEQUENCE")]
    Sequence,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SourceBufferAppendMode {
    type GlibType = ffi::GstSourceBufferAppendMode;

    #[inline]
    fn into_glib(self) -> ffi::GstSourceBufferAppendMode {
        match self {
            Self::Segments => ffi::GST_SOURCE_BUFFER_APPEND_MODE_SEGMENTS,
            Self::Sequence => ffi::GST_SOURCE_BUFFER_APPEND_MODE_SEQUENCE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstSourceBufferAppendMode> for SourceBufferAppendMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GstSourceBufferAppendMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_SOURCE_BUFFER_APPEND_MODE_SEGMENTS => Self::Segments,
            ffi::GST_SOURCE_BUFFER_APPEND_MODE_SEQUENCE => Self::Sequence,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SourceBufferAppendMode {
    #[inline]
    #[doc(alias = "gst_source_buffer_append_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_source_buffer_append_mode_get_type()) }
    }
}

impl glib::HasParamSpec for SourceBufferAppendMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SourceBufferAppendMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SourceBufferAppendMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for SourceBufferAppendMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SourceBufferAppendMode> for glib::Value {
    #[inline]
    fn from(v: SourceBufferAppendMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
