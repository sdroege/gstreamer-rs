// This file was generated by gir (3294959) from gir-files (???)
// DO NOT EDIT

use PlayerVideoRenderer;
use ffi;
use glib;
use glib::Value;
use glib::object::IsA;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
use gst;
use std::mem;
use std::ptr;

glib_wrapper! {
    pub struct PlayerVideoOverlayVideoRenderer(Object<ffi::GstPlayerVideoOverlayVideoRenderer>): PlayerVideoRenderer;

    match fn {
        get_type => || ffi::gst_player_video_overlay_video_renderer_get_type(),
    }
}

impl PlayerVideoOverlayVideoRenderer {
    //pub fn new<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(window_handle: P) -> Option<PlayerVideoRenderer> {
    //    unsafe { TODO: call ffi::gst_player_video_overlay_video_renderer_new() }
    //}

    //pub fn new_with_sink<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>, Q: IsA<gst::Element>>(window_handle: P, video_sink: &Q) -> Option<PlayerVideoRenderer> {
    //    unsafe { TODO: call ffi::gst_player_video_overlay_video_renderer_new_with_sink() }
    //}
}

unsafe impl Send for PlayerVideoOverlayVideoRenderer {}
unsafe impl Sync for PlayerVideoOverlayVideoRenderer {}

pub trait PlayerVideoOverlayVideoRendererExt {
    fn expose(&self);

    fn get_render_rectangle(&self) -> (i32, i32, i32, i32);

    //fn get_window_handle(&self) -> /*Unimplemented*/Option<Fundamental: Pointer>;

    fn set_render_rectangle(&self, x: i32, y: i32, width: i32, height: i32);

    //fn set_window_handle<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(&self, window_handle: P);

    fn get_property_video_sink(&self) -> Option<gst::Element>;

    fn set_property_video_sink<P: IsA<gst::Element> + IsA<glib::object::Object> + glib::value::SetValueOptional>(&self, video_sink: Option<&P>);
}

impl<O: IsA<PlayerVideoOverlayVideoRenderer> + IsA<glib::object::Object>> PlayerVideoOverlayVideoRendererExt for O {
    fn expose(&self) {
        unsafe {
            ffi::gst_player_video_overlay_video_renderer_expose(self.to_glib_none().0);
        }
    }

    fn get_render_rectangle(&self) -> (i32, i32, i32, i32) {
        unsafe {
            let mut x = mem::uninitialized();
            let mut y = mem::uninitialized();
            let mut width = mem::uninitialized();
            let mut height = mem::uninitialized();
            ffi::gst_player_video_overlay_video_renderer_get_render_rectangle(self.to_glib_none().0, &mut x, &mut y, &mut width, &mut height);
            (x, y, width, height)
        }
    }

    //fn get_window_handle(&self) -> /*Unimplemented*/Option<Fundamental: Pointer> {
    //    unsafe { TODO: call ffi::gst_player_video_overlay_video_renderer_get_window_handle() }
    //}

    fn set_render_rectangle(&self, x: i32, y: i32, width: i32, height: i32) {
        unsafe {
            ffi::gst_player_video_overlay_video_renderer_set_render_rectangle(self.to_glib_none().0, x, y, width, height);
        }
    }

    //fn set_window_handle<P: Into<Option</*Unimplemented*/Fundamental: Pointer>>>(&self, window_handle: P) {
    //    unsafe { TODO: call ffi::gst_player_video_overlay_video_renderer_set_window_handle() }
    //}

    fn get_property_video_sink(&self) -> Option<gst::Element> {
        let mut value = Value::from(None::<&gst::Element>);
        unsafe {
            gobject_ffi::g_object_get_property(self.to_glib_none().0, "video-sink".to_glib_none().0, value.to_glib_none_mut().0);
        }
        value.get()
    }

    fn set_property_video_sink<P: IsA<gst::Element> + IsA<glib::object::Object> + glib::value::SetValueOptional>(&self, video_sink: Option<&P>) {
        unsafe {
            gobject_ffi::g_object_set_property(self.to_glib_none().0, "video-sink".to_glib_none().0, Value::from(video_sink).to_glib_none().0);
        }
    }
}
