// This file was generated by gir (0113735) from gir-files (???)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;
extern crate gstreamer_sys as gst;
extern crate gstreamer_base_sys as gst_base;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType, Volatile};

// Enums
pub type GstAudioBaseSinkDiscontReason = c_int;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_NO_DISCONT: GstAudioBaseSinkDiscontReason = 0;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_NEW_CAPS: GstAudioBaseSinkDiscontReason = 1;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_FLUSH: GstAudioBaseSinkDiscontReason = 2;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_SYNC_LATENCY: GstAudioBaseSinkDiscontReason = 3;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_ALIGNMENT: GstAudioBaseSinkDiscontReason = 4;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_DEVICE_FAILURE: GstAudioBaseSinkDiscontReason = 5;

pub type GstAudioBaseSinkSlaveMethod = c_int;
pub const GST_AUDIO_BASE_SINK_SLAVE_RESAMPLE: GstAudioBaseSinkSlaveMethod = 0;
pub const GST_AUDIO_BASE_SINK_SLAVE_SKEW: GstAudioBaseSinkSlaveMethod = 1;
pub const GST_AUDIO_BASE_SINK_SLAVE_NONE: GstAudioBaseSinkSlaveMethod = 2;
pub const GST_AUDIO_BASE_SINK_SLAVE_CUSTOM: GstAudioBaseSinkSlaveMethod = 3;

pub type GstAudioBaseSrcSlaveMethod = c_int;
pub const GST_AUDIO_BASE_SRC_SLAVE_RESAMPLE: GstAudioBaseSrcSlaveMethod = 0;
pub const GST_AUDIO_BASE_SRC_SLAVE_RE_TIMESTAMP: GstAudioBaseSrcSlaveMethod = 1;
pub const GST_AUDIO_BASE_SRC_SLAVE_SKEW: GstAudioBaseSrcSlaveMethod = 2;
pub const GST_AUDIO_BASE_SRC_SLAVE_NONE: GstAudioBaseSrcSlaveMethod = 3;

pub type GstAudioCdSrcMode = c_int;
pub const GST_AUDIO_CD_SRC_MODE_NORMAL: GstAudioCdSrcMode = 0;
pub const GST_AUDIO_CD_SRC_MODE_CONTINUOUS: GstAudioCdSrcMode = 1;

pub type GstAudioChannelPosition = c_int;
pub const GST_AUDIO_CHANNEL_POSITION_NONE: GstAudioChannelPosition = -3;
pub const GST_AUDIO_CHANNEL_POSITION_MONO: GstAudioChannelPosition = -2;
pub const GST_AUDIO_CHANNEL_POSITION_INVALID: GstAudioChannelPosition = -1;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT: GstAudioChannelPosition = 0;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT: GstAudioChannelPosition = 1;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER: GstAudioChannelPosition = 2;
pub const GST_AUDIO_CHANNEL_POSITION_LFE1: GstAudioChannelPosition = 3;
pub const GST_AUDIO_CHANNEL_POSITION_REAR_LEFT: GstAudioChannelPosition = 4;
pub const GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT: GstAudioChannelPosition = 5;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER: GstAudioChannelPosition = 6;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER: GstAudioChannelPosition = 7;
pub const GST_AUDIO_CHANNEL_POSITION_REAR_CENTER: GstAudioChannelPosition = 8;
pub const GST_AUDIO_CHANNEL_POSITION_LFE2: GstAudioChannelPosition = 9;
pub const GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT: GstAudioChannelPosition = 10;
pub const GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT: GstAudioChannelPosition = 11;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT: GstAudioChannelPosition = 12;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT: GstAudioChannelPosition = 13;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER: GstAudioChannelPosition = 14;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_CENTER: GstAudioChannelPosition = 15;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT: GstAudioChannelPosition = 16;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT: GstAudioChannelPosition = 17;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT: GstAudioChannelPosition = 18;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT: GstAudioChannelPosition = 19;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER: GstAudioChannelPosition = 20;
pub const GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER: GstAudioChannelPosition = 21;
pub const GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT: GstAudioChannelPosition = 22;
pub const GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT: GstAudioChannelPosition = 23;
pub const GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT: GstAudioChannelPosition = 24;
pub const GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT: GstAudioChannelPosition = 25;
pub const GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT: GstAudioChannelPosition = 26;
pub const GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT: GstAudioChannelPosition = 27;

pub type GstAudioDitherMethod = c_int;
pub const GST_AUDIO_DITHER_NONE: GstAudioDitherMethod = 0;
pub const GST_AUDIO_DITHER_RPDF: GstAudioDitherMethod = 1;
pub const GST_AUDIO_DITHER_TPDF: GstAudioDitherMethod = 2;
pub const GST_AUDIO_DITHER_TPDF_HF: GstAudioDitherMethod = 3;

pub type GstAudioFormat = c_int;
pub const GST_AUDIO_FORMAT_UNKNOWN: GstAudioFormat = 0;
pub const GST_AUDIO_FORMAT_ENCODED: GstAudioFormat = 1;
pub const GST_AUDIO_FORMAT_S8: GstAudioFormat = 2;
pub const GST_AUDIO_FORMAT_U8: GstAudioFormat = 3;
pub const GST_AUDIO_FORMAT_S16LE: GstAudioFormat = 4;
pub const GST_AUDIO_FORMAT_S16BE: GstAudioFormat = 5;
pub const GST_AUDIO_FORMAT_U16LE: GstAudioFormat = 6;
pub const GST_AUDIO_FORMAT_U16BE: GstAudioFormat = 7;
pub const GST_AUDIO_FORMAT_S24_32LE: GstAudioFormat = 8;
pub const GST_AUDIO_FORMAT_S24_32BE: GstAudioFormat = 9;
pub const GST_AUDIO_FORMAT_U24_32LE: GstAudioFormat = 10;
pub const GST_AUDIO_FORMAT_U24_32BE: GstAudioFormat = 11;
pub const GST_AUDIO_FORMAT_S32LE: GstAudioFormat = 12;
pub const GST_AUDIO_FORMAT_S32BE: GstAudioFormat = 13;
pub const GST_AUDIO_FORMAT_U32LE: GstAudioFormat = 14;
pub const GST_AUDIO_FORMAT_U32BE: GstAudioFormat = 15;
pub const GST_AUDIO_FORMAT_S24LE: GstAudioFormat = 16;
pub const GST_AUDIO_FORMAT_S24BE: GstAudioFormat = 17;
pub const GST_AUDIO_FORMAT_U24LE: GstAudioFormat = 18;
pub const GST_AUDIO_FORMAT_U24BE: GstAudioFormat = 19;
pub const GST_AUDIO_FORMAT_S20LE: GstAudioFormat = 20;
pub const GST_AUDIO_FORMAT_S20BE: GstAudioFormat = 21;
pub const GST_AUDIO_FORMAT_U20LE: GstAudioFormat = 22;
pub const GST_AUDIO_FORMAT_U20BE: GstAudioFormat = 23;
pub const GST_AUDIO_FORMAT_S18LE: GstAudioFormat = 24;
pub const GST_AUDIO_FORMAT_S18BE: GstAudioFormat = 25;
pub const GST_AUDIO_FORMAT_U18LE: GstAudioFormat = 26;
pub const GST_AUDIO_FORMAT_U18BE: GstAudioFormat = 27;
pub const GST_AUDIO_FORMAT_F32LE: GstAudioFormat = 28;
pub const GST_AUDIO_FORMAT_F32BE: GstAudioFormat = 29;
pub const GST_AUDIO_FORMAT_F64LE: GstAudioFormat = 30;
pub const GST_AUDIO_FORMAT_F64BE: GstAudioFormat = 31;

pub type GstAudioLayout = c_int;
pub const GST_AUDIO_LAYOUT_INTERLEAVED: GstAudioLayout = 0;
pub const GST_AUDIO_LAYOUT_NON_INTERLEAVED: GstAudioLayout = 1;

pub type GstAudioNoiseShapingMethod = c_int;
pub const GST_AUDIO_NOISE_SHAPING_NONE: GstAudioNoiseShapingMethod = 0;
pub const GST_AUDIO_NOISE_SHAPING_ERROR_FEEDBACK: GstAudioNoiseShapingMethod = 1;
pub const GST_AUDIO_NOISE_SHAPING_SIMPLE: GstAudioNoiseShapingMethod = 2;
pub const GST_AUDIO_NOISE_SHAPING_MEDIUM: GstAudioNoiseShapingMethod = 3;
pub const GST_AUDIO_NOISE_SHAPING_HIGH: GstAudioNoiseShapingMethod = 4;

pub type GstAudioResamplerFilterInterpolation = c_int;
pub const GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_NONE: GstAudioResamplerFilterInterpolation = 0;
pub const GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_LINEAR: GstAudioResamplerFilterInterpolation = 1;
pub const GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_CUBIC: GstAudioResamplerFilterInterpolation = 2;

pub type GstAudioResamplerFilterMode = c_int;
pub const GST_AUDIO_RESAMPLER_FILTER_MODE_INTERPOLATED: GstAudioResamplerFilterMode = 0;
pub const GST_AUDIO_RESAMPLER_FILTER_MODE_FULL: GstAudioResamplerFilterMode = 1;
pub const GST_AUDIO_RESAMPLER_FILTER_MODE_AUTO: GstAudioResamplerFilterMode = 2;

pub type GstAudioResamplerMethod = c_int;
pub const GST_AUDIO_RESAMPLER_METHOD_NEAREST: GstAudioResamplerMethod = 0;
pub const GST_AUDIO_RESAMPLER_METHOD_LINEAR: GstAudioResamplerMethod = 1;
pub const GST_AUDIO_RESAMPLER_METHOD_CUBIC: GstAudioResamplerMethod = 2;
pub const GST_AUDIO_RESAMPLER_METHOD_BLACKMAN_NUTTALL: GstAudioResamplerMethod = 3;
pub const GST_AUDIO_RESAMPLER_METHOD_KAISER: GstAudioResamplerMethod = 4;

pub type GstAudioRingBufferFormatType = c_int;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW: GstAudioRingBufferFormatType = 0;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MU_LAW: GstAudioRingBufferFormatType = 1;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_A_LAW: GstAudioRingBufferFormatType = 2;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IMA_ADPCM: GstAudioRingBufferFormatType = 3;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG: GstAudioRingBufferFormatType = 4;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_GSM: GstAudioRingBufferFormatType = 5;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IEC958: GstAudioRingBufferFormatType = 6;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3: GstAudioRingBufferFormatType = 7;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_EAC3: GstAudioRingBufferFormatType = 8;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS: GstAudioRingBufferFormatType = 9;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC: GstAudioRingBufferFormatType = 10;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC: GstAudioRingBufferFormatType = 11;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC_RAW: GstAudioRingBufferFormatType = 12;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC_RAW: GstAudioRingBufferFormatType = 13;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC: GstAudioRingBufferFormatType = 14;

pub type GstAudioRingBufferState = c_int;
pub const GST_AUDIO_RING_BUFFER_STATE_STOPPED: GstAudioRingBufferState = 0;
pub const GST_AUDIO_RING_BUFFER_STATE_PAUSED: GstAudioRingBufferState = 1;
pub const GST_AUDIO_RING_BUFFER_STATE_STARTED: GstAudioRingBufferState = 2;
pub const GST_AUDIO_RING_BUFFER_STATE_ERROR: GstAudioRingBufferState = 3;

pub type GstStreamVolumeFormat = c_int;
pub const GST_STREAM_VOLUME_FORMAT_LINEAR: GstStreamVolumeFormat = 0;
pub const GST_STREAM_VOLUME_FORMAT_CUBIC: GstStreamVolumeFormat = 1;
pub const GST_STREAM_VOLUME_FORMAT_DB: GstStreamVolumeFormat = 2;

// Constants
pub const GST_AUDIO_CHANNELS_RANGE: *const c_char = b"(int) [ 1, max ]\0" as *const u8 as *const c_char;
pub const GST_AUDIO_CONVERTER_OPT_DITHER_METHOD: *const c_char = b"GstAudioConverter.dither-method\0" as *const u8 as *const c_char;
pub const GST_AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD: *const c_char = b"GstAudioConverter.noise-shaping-method\0" as *const u8 as *const c_char;
pub const GST_AUDIO_CONVERTER_OPT_QUANTIZATION: *const c_char = b"GstAudioConverter.quantization\0" as *const u8 as *const c_char;
pub const GST_AUDIO_CONVERTER_OPT_RESAMPLER_METHOD: *const c_char = b"GstAudioConverter.resampler-method\0" as *const u8 as *const c_char;
pub const GST_AUDIO_DECODER_MAX_ERRORS: c_int = 10;
pub const GST_AUDIO_DECODER_SINK_NAME: *const c_char = b"sink\0" as *const u8 as *const c_char;
pub const GST_AUDIO_DECODER_SRC_NAME: *const c_char = b"src\0" as *const u8 as *const c_char;
pub const GST_AUDIO_DEF_CHANNELS: c_int = 2;
pub const GST_AUDIO_DEF_FORMAT: *const c_char = b"S16LE\0" as *const u8 as *const c_char;
pub const GST_AUDIO_DEF_RATE: c_int = 44100;
pub const GST_AUDIO_ENCODER_SINK_NAME: *const c_char = b"sink\0" as *const u8 as *const c_char;
pub const GST_AUDIO_ENCODER_SRC_NAME: *const c_char = b"src\0" as *const u8 as *const c_char;
pub const GST_AUDIO_FORMATS_ALL: *const c_char = b" { S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE }\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RATE_RANGE: *const c_char = b"(int) [ 1, max ]\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_CUBIC_B: *const c_char = b"GstAudioResampler.cubic-b\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_CUBIC_C: *const c_char = b"GstAudioResampler.cubic-c\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_CUTOFF: *const c_char = b"GstAudioResampler.cutoff\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_INTERPOLATION: *const c_char = b"GstAudioResampler.filter-interpolation\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_MODE: *const c_char = b"GstAudioResampler.filter-mode\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_MODE_THRESHOLD: *const c_char = b"GstAudioResampler.filter-mode-threshold\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_OVERSAMPLE: *const c_char = b"GstAudioResampler.filter-oversample\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_MAX_PHASE_ERROR: *const c_char = b"GstAudioResampler.max-phase-error\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_N_TAPS: *const c_char = b"GstAudioResampler.n-taps\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_STOP_ATTENUATION: *const c_char = b"GstAudioResampler.stop-attenutation\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_TRANSITION_BANDWIDTH: *const c_char = b"GstAudioResampler.transition-bandwidth\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_QUALITY_DEFAULT: c_int = 4;
pub const GST_AUDIO_RESAMPLER_QUALITY_MAX: c_int = 10;
pub const GST_AUDIO_RESAMPLER_QUALITY_MIN: c_int = 0;
pub const GST_META_TAG_AUDIO_CHANNELS_STR: *const c_char = b"channels\0" as *const u8 as *const c_char;
pub const GST_META_TAG_AUDIO_RATE_STR: *const c_char = b"rate\0" as *const u8 as *const c_char;
pub const GST_META_TAG_AUDIO_STR: *const c_char = b"audio\0" as *const u8 as *const c_char;

// Flags
bitflags! {
    #[repr(C)]
    pub struct GstAudioChannelMixerFlags: c_uint {
        const NONE = 0;
        const NON_INTERLEAVED_IN = 1;
        const NON_INTERLEAVED_OUT = 2;
        const UNPOSITIONED_IN = 4;
        const UNPOSITIONED_OUT = 8;
    }
}
pub const GST_AUDIO_CHANNEL_MIXER_FLAGS_NONE: GstAudioChannelMixerFlags = GstAudioChannelMixerFlags::NONE;
pub const GST_AUDIO_CHANNEL_MIXER_FLAGS_NON_INTERLEAVED_IN: GstAudioChannelMixerFlags = GstAudioChannelMixerFlags::NON_INTERLEAVED_IN;
pub const GST_AUDIO_CHANNEL_MIXER_FLAGS_NON_INTERLEAVED_OUT: GstAudioChannelMixerFlags = GstAudioChannelMixerFlags::NON_INTERLEAVED_OUT;
pub const GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_IN: GstAudioChannelMixerFlags = GstAudioChannelMixerFlags::UNPOSITIONED_IN;
pub const GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_OUT: GstAudioChannelMixerFlags = GstAudioChannelMixerFlags::UNPOSITIONED_OUT;

bitflags! {
    #[repr(C)]
    pub struct GstAudioConverterFlags: c_uint {
        const NONE = 0;
        const IN_WRITABLE = 1;
        const VARIABLE_RATE = 2;
    }
}
pub const GST_AUDIO_CONVERTER_FLAG_NONE: GstAudioConverterFlags = GstAudioConverterFlags::NONE;
pub const GST_AUDIO_CONVERTER_FLAG_IN_WRITABLE: GstAudioConverterFlags = GstAudioConverterFlags::IN_WRITABLE;
pub const GST_AUDIO_CONVERTER_FLAG_VARIABLE_RATE: GstAudioConverterFlags = GstAudioConverterFlags::VARIABLE_RATE;

bitflags! {
    #[repr(C)]
    pub struct GstAudioFlags: c_uint {
        const NONE = 0;
        const UNPOSITIONED = 1;
    }
}
pub const GST_AUDIO_FLAG_NONE: GstAudioFlags = GstAudioFlags::NONE;
pub const GST_AUDIO_FLAG_UNPOSITIONED: GstAudioFlags = GstAudioFlags::UNPOSITIONED;

bitflags! {
    #[repr(C)]
    pub struct GstAudioFormatFlags: c_uint {
        const INTEGER = 1;
        const FLOAT = 2;
        const SIGNED = 4;
        const COMPLEX = 16;
        const UNPACK = 32;
    }
}
pub const GST_AUDIO_FORMAT_FLAG_INTEGER: GstAudioFormatFlags = GstAudioFormatFlags::INTEGER;
pub const GST_AUDIO_FORMAT_FLAG_FLOAT: GstAudioFormatFlags = GstAudioFormatFlags::FLOAT;
pub const GST_AUDIO_FORMAT_FLAG_SIGNED: GstAudioFormatFlags = GstAudioFormatFlags::SIGNED;
pub const GST_AUDIO_FORMAT_FLAG_COMPLEX: GstAudioFormatFlags = GstAudioFormatFlags::COMPLEX;
pub const GST_AUDIO_FORMAT_FLAG_UNPACK: GstAudioFormatFlags = GstAudioFormatFlags::UNPACK;

bitflags! {
    #[repr(C)]
    pub struct GstAudioPackFlags: c_uint {
        const NONE = 0;
        const TRUNCATE_RANGE = 1;
    }
}
pub const GST_AUDIO_PACK_FLAG_NONE: GstAudioPackFlags = GstAudioPackFlags::NONE;
pub const GST_AUDIO_PACK_FLAG_TRUNCATE_RANGE: GstAudioPackFlags = GstAudioPackFlags::TRUNCATE_RANGE;

bitflags! {
    #[repr(C)]
    pub struct GstAudioQuantizeFlags: c_uint {
        const NONE = 0;
        const NON_INTERLEAVED = 1;
    }
}
pub const GST_AUDIO_QUANTIZE_FLAG_NONE: GstAudioQuantizeFlags = GstAudioQuantizeFlags::NONE;
pub const GST_AUDIO_QUANTIZE_FLAG_NON_INTERLEAVED: GstAudioQuantizeFlags = GstAudioQuantizeFlags::NON_INTERLEAVED;

bitflags! {
    #[repr(C)]
    pub struct GstAudioResamplerFlags: c_uint {
        const NONE = 0;
        const NON_INTERLEAVED_IN = 1;
        const NON_INTERLEAVED_OUT = 2;
        const VARIABLE_RATE = 4;
    }
}
pub const GST_AUDIO_RESAMPLER_FLAG_NONE: GstAudioResamplerFlags = GstAudioResamplerFlags::NONE;
pub const GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_IN: GstAudioResamplerFlags = GstAudioResamplerFlags::NON_INTERLEAVED_IN;
pub const GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_OUT: GstAudioResamplerFlags = GstAudioResamplerFlags::NON_INTERLEAVED_OUT;
pub const GST_AUDIO_RESAMPLER_FLAG_VARIABLE_RATE: GstAudioResamplerFlags = GstAudioResamplerFlags::VARIABLE_RATE;

// Callbacks
pub type GstAudioBaseSinkCustomSlavingCallback = Option<unsafe extern "C" fn(*mut GstAudioBaseSink, gst::GstClockTime, gst::GstClockTime, *mut gst::GstClockTimeDiff, GstAudioBaseSinkDiscontReason, gpointer)>;
pub type GstAudioClockGetTimeFunc = Option<unsafe extern "C" fn(*mut gst::GstClock, gpointer) -> gst::GstClockTime>;
pub type GstAudioFormatPack = Option<unsafe extern "C" fn(*const GstAudioFormatInfo, GstAudioPackFlags, gpointer, gpointer, c_int)>;
pub type GstAudioFormatUnpack = Option<unsafe extern "C" fn(*const GstAudioFormatInfo, GstAudioPackFlags, gpointer, gpointer, c_int)>;
pub type GstAudioRingBufferCallback = Option<unsafe extern "C" fn(*mut GstAudioRingBuffer, *mut u8, c_uint, gpointer)>;

// Records
#[repr(C)]
pub struct GstAudioBaseSinkClass {
    pub parent_class: gst_base::GstBaseSinkClass,
    pub create_ringbuffer: Option<unsafe extern "C" fn(*mut GstAudioBaseSink) -> *mut GstAudioRingBuffer>,
    pub payload: Option<unsafe extern "C" fn(*mut GstAudioBaseSink, *mut gst::GstBuffer) -> *mut gst::GstBuffer>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioBaseSinkClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioBaseSinkClass @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioBaseSinkPrivate(c_void);

impl ::std::fmt::Debug for GstAudioBaseSinkPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioBaseSinkPrivate @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioBaseSrcClass {
    pub parent_class: gst_base::GstPushSrcClass,
    pub create_ringbuffer: Option<unsafe extern "C" fn(*mut GstAudioBaseSrc) -> *mut GstAudioRingBuffer>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioBaseSrcClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioBaseSrcClass @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioBaseSrcPrivate(c_void);

impl ::std::fmt::Debug for GstAudioBaseSrcPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioBaseSrcPrivate @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioCdSrcClass {
    pub pushsrc_class: gst_base::GstPushSrcClass,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioCdSrc, *const c_char) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioCdSrc)>,
    pub read_sector: Option<unsafe extern "C" fn(*mut GstAudioCdSrc, c_int) -> *mut gst::GstBuffer>,
    pub _gst_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GstAudioCdSrcClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioCdSrcClass @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioCdSrcPrivate(c_void);

impl ::std::fmt::Debug for GstAudioCdSrcPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioCdSrcPrivate @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioCdSrcTrack {
    pub is_audio: gboolean,
    pub num: c_uint,
    pub start: c_uint,
    pub end: c_uint,
    pub tags: *mut gst::GstTagList,
    pub _gst_reserved1: [c_uint; 2],
    pub _gst_reserved2: [gpointer; 2],
}

impl ::std::fmt::Debug for GstAudioCdSrcTrack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioCdSrcTrack @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioChannelMixer(c_void);

impl ::std::fmt::Debug for GstAudioChannelMixer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioChannelMixer @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioClippingMeta {
    pub meta: gst::GstMeta,
    pub format: gst::GstFormat,
    pub start: u64,
    pub end: u64,
}

impl ::std::fmt::Debug for GstAudioClippingMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioClippingMeta @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioClockClass {
    pub parent_class: gst::GstSystemClockClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioClockClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioClockClass @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioConverter(c_void);

impl ::std::fmt::Debug for GstAudioConverter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioConverter @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioDecoderClass {
    pub element_class: gst::GstElementClass,
    pub start: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub set_format: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstCaps) -> gboolean>,
    pub parse: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst_base::GstAdapter, *mut c_int, *mut c_int) -> gst::GstFlowReturn>,
    pub handle_frame: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub flush: Option<unsafe extern "C" fn(*mut GstAudioDecoder, gboolean)>,
    pub pre_push: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub sink_event: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstEvent) -> gboolean>,
    pub src_event: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstEvent) -> gboolean>,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub negotiate: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub decide_allocation: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub propose_allocation: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub sink_query: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub src_query: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub getcaps: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub transform_meta: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstBuffer, *mut gst::GstMeta, *mut gst::GstBuffer) -> gboolean>,
    pub _gst_reserved: [gpointer; 16],
}

impl ::std::fmt::Debug for GstAudioDecoderClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioDecoderClass @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioDecoderPrivate(c_void);

impl ::std::fmt::Debug for GstAudioDecoderPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioDecoderPrivate @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioDownmixMeta {
    pub meta: gst::GstMeta,
    pub from_position: *mut GstAudioChannelPosition,
    pub to_position: *mut GstAudioChannelPosition,
    pub from_channels: c_int,
    pub to_channels: c_int,
    pub matrix: *mut *mut c_float,
}

impl ::std::fmt::Debug for GstAudioDownmixMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioDownmixMeta @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioEncoderClass {
    pub element_class: gst::GstElementClass,
    pub start: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub set_format: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut GstAudioInfo) -> gboolean>,
    pub handle_frame: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub flush: Option<unsafe extern "C" fn(*mut GstAudioEncoder)>,
    pub pre_push: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub sink_event: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstEvent) -> gboolean>,
    pub src_event: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstEvent) -> gboolean>,
    pub getcaps: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub negotiate: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub decide_allocation: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub propose_allocation: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub transform_meta: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstBuffer, *mut gst::GstMeta, *mut gst::GstBuffer) -> gboolean>,
    pub sink_query: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub src_query: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub _gst_reserved: [gpointer; 17],
}

impl ::std::fmt::Debug for GstAudioEncoderClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioEncoderClass @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioEncoderPrivate(c_void);

impl ::std::fmt::Debug for GstAudioEncoderPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioEncoderPrivate @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioFilterClass {
    pub basetransformclass: gst_base::GstBaseTransformClass,
    pub setup: Option<unsafe extern "C" fn(*mut GstAudioFilter, *const GstAudioInfo) -> gboolean>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioFilterClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioFilterClass @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioFormatInfo {
    pub format: GstAudioFormat,
    pub name: *const c_char,
    pub description: *const c_char,
    pub flags: GstAudioFormatFlags,
    pub endianness: c_int,
    pub width: c_int,
    pub depth: c_int,
    pub silence: [u8; 8],
    pub unpack_format: GstAudioFormat,
    pub unpack_func: GstAudioFormatUnpack,
    pub pack_func: GstAudioFormatPack,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioFormatInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioFormatInfo @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioInfo {
    pub finfo: *const GstAudioFormatInfo,
    pub flags: GstAudioFlags,
    pub layout: GstAudioLayout,
    pub rate: c_int,
    pub channels: c_int,
    pub bpf: c_int,
    pub position: [GstAudioChannelPosition; 64],
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioInfo @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioQuantize(c_void);

impl ::std::fmt::Debug for GstAudioQuantize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioQuantize @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioResampler(c_void);

impl ::std::fmt::Debug for GstAudioResampler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioResampler @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioRingBufferClass {
    pub parent_class: gst::GstObjectClass,
    pub open_device: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub acquire: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer, *mut GstAudioRingBufferSpec) -> gboolean>,
    pub release: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub close_device: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub pause: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub resume: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub delay: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> c_uint>,
    pub activate: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer, gboolean) -> gboolean>,
    pub commit: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer, *mut u64, *mut u8, c_int, c_int, *mut c_int) -> c_uint>,
    pub clear_all: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioRingBufferClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioRingBufferClass @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioRingBufferSpec {
    pub caps: *mut gst::GstCaps,
    pub type_: GstAudioRingBufferFormatType,
    pub info: GstAudioInfo,
    pub latency_time: u64,
    pub buffer_time: u64,
    pub segsize: c_int,
    pub segtotal: c_int,
    pub seglatency: c_int,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioRingBufferSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioRingBufferSpec @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioSinkClass {
    pub parent_class: GstAudioBaseSinkClass,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioSink) -> gboolean>,
    pub prepare: Option<unsafe extern "C" fn(*mut GstAudioSink, *mut GstAudioRingBufferSpec) -> gboolean>,
    pub unprepare: Option<unsafe extern "C" fn(*mut GstAudioSink) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioSink) -> gboolean>,
    pub write: Option<unsafe extern "C" fn(*mut GstAudioSink, gpointer, c_uint) -> c_int>,
    pub delay: Option<unsafe extern "C" fn(*mut GstAudioSink) -> c_uint>,
    pub reset: Option<unsafe extern "C" fn(*mut GstAudioSink)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioSinkClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioSinkClass @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstAudioSrcClass {
    pub parent_class: GstAudioBaseSrcClass,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> gboolean>,
    pub prepare: Option<unsafe extern "C" fn(*mut GstAudioSrc, *mut GstAudioRingBufferSpec) -> gboolean>,
    pub unprepare: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> gboolean>,
    pub read: Option<unsafe extern "C" fn(*mut GstAudioSrc, gpointer, c_uint, *mut gst::GstClockTime) -> c_uint>,
    pub delay: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> c_uint>,
    pub reset: Option<unsafe extern "C" fn(*mut GstAudioSrc)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioSrcClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstAudioSrcClass @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstStreamVolumeInterface {
    pub iface: gobject::GTypeInterface,
}

impl ::std::fmt::Debug for GstStreamVolumeInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstStreamVolumeInterface @ {:?}", self as *const _)
    }
}

// Classes
#[repr(C)]
pub struct GstAudioBaseSink {
    pub element: gst_base::GstBaseSink,
    pub ringbuffer: *mut GstAudioRingBuffer,
    pub buffer_time: u64,
    pub latency_time: u64,
    pub next_sample: u64,
    pub provided_clock: *mut gst::GstClock,
    pub eos_rendering: gboolean,
    pub priv_: *mut GstAudioBaseSinkPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioBaseSink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioBaseSink @ {:?}", self as *const _))
         .field("element", &self.element)
         .field("ringbuffer", &self.ringbuffer)
         .field("buffer_time", &self.buffer_time)
         .field("latency_time", &self.latency_time)
         .field("next_sample", &self.next_sample)
         .field("provided_clock", &self.provided_clock)
         .field("eos_rendering", &self.eos_rendering)
         .field("priv_", &self.priv_)
         .field("_gst_reserved", &self._gst_reserved)
         .finish()
    }
}

#[repr(C)]
pub struct GstAudioBaseSrc {
    pub element: gst_base::GstPushSrc,
    pub ringbuffer: *mut GstAudioRingBuffer,
    pub buffer_time: gst::GstClockTime,
    pub latency_time: gst::GstClockTime,
    pub next_sample: u64,
    pub clock: *mut gst::GstClock,
    pub priv_: *mut GstAudioBaseSrcPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioBaseSrc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioBaseSrc @ {:?}", self as *const _))
         .field("element", &self.element)
         .field("ringbuffer", &self.ringbuffer)
         .field("buffer_time", &self.buffer_time)
         .field("latency_time", &self.latency_time)
         .field("next_sample", &self.next_sample)
         .field("clock", &self.clock)
         .field("priv_", &self.priv_)
         .field("_gst_reserved", &self._gst_reserved)
         .finish()
    }
}

#[repr(C)]
pub struct GstAudioCdSrc {
    pub pushsrc: gst_base::GstPushSrc,
    pub tags: *mut gst::GstTagList,
    pub priv_: *mut GstAudioCdSrcPrivate,
    pub _gst_reserved1: [c_uint; 2],
    pub _gst_reserved2: [gpointer; 2],
}

impl ::std::fmt::Debug for GstAudioCdSrc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioCdSrc @ {:?}", self as *const _))
         .field("pushsrc", &self.pushsrc)
         .field("tags", &self.tags)
         .field("priv_", &self.priv_)
         .field("_gst_reserved1", &self._gst_reserved1)
         .field("_gst_reserved2", &self._gst_reserved2)
         .finish()
    }
}

#[repr(C)]
pub struct GstAudioClock {
    pub clock: gst::GstSystemClock,
    pub func: GstAudioClockGetTimeFunc,
    pub user_data: gpointer,
    pub destroy_notify: glib::GDestroyNotify,
    pub last_time: gst::GstClockTime,
    pub time_offset: gst::GstClockTimeDiff,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioClock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioClock @ {:?}", self as *const _))
         .field("clock", &self.clock)
         .field("func", &self.func)
         .field("user_data", &self.user_data)
         .field("destroy_notify", &self.destroy_notify)
         .field("last_time", &self.last_time)
         .field("time_offset", &self.time_offset)
         .field("_gst_reserved", &self._gst_reserved)
         .finish()
    }
}

#[repr(C)]
pub struct GstAudioDecoder {
    pub element: gst::GstElement,
    pub sinkpad: *mut gst::GstPad,
    pub srcpad: *mut gst::GstPad,
    pub stream_lock: glib::GRecMutex,
    pub input_segment: gst::GstSegment,
    pub output_segment: gst::GstSegment,
    pub priv_: *mut GstAudioDecoderPrivate,
    pub _gst_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GstAudioDecoder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioDecoder @ {:?}", self as *const _))
         .field("element", &self.element)
         .field("sinkpad", &self.sinkpad)
         .field("srcpad", &self.srcpad)
         .field("stream_lock", &self.stream_lock)
         .field("input_segment", &self.input_segment)
         .field("output_segment", &self.output_segment)
         .field("priv_", &self.priv_)
         .field("_gst_reserved", &self._gst_reserved)
         .finish()
    }
}

#[repr(C)]
pub struct GstAudioEncoder {
    pub element: gst::GstElement,
    pub sinkpad: *mut gst::GstPad,
    pub srcpad: *mut gst::GstPad,
    pub stream_lock: glib::GRecMutex,
    pub input_segment: gst::GstSegment,
    pub output_segment: gst::GstSegment,
    pub priv_: *mut GstAudioEncoderPrivate,
    pub _gst_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GstAudioEncoder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioEncoder @ {:?}", self as *const _))
         .field("element", &self.element)
         .field("sinkpad", &self.sinkpad)
         .field("srcpad", &self.srcpad)
         .field("stream_lock", &self.stream_lock)
         .field("input_segment", &self.input_segment)
         .field("output_segment", &self.output_segment)
         .field("priv_", &self.priv_)
         .field("_gst_reserved", &self._gst_reserved)
         .finish()
    }
}

#[repr(C)]
pub struct GstAudioFilter {
    pub basetransform: gst_base::GstBaseTransform,
    pub info: GstAudioInfo,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioFilter @ {:?}", self as *const _))
         .field("basetransform", &self.basetransform)
         .field("info", &self.info)
         .field("_gst_reserved", &self._gst_reserved)
         .finish()
    }
}

#[repr(C)]
pub struct GstAudioRingBuffer {
    pub object: gst::GstObject,
    pub cond: glib::GCond,
    pub open: gboolean,
    pub acquired: gboolean,
    pub memory: *mut u8,
    pub size: size_t,
    pub timestamps: *mut gst::GstClockTime,
    pub spec: GstAudioRingBufferSpec,
    pub samples_per_seg: c_int,
    pub empty_seg: *mut u8,
    pub state: c_int,
    pub segdone: c_int,
    pub segbase: c_int,
    pub waiting: c_int,
    pub callback: GstAudioRingBufferCallback,
    pub cb_data: gpointer,
    pub need_reorder: gboolean,
    pub channel_reorder_map: [c_int; 64],
    pub flushing: gboolean,
    pub may_start: c_int,
    pub active: gboolean,
    pub cb_data_notify: glib::GDestroyNotify,
    pub _gst_reserved: [gpointer; 3],
}

impl ::std::fmt::Debug for GstAudioRingBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioRingBuffer @ {:?}", self as *const _))
         .field("object", &self.object)
         .field("cond", &self.cond)
         .field("open", &self.open)
         .field("acquired", &self.acquired)
         .field("memory", &self.memory)
         .field("size", &self.size)
         .field("timestamps", &self.timestamps)
         .field("spec", &self.spec)
         .field("samples_per_seg", &self.samples_per_seg)
         .field("empty_seg", &self.empty_seg)
         .field("state", &self.state)
         .field("segdone", &self.segdone)
         .field("segbase", &self.segbase)
         .field("waiting", &self.waiting)
         .field("callback", &self.callback)
         .field("cb_data", &self.cb_data)
         .field("need_reorder", &self.need_reorder)
         .field("channel_reorder_map", &format!("{:?}", &self.channel_reorder_map as *const _))
         .field("flushing", &self.flushing)
         .field("may_start", &self.may_start)
         .field("active", &self.active)
         .field("cb_data_notify", &self.cb_data_notify)
         .field("_gst_reserved", &self._gst_reserved)
         .finish()
    }
}

#[repr(C)]
pub struct GstAudioSink {
    pub element: GstAudioBaseSink,
    pub thread: *mut glib::GThread,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioSink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioSink @ {:?}", self as *const _))
         .field("element", &self.element)
         .field("thread", &self.thread)
         .field("_gst_reserved", &self._gst_reserved)
         .finish()
    }
}

#[repr(C)]
pub struct GstAudioSrc {
    pub element: GstAudioBaseSrc,
    pub thread: *mut glib::GThread,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioSrc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioSrc @ {:?}", self as *const _))
         .field("element", &self.element)
         .field("thread", &self.thread)
         .field("_gst_reserved", &self._gst_reserved)
         .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct GstStreamVolume(c_void);

impl ::std::fmt::Debug for GstStreamVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstStreamVolume @ {:?}", self as *const _)
    }
}


extern "C" {

    //=========================================================================
    // GstAudioBaseSinkDiscontReason
    //=========================================================================
    pub fn gst_audio_base_sink_discont_reason_get_type() -> GType;

    //=========================================================================
    // GstAudioBaseSinkSlaveMethod
    //=========================================================================
    pub fn gst_audio_base_sink_slave_method_get_type() -> GType;

    //=========================================================================
    // GstAudioBaseSrcSlaveMethod
    //=========================================================================
    pub fn gst_audio_base_src_slave_method_get_type() -> GType;

    //=========================================================================
    // GstAudioCdSrcMode
    //=========================================================================
    pub fn gst_audio_cd_src_mode_get_type() -> GType;

    //=========================================================================
    // GstAudioChannelPosition
    //=========================================================================
    pub fn gst_audio_channel_position_get_type() -> GType;

    //=========================================================================
    // GstAudioDitherMethod
    //=========================================================================
    pub fn gst_audio_dither_method_get_type() -> GType;

    //=========================================================================
    // GstAudioFormat
    //=========================================================================
    pub fn gst_audio_format_get_type() -> GType;
    pub fn gst_audio_format_build_integer(sign: gboolean, endianness: c_int, width: c_int, depth: c_int) -> GstAudioFormat;
    pub fn gst_audio_format_fill_silence(info: *const GstAudioFormatInfo, dest: gpointer, length: size_t);
    pub fn gst_audio_format_from_string(format: *const c_char) -> GstAudioFormat;
    pub fn gst_audio_format_get_info(format: GstAudioFormat) -> *const GstAudioFormatInfo;
    pub fn gst_audio_format_to_string(format: GstAudioFormat) -> *const c_char;

    //=========================================================================
    // GstAudioLayout
    //=========================================================================
    pub fn gst_audio_layout_get_type() -> GType;

    //=========================================================================
    // GstAudioNoiseShapingMethod
    //=========================================================================
    pub fn gst_audio_noise_shaping_method_get_type() -> GType;

    //=========================================================================
    // GstAudioResamplerFilterInterpolation
    //=========================================================================
    pub fn gst_audio_resampler_filter_interpolation_get_type() -> GType;

    //=========================================================================
    // GstAudioResamplerFilterMode
    //=========================================================================
    pub fn gst_audio_resampler_filter_mode_get_type() -> GType;

    //=========================================================================
    // GstAudioResamplerMethod
    //=========================================================================
    pub fn gst_audio_resampler_method_get_type() -> GType;

    //=========================================================================
    // GstAudioRingBufferFormatType
    //=========================================================================
    pub fn gst_audio_ring_buffer_format_type_get_type() -> GType;

    //=========================================================================
    // GstAudioRingBufferState
    //=========================================================================
    pub fn gst_audio_ring_buffer_state_get_type() -> GType;

    //=========================================================================
    // GstAudioChannelMixerFlags
    //=========================================================================
    pub fn gst_audio_channel_mixer_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioConverterFlags
    //=========================================================================
    pub fn gst_audio_converter_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioFlags
    //=========================================================================
    pub fn gst_audio_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioFormatFlags
    //=========================================================================
    pub fn gst_audio_format_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioPackFlags
    //=========================================================================
    pub fn gst_audio_pack_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioQuantizeFlags
    //=========================================================================
    pub fn gst_audio_quantize_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioResamplerFlags
    //=========================================================================
    pub fn gst_audio_resampler_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioChannelMixer
    //=========================================================================
    pub fn gst_audio_channel_mixer_free(mix: *mut GstAudioChannelMixer);
    pub fn gst_audio_channel_mixer_is_passthrough(mix: *mut GstAudioChannelMixer) -> gboolean;
    pub fn gst_audio_channel_mixer_samples(mix: *mut GstAudioChannelMixer, in_: gpointer, out: gpointer, samples: c_int);
    pub fn gst_audio_channel_mixer_new(flags: GstAudioChannelMixerFlags, format: GstAudioFormat, in_channels: c_int, in_position: *mut GstAudioChannelPosition, out_channels: c_int, out_position: *mut GstAudioChannelPosition) -> *mut GstAudioChannelMixer;

    //=========================================================================
    // GstAudioClippingMeta
    //=========================================================================
    pub fn gst_audio_clipping_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstAudioConverter
    //=========================================================================
    pub fn gst_audio_converter_free(convert: *mut GstAudioConverter);
    pub fn gst_audio_converter_get_config(convert: *mut GstAudioConverter, in_rate: *mut c_int, out_rate: *mut c_int) -> *const gst::GstStructure;
    pub fn gst_audio_converter_get_in_frames(convert: *mut GstAudioConverter, out_frames: size_t) -> size_t;
    pub fn gst_audio_converter_get_max_latency(convert: *mut GstAudioConverter) -> size_t;
    pub fn gst_audio_converter_get_out_frames(convert: *mut GstAudioConverter, in_frames: size_t) -> size_t;
    pub fn gst_audio_converter_reset(convert: *mut GstAudioConverter);
    pub fn gst_audio_converter_samples(convert: *mut GstAudioConverter, flags: GstAudioConverterFlags, in_: gpointer, in_frames: size_t, out: gpointer, out_frames: size_t) -> gboolean;
    pub fn gst_audio_converter_supports_inplace(convert: *mut GstAudioConverter) -> gboolean;
    pub fn gst_audio_converter_update_config(convert: *mut GstAudioConverter, in_rate: c_int, out_rate: c_int, config: *mut gst::GstStructure) -> gboolean;
    pub fn gst_audio_converter_new(flags: GstAudioConverterFlags, in_info: *mut GstAudioInfo, out_info: *mut GstAudioInfo, config: *mut gst::GstStructure) -> *mut GstAudioConverter;

    //=========================================================================
    // GstAudioDownmixMeta
    //=========================================================================
    pub fn gst_audio_downmix_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstAudioFilterClass
    //=========================================================================
    pub fn gst_audio_filter_class_add_pad_templates(klass: *mut GstAudioFilterClass, allowed_caps: *mut gst::GstCaps);

    //=========================================================================
    // GstAudioInfo
    //=========================================================================
    pub fn gst_audio_info_get_type() -> GType;
    pub fn gst_audio_info_new() -> *mut GstAudioInfo;
    pub fn gst_audio_info_convert(info: *const GstAudioInfo, src_fmt: gst::GstFormat, src_val: i64, dest_fmt: gst::GstFormat, dest_val: *mut i64) -> gboolean;
    pub fn gst_audio_info_copy(info: *const GstAudioInfo) -> *mut GstAudioInfo;
    pub fn gst_audio_info_free(info: *mut GstAudioInfo);
    pub fn gst_audio_info_from_caps(info: *mut GstAudioInfo, caps: *const gst::GstCaps) -> gboolean;
    pub fn gst_audio_info_init(info: *mut GstAudioInfo);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_audio_info_is_equal(info: *const GstAudioInfo, other: *const GstAudioInfo) -> gboolean;
    pub fn gst_audio_info_set_format(info: *mut GstAudioInfo, format: GstAudioFormat, rate: c_int, channels: c_int, position: *const GstAudioChannelPosition);
    pub fn gst_audio_info_to_caps(info: *const GstAudioInfo) -> *mut gst::GstCaps;

    //=========================================================================
    // GstAudioQuantize
    //=========================================================================
    pub fn gst_audio_quantize_free(quant: *mut GstAudioQuantize);
    pub fn gst_audio_quantize_reset(quant: *mut GstAudioQuantize);
    pub fn gst_audio_quantize_samples(quant: *mut GstAudioQuantize, in_: gpointer, out: gpointer, samples: c_uint);
    pub fn gst_audio_quantize_new(dither: GstAudioDitherMethod, ns: GstAudioNoiseShapingMethod, flags: GstAudioQuantizeFlags, format: GstAudioFormat, channels: c_uint, quantizer: c_uint) -> *mut GstAudioQuantize;

    //=========================================================================
    // GstAudioResampler
    //=========================================================================
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_audio_resampler_free(resampler: *mut GstAudioResampler);
    pub fn gst_audio_resampler_get_in_frames(resampler: *mut GstAudioResampler, out_frames: size_t) -> size_t;
    pub fn gst_audio_resampler_get_max_latency(resampler: *mut GstAudioResampler) -> size_t;
    pub fn gst_audio_resampler_get_out_frames(resampler: *mut GstAudioResampler, in_frames: size_t) -> size_t;
    pub fn gst_audio_resampler_resample(resampler: *mut GstAudioResampler, in_: gpointer, in_frames: size_t, out: gpointer, out_frames: size_t);
    pub fn gst_audio_resampler_reset(resampler: *mut GstAudioResampler);
    pub fn gst_audio_resampler_update(resampler: *mut GstAudioResampler, in_rate: c_int, out_rate: c_int, options: *mut gst::GstStructure) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_audio_resampler_new(method: GstAudioResamplerMethod, flags: GstAudioResamplerFlags, format: GstAudioFormat, channels: c_int, in_rate: c_int, out_rate: c_int, options: *mut gst::GstStructure) -> *mut GstAudioResampler;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_audio_resampler_options_set_quality(method: GstAudioResamplerMethod, quality: c_uint, in_rate: c_int, out_rate: c_int, options: *mut gst::GstStructure);

    //=========================================================================
    // GstAudioBaseSink
    //=========================================================================
    pub fn gst_audio_base_sink_get_type() -> GType;
    pub fn gst_audio_base_sink_create_ringbuffer(sink: *mut GstAudioBaseSink) -> *mut GstAudioRingBuffer;
    pub fn gst_audio_base_sink_get_alignment_threshold(sink: *mut GstAudioBaseSink) -> gst::GstClockTime;
    pub fn gst_audio_base_sink_get_discont_wait(sink: *mut GstAudioBaseSink) -> gst::GstClockTime;
    pub fn gst_audio_base_sink_get_drift_tolerance(sink: *mut GstAudioBaseSink) -> i64;
    pub fn gst_audio_base_sink_get_provide_clock(sink: *mut GstAudioBaseSink) -> gboolean;
    pub fn gst_audio_base_sink_get_slave_method(sink: *mut GstAudioBaseSink) -> GstAudioBaseSinkSlaveMethod;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_audio_base_sink_report_device_failure(sink: *mut GstAudioBaseSink);
    pub fn gst_audio_base_sink_set_alignment_threshold(sink: *mut GstAudioBaseSink, alignment_threshold: gst::GstClockTime);
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_audio_base_sink_set_custom_slaving_callback(sink: *mut GstAudioBaseSink, callback: GstAudioBaseSinkCustomSlavingCallback, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_audio_base_sink_set_discont_wait(sink: *mut GstAudioBaseSink, discont_wait: gst::GstClockTime);
    pub fn gst_audio_base_sink_set_drift_tolerance(sink: *mut GstAudioBaseSink, drift_tolerance: i64);
    pub fn gst_audio_base_sink_set_provide_clock(sink: *mut GstAudioBaseSink, provide: gboolean);
    pub fn gst_audio_base_sink_set_slave_method(sink: *mut GstAudioBaseSink, method: GstAudioBaseSinkSlaveMethod);

    //=========================================================================
    // GstAudioBaseSrc
    //=========================================================================
    pub fn gst_audio_base_src_get_type() -> GType;
    pub fn gst_audio_base_src_create_ringbuffer(src: *mut GstAudioBaseSrc) -> *mut GstAudioRingBuffer;
    pub fn gst_audio_base_src_get_provide_clock(src: *mut GstAudioBaseSrc) -> gboolean;
    pub fn gst_audio_base_src_get_slave_method(src: *mut GstAudioBaseSrc) -> GstAudioBaseSrcSlaveMethod;
    pub fn gst_audio_base_src_set_provide_clock(src: *mut GstAudioBaseSrc, provide: gboolean);
    pub fn gst_audio_base_src_set_slave_method(src: *mut GstAudioBaseSrc, method: GstAudioBaseSrcSlaveMethod);

    //=========================================================================
    // GstAudioCdSrc
    //=========================================================================
    pub fn gst_audio_cd_src_get_type() -> GType;
    pub fn gst_audio_cd_src_add_track(src: *mut GstAudioCdSrc, track: *mut GstAudioCdSrcTrack) -> gboolean;

    //=========================================================================
    // GstAudioClock
    //=========================================================================
    pub fn gst_audio_clock_get_type() -> GType;
    pub fn gst_audio_clock_new(name: *const c_char, func: GstAudioClockGetTimeFunc, user_data: gpointer, destroy_notify: glib::GDestroyNotify) -> *mut gst::GstClock;
    pub fn gst_audio_clock_adjust(clock: *mut GstAudioClock, time: gst::GstClockTime) -> gst::GstClockTime;
    pub fn gst_audio_clock_get_time(clock: *mut GstAudioClock) -> gst::GstClockTime;
    pub fn gst_audio_clock_invalidate(clock: *mut GstAudioClock);
    pub fn gst_audio_clock_reset(clock: *mut GstAudioClock, time: gst::GstClockTime);

    //=========================================================================
    // GstAudioDecoder
    //=========================================================================
    pub fn gst_audio_decoder_get_type() -> GType;
    pub fn gst_audio_decoder_allocate_output_buffer(dec: *mut GstAudioDecoder, size: size_t) -> *mut gst::GstBuffer;
    pub fn gst_audio_decoder_finish_frame(dec: *mut GstAudioDecoder, buf: *mut gst::GstBuffer, frames: c_int) -> gst::GstFlowReturn;
    pub fn gst_audio_decoder_get_allocator(dec: *mut GstAudioDecoder, allocator: *mut *mut gst::GstAllocator, params: *mut gst::GstAllocationParams);
    pub fn gst_audio_decoder_get_audio_info(dec: *mut GstAudioDecoder) -> *mut GstAudioInfo;
    pub fn gst_audio_decoder_get_delay(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_drainable(dec: *mut GstAudioDecoder) -> gboolean;
    pub fn gst_audio_decoder_get_estimate_rate(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_latency(dec: *mut GstAudioDecoder, min: *mut gst::GstClockTime, max: *mut gst::GstClockTime);
    pub fn gst_audio_decoder_get_max_errors(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_min_latency(dec: *mut GstAudioDecoder) -> gst::GstClockTime;
    pub fn gst_audio_decoder_get_needs_format(dec: *mut GstAudioDecoder) -> gboolean;
    pub fn gst_audio_decoder_get_parse_state(dec: *mut GstAudioDecoder, sync: *mut gboolean, eos: *mut gboolean);
    pub fn gst_audio_decoder_get_plc(dec: *mut GstAudioDecoder) -> gboolean;
    pub fn gst_audio_decoder_get_plc_aware(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_tolerance(dec: *mut GstAudioDecoder) -> gst::GstClockTime;
    pub fn gst_audio_decoder_merge_tags(dec: *mut GstAudioDecoder, tags: *const gst::GstTagList, mode: gst::GstTagMergeMode);
    pub fn gst_audio_decoder_negotiate(dec: *mut GstAudioDecoder) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_audio_decoder_proxy_getcaps(decoder: *mut GstAudioDecoder, caps: *mut gst::GstCaps, filter: *mut gst::GstCaps) -> *mut gst::GstCaps;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_audio_decoder_set_allocation_caps(dec: *mut GstAudioDecoder, allocation_caps: *mut gst::GstCaps);
    pub fn gst_audio_decoder_set_drainable(dec: *mut GstAudioDecoder, enabled: gboolean);
    pub fn gst_audio_decoder_set_estimate_rate(dec: *mut GstAudioDecoder, enabled: gboolean);
    pub fn gst_audio_decoder_set_latency(dec: *mut GstAudioDecoder, min: gst::GstClockTime, max: gst::GstClockTime);
    pub fn gst_audio_decoder_set_max_errors(dec: *mut GstAudioDecoder, num: c_int);
    pub fn gst_audio_decoder_set_min_latency(dec: *mut GstAudioDecoder, num: gst::GstClockTime);
    pub fn gst_audio_decoder_set_needs_format(dec: *mut GstAudioDecoder, enabled: gboolean);
    pub fn gst_audio_decoder_set_output_format(dec: *mut GstAudioDecoder, info: *const GstAudioInfo) -> gboolean;
    pub fn gst_audio_decoder_set_plc(dec: *mut GstAudioDecoder, enabled: gboolean);
    pub fn gst_audio_decoder_set_plc_aware(dec: *mut GstAudioDecoder, plc: gboolean);
    pub fn gst_audio_decoder_set_tolerance(dec: *mut GstAudioDecoder, tolerance: gst::GstClockTime);
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_audio_decoder_set_use_default_pad_acceptcaps(decoder: *mut GstAudioDecoder, use_: gboolean);

    //=========================================================================
    // GstAudioEncoder
    //=========================================================================
    pub fn gst_audio_encoder_get_type() -> GType;
    pub fn gst_audio_encoder_allocate_output_buffer(enc: *mut GstAudioEncoder, size: size_t) -> *mut gst::GstBuffer;
    pub fn gst_audio_encoder_finish_frame(enc: *mut GstAudioEncoder, buffer: *mut gst::GstBuffer, samples: c_int) -> gst::GstFlowReturn;
    pub fn gst_audio_encoder_get_allocator(enc: *mut GstAudioEncoder, allocator: *mut *mut gst::GstAllocator, params: *mut gst::GstAllocationParams);
    pub fn gst_audio_encoder_get_audio_info(enc: *mut GstAudioEncoder) -> *mut GstAudioInfo;
    pub fn gst_audio_encoder_get_drainable(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_frame_max(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_frame_samples_max(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_frame_samples_min(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_hard_min(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_hard_resync(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_latency(enc: *mut GstAudioEncoder, min: *mut gst::GstClockTime, max: *mut gst::GstClockTime);
    pub fn gst_audio_encoder_get_lookahead(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_mark_granule(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_perfect_timestamp(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_tolerance(enc: *mut GstAudioEncoder) -> gst::GstClockTime;
    pub fn gst_audio_encoder_merge_tags(enc: *mut GstAudioEncoder, tags: *const gst::GstTagList, mode: gst::GstTagMergeMode);
    pub fn gst_audio_encoder_negotiate(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_proxy_getcaps(enc: *mut GstAudioEncoder, caps: *mut gst::GstCaps, filter: *mut gst::GstCaps) -> *mut gst::GstCaps;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_audio_encoder_set_allocation_caps(enc: *mut GstAudioEncoder, allocation_caps: *mut gst::GstCaps);
    pub fn gst_audio_encoder_set_drainable(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_frame_max(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_frame_samples_max(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_frame_samples_min(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_hard_min(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_hard_resync(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_headers(enc: *mut GstAudioEncoder, headers: *mut glib::GList);
    pub fn gst_audio_encoder_set_latency(enc: *mut GstAudioEncoder, min: gst::GstClockTime, max: gst::GstClockTime);
    pub fn gst_audio_encoder_set_lookahead(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_mark_granule(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_output_format(enc: *mut GstAudioEncoder, caps: *mut gst::GstCaps) -> gboolean;
    pub fn gst_audio_encoder_set_perfect_timestamp(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_tolerance(enc: *mut GstAudioEncoder, tolerance: gst::GstClockTime);

    //=========================================================================
    // GstAudioFilter
    //=========================================================================
    pub fn gst_audio_filter_get_type() -> GType;

    //=========================================================================
    // GstAudioRingBuffer
    //=========================================================================
    pub fn gst_audio_ring_buffer_get_type() -> GType;
    pub fn gst_audio_ring_buffer_debug_spec_buff(spec: *mut GstAudioRingBufferSpec);
    pub fn gst_audio_ring_buffer_debug_spec_caps(spec: *mut GstAudioRingBufferSpec);
    pub fn gst_audio_ring_buffer_parse_caps(spec: *mut GstAudioRingBufferSpec, caps: *mut gst::GstCaps) -> gboolean;
    pub fn gst_audio_ring_buffer_acquire(buf: *mut GstAudioRingBuffer, spec: *mut GstAudioRingBufferSpec) -> gboolean;
    pub fn gst_audio_ring_buffer_activate(buf: *mut GstAudioRingBuffer, active: gboolean) -> gboolean;
    pub fn gst_audio_ring_buffer_advance(buf: *mut GstAudioRingBuffer, advance: c_uint);
    pub fn gst_audio_ring_buffer_clear(buf: *mut GstAudioRingBuffer, segment: c_int);
    pub fn gst_audio_ring_buffer_clear_all(buf: *mut GstAudioRingBuffer);
    pub fn gst_audio_ring_buffer_close_device(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_commit(buf: *mut GstAudioRingBuffer, sample: *mut u64, data: *mut u8, in_samples: c_int, out_samples: c_int, accum: *mut c_int) -> c_uint;
    pub fn gst_audio_ring_buffer_convert(buf: *mut GstAudioRingBuffer, src_fmt: gst::GstFormat, src_val: i64, dest_fmt: gst::GstFormat, dest_val: *mut i64) -> gboolean;
    pub fn gst_audio_ring_buffer_delay(buf: *mut GstAudioRingBuffer) -> c_uint;
    pub fn gst_audio_ring_buffer_device_is_open(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_is_acquired(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_is_active(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_is_flushing(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_may_start(buf: *mut GstAudioRingBuffer, allowed: gboolean);
    pub fn gst_audio_ring_buffer_open_device(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_pause(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_prepare_read(buf: *mut GstAudioRingBuffer, segment: *mut c_int, readptr: *mut *mut u8, len: *mut c_int) -> gboolean;
    pub fn gst_audio_ring_buffer_read(buf: *mut GstAudioRingBuffer, sample: u64, data: *mut u8, len: c_uint, timestamp: *mut gst::GstClockTime) -> c_uint;
    pub fn gst_audio_ring_buffer_release(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_samples_done(buf: *mut GstAudioRingBuffer) -> u64;
    pub fn gst_audio_ring_buffer_set_callback(buf: *mut GstAudioRingBuffer, cb: GstAudioRingBufferCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_audio_ring_buffer_set_callback_full(buf: *mut GstAudioRingBuffer, cb: GstAudioRingBufferCallback, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_audio_ring_buffer_set_channel_positions(buf: *mut GstAudioRingBuffer, position: *const GstAudioChannelPosition);
    pub fn gst_audio_ring_buffer_set_flushing(buf: *mut GstAudioRingBuffer, flushing: gboolean);
    pub fn gst_audio_ring_buffer_set_sample(buf: *mut GstAudioRingBuffer, sample: u64);
    pub fn gst_audio_ring_buffer_set_timestamp(buf: *mut GstAudioRingBuffer, readseg: c_int, timestamp: gst::GstClockTime);
    pub fn gst_audio_ring_buffer_start(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_stop(buf: *mut GstAudioRingBuffer) -> gboolean;

    //=========================================================================
    // GstAudioSink
    //=========================================================================
    pub fn gst_audio_sink_get_type() -> GType;

    //=========================================================================
    // GstAudioSrc
    //=========================================================================
    pub fn gst_audio_src_get_type() -> GType;

    //=========================================================================
    // GstStreamVolume
    //=========================================================================
    pub fn gst_stream_volume_get_type() -> GType;
    pub fn gst_stream_volume_convert_volume(from: GstStreamVolumeFormat, to: GstStreamVolumeFormat, val: c_double) -> c_double;
    pub fn gst_stream_volume_get_mute(volume: *mut GstStreamVolume) -> gboolean;
    pub fn gst_stream_volume_get_volume(volume: *mut GstStreamVolume, format: GstStreamVolumeFormat) -> c_double;
    pub fn gst_stream_volume_set_mute(volume: *mut GstStreamVolume, mute: gboolean);
    pub fn gst_stream_volume_set_volume(volume: *mut GstStreamVolume, format: GstStreamVolumeFormat, val: c_double);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gst_audio_buffer_clip(buffer: *mut gst::GstBuffer, segment: *const gst::GstSegment, rate: c_int, bpf: c_int) -> *mut gst::GstBuffer;
    pub fn gst_audio_buffer_reorder_channels(buffer: *mut gst::GstBuffer, format: GstAudioFormat, channels: c_int, from: *mut GstAudioChannelPosition, to: *mut GstAudioChannelPosition) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_audio_channel_get_fallback_mask(channels: c_int) -> u64;
    pub fn gst_audio_channel_positions_from_mask(channels: c_int, channel_mask: u64, position: *mut GstAudioChannelPosition) -> gboolean;
    pub fn gst_audio_channel_positions_to_mask(position: *mut GstAudioChannelPosition, channels: c_int, force_order: gboolean, channel_mask: *mut u64) -> gboolean;
    pub fn gst_audio_channel_positions_to_string(position: *mut GstAudioChannelPosition, channels: c_int) -> *mut c_char;
    pub fn gst_audio_channel_positions_to_valid_order(position: *mut GstAudioChannelPosition, channels: c_int) -> gboolean;
    pub fn gst_audio_check_valid_channel_positions(position: *mut GstAudioChannelPosition, channels: c_int, force_order: gboolean) -> gboolean;
    pub fn gst_audio_clipping_meta_api_get_type() -> GType;
    pub fn gst_audio_downmix_meta_api_get_type() -> GType;
    pub fn gst_audio_format_info_get_type() -> GType;
    pub fn gst_audio_get_channel_reorder_map(channels: c_int, from: *mut GstAudioChannelPosition, to: *mut GstAudioChannelPosition, reorder_map: *mut c_int) -> gboolean;
    pub fn gst_audio_iec61937_frame_size(spec: *const GstAudioRingBufferSpec) -> c_uint;
    pub fn gst_audio_iec61937_payload(src: *mut u8, src_n: c_uint, dst: *mut u8, dst_n: c_uint, spec: *const GstAudioRingBufferSpec, endianness: c_int) -> gboolean;
    pub fn gst_audio_reorder_channels(data: gpointer, size: size_t, format: GstAudioFormat, channels: c_int, from: *mut GstAudioChannelPosition, to: *mut GstAudioChannelPosition) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_buffer_add_audio_clipping_meta(buffer: *mut gst::GstBuffer, format: gst::GstFormat, start: u64, end: u64) -> *mut GstAudioClippingMeta;
    pub fn gst_buffer_add_audio_downmix_meta(buffer: *mut gst::GstBuffer, from_position: *mut GstAudioChannelPosition, from_channels: c_int, to_position: *mut GstAudioChannelPosition, to_channels: c_int, matrix: *mut *const c_float) -> *mut GstAudioDownmixMeta;
    pub fn gst_buffer_get_audio_downmix_meta_for_channels(buffer: *mut gst::GstBuffer, to_position: *mut GstAudioChannelPosition, to_channels: c_int) -> *mut GstAudioDownmixMeta;

}
