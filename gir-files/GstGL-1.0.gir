<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="Gst" version="1.0"/>
  <include name="GstBase" version="1.0"/>
  <include name="GstVideo" version="1.0"/>
  <package name="gstreamer-gl-1.0"/>
  <c:include name="gst/gl/gl.h"/>
  <namespace name="GstGL" version="1.0" shared-library="libgstgl-1.0.so.0" c:identifier-prefixes="Gst" c:symbol-prefixes="gst">
    <constant name="BUFFER_POOL_OPTION_GL_SYNC_META" value="GstBufferPoolOptionGLSyncMeta" c:type="GST_BUFFER_POOL_OPTION_GL_SYNC_META">
      <doc xml:space="preserve">An option that can be activated on bufferpools to request OpenGL
synchronization metadata on buffers from the pool.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_2D" value="GstBufferPoolOptionGLTextureTarget2D" c:type="GST_BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_2D">
      <doc xml:space="preserve">String used for %GST_GL_TEXTURE_TARGET_2D as a #GstBufferPool pool option</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_EXTERNAL_OES" value="GstBufferPoolOptionGLTextureTargetExternalOES" c:type="GST_BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_EXTERNAL_OES">
      <doc xml:space="preserve">String used for %GST_GL_TEXTURE_TARGET_EXTERNAL_OES as a #GstBufferPool pool option</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_RECTANGLE" value="GstBufferPoolOptionGLTextureTargetRectangle" c:type="GST_BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_RECTANGLE">
      <doc xml:space="preserve">String used for %GST_GL_TEXTURE_TARGET_RECTANGLE as a #GstBufferPool pool option</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CAPS_FEATURE_MEMORY_GL_BUFFER" value="memory:GLBuffer" c:type="GST_CAPS_FEATURE_MEMORY_GL_BUFFER">
      <doc xml:space="preserve">Name of the caps feature indicating the use of GL buffers</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CAPS_FEATURE_MEMORY_GL_MEMORY" value="memory:GLMemory" c:type="GST_CAPS_FEATURE_MEMORY_GL_MEMORY">
      <doc xml:space="preserve">Name of the caps feature for indicating the use of #GstGLMemory</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <bitfield name="GLAPI" glib:type-name="GstGLAPI" glib:get-type="gst_gl_api_get_type" c:type="GstGLAPI">
      <member name="none" value="0" c:identifier="GST_GL_API_NONE" glib:nick="none">
        <doc xml:space="preserve">no API</doc>
      </member>
      <member name="opengl" value="1" c:identifier="GST_GL_API_OPENGL" glib:nick="opengl">
        <doc xml:space="preserve">Desktop OpenGL up to and including 3.1.  The
                   compatibility profile when the OpenGL version is &gt;= 3.2</doc>
      </member>
      <member name="opengl3" value="2" c:identifier="GST_GL_API_OPENGL3" glib:nick="opengl3">
        <doc xml:space="preserve">Desktop OpenGL &gt;= 3.2 core profile</doc>
      </member>
      <member name="gles1" value="32768" c:identifier="GST_GL_API_GLES1" glib:nick="gles1">
        <doc xml:space="preserve">OpenGL ES 1.x</doc>
      </member>
      <member name="gles2" value="65536" c:identifier="GST_GL_API_GLES2" glib:nick="gles2">
        <doc xml:space="preserve">OpenGL ES 2.x and 3.x</doc>
      </member>
      <member name="any" value="4294967295" c:identifier="GST_GL_API_ANY" glib:nick="any">
        <doc xml:space="preserve">Any OpenGL API</doc>
      </member>
      <function name="from_string" c:identifier="gst_gl_api_from_string">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #GstGLAPI represented by @api_s</doc>
          <type name="GLAPI" c:type="GstGLAPI"/>
        </return-value>
        <parameters>
          <parameter name="api_s" transfer-ownership="none">
            <doc xml:space="preserve">a space separated string of OpenGL apis</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_string" c:identifier="gst_gl_api_to_string">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A space separated string of the OpenGL api's enabled in @api</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="api" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLAPI to stringify</doc>
            <type name="GLAPI" c:type="GstGLAPI"/>
          </parameter>
        </parameters>
      </function>
    </bitfield>
    <record name="GLAllocationParams" c:type="GstGLAllocationParams" glib:type-name="GstGLAllocationParams" glib:get-type="gst_gl_allocation_params_get_type" c:symbol-prefix="gl_allocation_params">
      <field name="struct_size" writable="1">
        <doc xml:space="preserve">the size of the struct (including and subclass data)</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="copy" writable="1">
        <doc xml:space="preserve">a #GstGLAllocationParamsCopyFunc</doc>
        <type name="GLAllocationParamsCopyFunc" c:type="GstGLAllocationParamsCopyFunc"/>
      </field>
      <field name="free" writable="1">
        <doc xml:space="preserve">a #GstGLAllocationParamsFreeFunc</doc>
        <type name="GLAllocationParamsFreeFunc" c:type="GstGLAllocationParamsFreeFunc"/>
      </field>
      <field name="alloc_flags" writable="1">
        <doc xml:space="preserve">allocation flags</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="alloc_size" writable="1">
        <doc xml:space="preserve">the allocation size</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="alloc_params" writable="1">
        <doc xml:space="preserve">the #GstAllocationParams</doc>
        <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
      </field>
      <field name="context" writable="1">
        <doc xml:space="preserve">a #GstGLContext</doc>
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="notify" writable="1">
        <doc xml:space="preserve">a #GDestroyNotify</doc>
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="user_data" writable="1">
        <doc xml:space="preserve">argument to call @notify with</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="wrapped_data" writable="1">
        <doc xml:space="preserve">the wrapped data pointer</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="gl_handle" writable="1">
        <doc xml:space="preserve">the wrapped OpenGL handle</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="copy" c:identifier="gst_gl_allocation_params_copy" version="1.8">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of the #GstGLAllocationParams specified by
         @src or %NULL on failure</doc>
          <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLAllocationParams to initialize</doc>
            <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy_data" c:identifier="gst_gl_allocation_params_copy_data" version="1.8">
        <doc xml:space="preserve">Copies the dynamically allocated data from @src to @dest.  Direct subclasses
should call this function in their own overridden copy function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the source #GstGLAllocationParams</doc>
            <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">the destination #GstGLAllocationParams</doc>
            <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_gl_allocation_params_free" version="1.8">
        <doc xml:space="preserve">Frees the #GstGLAllocationParams and all associated data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLAllocationParams to initialize</doc>
            <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_data" c:identifier="gst_gl_allocation_params_free_data" version="1.8">
        <doc xml:space="preserve">Frees the dynamically allocated data in @params.  Direct subclasses
should call this function in their own overridden free function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">the source #GstGLAllocationParams</doc>
            <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_gl_allocation_params_init" version="1.8" introspectable="0">
        <doc xml:space="preserve">@notify will be called once for each allocated memory using these @params
when freeing the memory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the parameters could be initialized</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLAllocationParams to initialize</doc>
            <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
          </instance-parameter>
          <parameter name="struct_size" transfer-ownership="none">
            <doc xml:space="preserve">the struct size of the implementation</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="alloc_flags" transfer-ownership="none">
            <doc xml:space="preserve">some alloc flags</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="copy" transfer-ownership="none">
            <doc xml:space="preserve">a copy function</doc>
            <type name="GLAllocationParamsCopyFunc" c:type="GstGLAllocationParamsCopyFunc"/>
          </parameter>
          <parameter name="free" transfer-ownership="none" scope="notified" closure="9" destroy="10">
            <doc xml:space="preserve">a free function</doc>
            <type name="GLAllocationParamsFreeFunc" c:type="GstGLAllocationParamsFreeFunc"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="alloc_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to allocate.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="alloc_params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GstAllocationParams to apply</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
          <parameter name="wrapped_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a sysmem data pointer to initialize the allocation with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="gl_handle" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a GL handle to initialize the allocation with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to call @notify with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="GLAllocationParamsCopyFunc" c:type="GstGLAllocationParamsCopyFunc">
      <doc xml:space="preserve">Copies the parameters from @src into @dest.  The subclass must compose copy
functions from the superclass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">the source #GstGLAllocationParams to copy from</doc>
          <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">the source #GstGLAllocationParams to copy</doc>
          <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="GLAllocationParamsFreeFunc" c:type="GstGLAllocationParamsFreeFunc">
      <doc xml:space="preserve">Free any dynamically allocated data.  The subclass must call the superclass'
free.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="params" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GstGLAllocationParams</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="GLAsyncDebug" c:type="GstGLAsyncDebug">
      <doc xml:space="preserve">#GstGLAsyncDebug an opaque structure and should only be accessed through the
provided API.</doc>
      <field name="state_flags" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="cat" readable="0" private="1">
        <type name="Gst.DebugCategory" c:type="GstDebugCategory*"/>
      </field>
      <field name="level" readable="0" private="1">
        <type name="Gst.DebugLevel" c:type="GstDebugLevel"/>
      </field>
      <field name="file" readable="0" private="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="function" readable="0" private="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="line" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="object" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject*"/>
      </field>
      <field name="debug_msg" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="callback" readable="0" private="1">
        <type name="GLAsyncDebugLogGetMessage" c:type="GstGLAsyncDebugLogGetMessage"/>
      </field>
      <field name="user_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="notify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="free" c:identifier="gst_gl_async_debug_free" version="1.8">
        <doc xml:space="preserve">Frees @ad</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ad" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLAsyncDebug</doc>
            <type name="GLAsyncDebug" c:type="GstGLAsyncDebug*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="freeze" c:identifier="gst_gl_async_debug_freeze" version="1.8">
        <doc xml:space="preserve">freeze the debug output.  While frozen, any call to
gst_gl_async_debug_output_log_msg() will not output any messages but
subsequent calls to gst_gl_async_debug_store_log_msg() will overwrite previous
messages.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ad" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLAsyncDebug</doc>
            <type name="GLAsyncDebug" c:type="GstGLAsyncDebug*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_gl_async_debug_init" version="1.8">
        <doc xml:space="preserve">Initialize @ad.  Intended for use with #GstGLAsyncDebug's that are embedded
in other structs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ad" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLAsyncDebug</doc>
            <type name="GLAsyncDebug" c:type="GstGLAsyncDebug*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="output_log_msg" c:identifier="gst_gl_async_debug_output_log_msg">
        <doc xml:space="preserve">Outputs a previously stored debug message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ad" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLAsyncDebug to store the message in</doc>
            <type name="GLAsyncDebug" c:type="GstGLAsyncDebug*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="store_log_msg" c:identifier="gst_gl_async_debug_store_log_msg" version="1.8" introspectable="0">
        <doc xml:space="preserve">Stores a debug message for later output by gst_gl_async_debug_output_log_msg()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ad" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLAsyncDebug to store the message in</doc>
            <type name="GLAsyncDebug" c:type="GstGLAsyncDebug*"/>
          </instance-parameter>
          <parameter name="cat" transfer-ownership="none">
            <doc xml:space="preserve">the #GstDebugCategory to output the message in</doc>
            <type name="Gst.DebugCategory" c:type="GstDebugCategory*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">the #GstDebugLevel</doc>
            <type name="Gst.DebugLevel" c:type="GstDebugLevel"/>
          </parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">the file where the debug message originates from</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="function" transfer-ownership="none">
            <doc xml:space="preserve">the function where the debug message originates from</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="line" transfer-ownership="none">
            <doc xml:space="preserve">the line in @file where the debug message originates from</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GObject to associate with the debug message</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a printf style format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the list of arguments for @format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="store_log_msg_valist" c:identifier="gst_gl_async_debug_store_log_msg_valist" version="1.8" introspectable="0">
        <doc xml:space="preserve">Stores a debug message for later output by gst_gl_async_debug_output_log_msg()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ad" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLAsyncDebug to store the message in</doc>
            <type name="GLAsyncDebug" c:type="GstGLAsyncDebug*"/>
          </instance-parameter>
          <parameter name="cat" transfer-ownership="none">
            <doc xml:space="preserve">the #GstDebugCategory to output the message in</doc>
            <type name="Gst.DebugCategory" c:type="GstDebugCategory*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">the #GstDebugLevel</doc>
            <type name="Gst.DebugLevel" c:type="GstDebugLevel"/>
          </parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">the file where the debug message originates from</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="function" transfer-ownership="none">
            <doc xml:space="preserve">the function where the debug message originates from</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="line" transfer-ownership="none">
            <doc xml:space="preserve">the line in @file where the debug message originates from</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GObject to associate with the debug message</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a printf style format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="varargs" transfer-ownership="none">
            <doc xml:space="preserve">the list of arguments for @format</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="thaw" c:identifier="gst_gl_async_debug_thaw" version="1.8">
        <doc xml:space="preserve">unfreeze the debug output.  See gst_gl_async_debug_freeze() for what freezing means</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ad" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLAsyncDebug</doc>
            <type name="GLAsyncDebug" c:type="GstGLAsyncDebug*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unset" c:identifier="gst_gl_async_debug_unset">
        <doc xml:space="preserve">Unset any dynamically allocated data.  Intended for use with
#GstGLAsyncDebug's that are embedded in other structs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ad" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLAsyncDebug</doc>
            <type name="GLAsyncDebug" c:type="GstGLAsyncDebug*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="gst_gl_async_debug_new" version="1.8" introspectable="0">
        <doc xml:space="preserve">Free with gst_gl_async_debug_free()</doc>
        <return-value>
          <doc xml:space="preserve">a new #GstGLAsyncDebug</doc>
          <type name="GLAsyncDebug" c:type="GstGLAsyncDebug*"/>
        </return-value>
      </function>
    </record>
    <callback name="GLAsyncDebugLogGetMessage" c:type="GstGLAsyncDebugLogGetMessage">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="0">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="GLBaseFilter" c:symbol-prefix="gl_base_filter" c:type="GstGLBaseFilter" parent="GstBase.BaseTransform" glib:type-name="GstGLBaseFilter" glib:get-type="gst_gl_base_filter_get_type" glib:type-struct="GLBaseFilterClass">
      <doc xml:space="preserve">#GstGLBaseFilter handles the nitty gritty details of retrieving an OpenGL
context.  It also provided some wrappers around #GstBaseTransform's
`start()`, `stop()` and `set_caps()` virtual methods that ensure an OpenGL
context is available and current in the calling thread.</doc>
      <virtual-method name="gl_set_caps">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <type name="GLBaseFilter" c:type="GstGLBaseFilter*"/>
          </instance-parameter>
          <parameter name="incaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="outcaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="gl_start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <type name="GLBaseFilter" c:type="GstGLBaseFilter*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="gl_stop">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <type name="GLBaseFilter" c:type="GstGLBaseFilter*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="find_gl_context" c:identifier="gst_gl_base_filter_find_gl_context" version="1.16">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether an OpenGL context could be retrieved or created successfully</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLBaseFilter</doc>
            <type name="GLBaseFilter" c:type="GstGLBaseFilter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gl_context" c:identifier="gst_gl_base_filter_get_gl_context" version="1.18">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the #GstGLContext found by @filter</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLBaseFilter</doc>
            <type name="GLBaseFilter" c:type="GstGLBaseFilter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="context" transfer-ownership="none">
        <type name="GLContext"/>
      </property>
      <field name="parent">
        <type name="GstBase.BaseTransform" c:type="GstBaseTransform"/>
      </field>
      <field name="display">
        <doc xml:space="preserve">the currently configured #GstGLDisplay</doc>
        <type name="GLDisplay" c:type="GstGLDisplay*"/>
      </field>
      <field name="context">
        <doc xml:space="preserve">the currently configured #GstGLContext</doc>
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="in_caps">
        <doc xml:space="preserve">the currently configured input #GstCaps</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="out_caps">
        <doc xml:space="preserve">the currently configured output #GstCaps</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLBaseFilterPrivate" c:type="GstGLBaseFilterPrivate*"/>
      </field>
    </class>
    <record name="GLBaseFilterClass" c:type="GstGLBaseFilterClass" glib:is-gtype-struct-for="GLBaseFilter">
      <doc xml:space="preserve">The base class for GStreamer GL Filter.</doc>
      <field name="parent_class">
        <type name="GstBase.BaseTransformClass" c:type="GstBaseTransformClass"/>
      </field>
      <field name="supported_gl_api">
        <doc xml:space="preserve">the logical-OR of #GstGLAPI's supported by this element</doc>
        <type name="GLAPI" c:type="GstGLAPI"/>
      </field>
      <field name="gl_start">
        <callback name="gl_start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <type name="GLBaseFilter" c:type="GstGLBaseFilter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="gl_stop">
        <callback name="gl_stop">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <type name="GLBaseFilter" c:type="GstGLBaseFilter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="gl_set_caps">
        <callback name="gl_set_caps">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <type name="GLBaseFilter" c:type="GstGLBaseFilter*"/>
            </parameter>
            <parameter name="incaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="outcaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GLBaseFilterPrivate" c:type="GstGLBaseFilterPrivate" disguised="1"/>
    <record name="GLBaseMemory" c:type="GstGLBaseMemory" glib:type-name="GstGLBaseMemory" glib:get-type="gst_gl_base_memory_get_type" c:symbol-prefix="gl_base_memory">
      <doc xml:space="preserve">GstGLBaseMemory is a #GstMemory subclass providing the basis of support
for the mapping of GL buffers.

Data is uploaded or downloaded from the GPU as is necessary.</doc>
      <field name="mem" writable="1">
        <doc xml:space="preserve">the parent object</doc>
        <type name="Gst.Memory" c:type="GstMemory"/>
      </field>
      <field name="context" writable="1">
        <doc xml:space="preserve">the #GstGLContext to use for GL operations</doc>
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="lock" writable="1">
        <type name="GLib.Mutex" c:type="GMutex"/>
      </field>
      <field name="map_flags" writable="1">
        <type name="Gst.MapFlags" c:type="GstMapFlags"/>
      </field>
      <field name="map_count" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="gl_map_count" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="query" writable="1">
        <type name="GLQuery" c:type="GstGLQuery*"/>
      </field>
      <field name="alloc_size" readable="0" private="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="alloc_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="notify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="user_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="alloc_data" c:identifier="gst_gl_base_memory_alloc_data">
        <doc xml:space="preserve">Note: only intended for subclass usage to allocate the system memory buffer
on demand.  If there is already a non-NULL data pointer in @gl_mem-&gt;data,
then this function imply returns TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the system memory could be allocated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLBaseMemory</doc>
            <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_gl_base_memory_init" version="1.8">
        <doc xml:space="preserve">Initializes @mem with the required parameters</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLBaseMemory to initialize</doc>
            <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
          </instance-parameter>
          <parameter name="allocator" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAllocator to initialize with</doc>
            <type name="Gst.Allocator" c:type="GstAllocator*"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the parent #GstMemory to initialize with</doc>
            <type name="Gst.Memory" c:type="GstMemory*"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLContext to initialize with</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the @GstAllocationParams to initialize with</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to be allocated</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to call @notify with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="memcpy" c:identifier="gst_gl_base_memory_memcpy" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the copy succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the source #GstGLBaseMemory</doc>
            <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">the destination #GstGLBaseMemory</doc>
            <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">the offset to start at</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to copy</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <function name="alloc" c:identifier="gst_gl_base_memory_alloc" version="1.8">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLBaseMemory from @allocator with the requested @params.</doc>
          <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
        </return-value>
        <parameters>
          <parameter name="allocator" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLBaseMemoryAllocator</doc>
            <type name="GLBaseMemoryAllocator" c:type="GstGLBaseMemoryAllocator*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLAllocationParams to allocate the memory with</doc>
            <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_once" c:identifier="gst_gl_base_memory_init_once" version="1.8">
        <doc xml:space="preserve">Initializes the GL Base Memory allocator. It is safe to call this function
multiple times.  This must be called before any other GstGLBaseMemory operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
    </record>
    <class name="GLBaseMemoryAllocator" c:symbol-prefix="gl_base_memory_allocator" c:type="GstGLBaseMemoryAllocator" version="1.8" parent="Gst.Allocator" abstract="1" glib:type-name="GstGLBaseMemoryAllocator" glib:get-type="gst_gl_base_memory_allocator_get_type" glib:type-struct="GLBaseMemoryAllocatorClass">
      <doc xml:space="preserve">Opaque #GstGLBaseMemoryAllocator struct</doc>
      <virtual-method name="alloc">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GstGLBaseMemory from @allocator and @params</doc>
          <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
        </return-value>
        <parameters>
          <instance-parameter name="allocator" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLBaseMemoryAllocator</doc>
            <type name="GLBaseMemoryAllocator" c:type="GstGLBaseMemoryAllocator*"/>
          </instance-parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLAllocationParams to allocate the memory with</doc>
            <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="parent" readable="0" private="1">
        <type name="Gst.Allocator" c:type="GstAllocator"/>
      </field>
      <field name="fallback_mem_copy" readable="0" private="1">
        <type name="Gst.MemoryCopyFunction" c:type="GstMemoryCopyFunction"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <callback name="GLBaseMemoryAllocatorAllocFunction" c:type="GstGLBaseMemoryAllocatorAllocFunction" version="1.8">
      <doc xml:space="preserve">Note: not called with a GL context current</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated #GstGLBaseMemory from @allocator and @params</doc>
        <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
      </return-value>
      <parameters>
        <parameter name="allocator" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLBaseMemoryAllocator</doc>
          <type name="GLBaseMemoryAllocator" c:type="GstGLBaseMemoryAllocator*"/>
        </parameter>
        <parameter name="params" transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLAllocationParams to allocate the memory with</doc>
          <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="GLBaseMemoryAllocatorClass" c:type="GstGLBaseMemoryAllocatorClass" glib:is-gtype-struct-for="GLBaseMemoryAllocator" version="1.8">
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="Gst.AllocatorClass" c:type="GstAllocatorClass"/>
      </field>
      <field name="alloc">
        <doc xml:space="preserve">a #GstGLBaseMemoryAllocatorAllocFunction</doc>
        <type name="GLBaseMemoryAllocatorAllocFunction" c:type="GstGLBaseMemoryAllocatorAllocFunction"/>
      </field>
      <field name="create">
        <doc xml:space="preserve">a #GstGLBaseMemoryAllocatorCreateFunction</doc>
        <type name="GLBaseMemoryAllocatorCreateFunction" c:type="GstGLBaseMemoryAllocatorCreateFunction"/>
      </field>
      <field name="map">
        <doc xml:space="preserve">a #GstGLBaseMemoryAllocatorMapFunction</doc>
        <type name="GLBaseMemoryAllocatorMapFunction" c:type="GstGLBaseMemoryAllocatorMapFunction"/>
      </field>
      <field name="unmap">
        <doc xml:space="preserve">a #GstGLBaseMemoryAllocatorUnmapFunction</doc>
        <type name="GLBaseMemoryAllocatorUnmapFunction" c:type="GstGLBaseMemoryAllocatorUnmapFunction"/>
      </field>
      <field name="copy">
        <doc xml:space="preserve">a #GstGLBaseMemoryAllocatorCopyFunction</doc>
        <type name="GLBaseMemoryAllocatorCopyFunction" c:type="GstGLBaseMemoryAllocatorCopyFunction"/>
      </field>
      <field name="destroy">
        <doc xml:space="preserve">a #GstGLBaseMemoryAllocatorDestroyFunction</doc>
        <type name="GLBaseMemoryAllocatorDestroyFunction" c:type="GstGLBaseMemoryAllocatorDestroyFunction"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="GLBaseMemoryAllocatorCopyFunction" c:type="GstGLBaseMemoryAllocatorCopyFunction" version="1.8">
      <doc xml:space="preserve">Also see gst_memory_copy();</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly copied #GstGLMemory or %NULL</doc>
        <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLBaseMemory</doc>
          <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">the offset to copy from</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to copy</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="GLBaseMemoryAllocatorCreateFunction" c:type="GstGLBaseMemoryAllocatorCreateFunction" version="1.8" throws="1">
      <doc xml:space="preserve">As this virtual method is called with an OpenGL context current, use this
function to allocate and OpenGL resources needed for your application</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the creation succeeded</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLBaseMemory</doc>
          <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="GLBaseMemoryAllocatorDestroyFunction" c:type="GstGLBaseMemoryAllocatorDestroyFunction" version="1.8">
      <doc xml:space="preserve">Destroy any resources allocated throughout the lifetime of @mem</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLBaseMemory</doc>
          <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="GLBaseMemoryAllocatorMapFunction" c:type="GstGLBaseMemoryAllocatorMapFunction" version="1.8">
      <doc xml:space="preserve">Also see gst_memory_map();</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the mapped pointer</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLBaseMemory</doc>
          <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GstMapInfo to map with</doc>
          <type name="Gst.MapInfo" c:type="GstMapInfo*"/>
        </parameter>
        <parameter name="maxsize" transfer-ownership="none">
          <doc xml:space="preserve">the size to map</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="GLBaseMemoryAllocatorUnmapFunction" c:type="GstGLBaseMemoryAllocatorUnmapFunction" version="1.8">
      <doc xml:space="preserve">Also see gst_memory_unmap();</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLBaseMemory</doc>
          <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GstMapInfo to map with</doc>
          <type name="Gst.MapInfo" c:type="GstMapInfo*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="GLBaseMemoryError" glib:type-name="GstGLBaseMemoryError" glib:get-type="gst_gl_base_memory_error_get_type" c:type="GstGLBaseMemoryError" glib:error-domain="gst-gl-base-memory-error-quark">
      <member name="failed" value="0" c:identifier="GST_GL_BASE_MEMORY_ERROR_FAILED" glib:nick="failed">
        <doc xml:space="preserve">generic failure</doc>
      </member>
      <member name="old_libs" value="1" c:identifier="GST_GL_BASE_MEMORY_ERROR_OLD_LIBS" glib:nick="old-libs">
        <doc xml:space="preserve">the implementation is too old and doesn't
                                    implement enough features</doc>
      </member>
      <member name="resource_unavailable" value="2" c:identifier="GST_GL_BASE_MEMORY_ERROR_RESOURCE_UNAVAILABLE" glib:nick="resource-unavailable">
        <doc xml:space="preserve">a resource could not be found</doc>
      </member>
      <function name="quark" c:identifier="gst_gl_base_memory_error_quark">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for #GstGLBaseMemory in #GError's</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="GLBaseMemoryTransfer" glib:type-name="GstGLBaseMemoryTransfer" glib:get-type="gst_gl_base_memory_transfer_get_type" c:type="GstGLBaseMemoryTransfer">
      <member name="download" value="1048576" c:identifier="GST_GL_BASE_MEMORY_TRANSFER_NEED_DOWNLOAD" glib:nick="download">
        <doc xml:space="preserve">the texture needs downloading
                                            to the data pointer</doc>
      </member>
      <member name="upload" value="2097152" c:identifier="GST_GL_BASE_MEMORY_TRANSFER_NEED_UPLOAD" glib:nick="upload">
        <doc xml:space="preserve">the data pointer needs uploading
                                            to the texture</doc>
      </member>
    </bitfield>
    <class name="GLBaseSrc" c:symbol-prefix="gl_base_src" c:type="GstGLBaseSrc" version="1.18" parent="GstBase.PushSrc" abstract="1" glib:type-name="GstGLBaseSrc" glib:get-type="gst_gl_base_src_get_type" glib:type-struct="GLBaseSrcClass">
      <doc xml:space="preserve">#GstGLBaseSrc handles the nitty gritty details of retrieving an OpenGL
context. It also provided some wrappers around #GstBaseSrc's `start()` and
`stop()` virtual methods that ensure an OpenGL context is available and
current in the calling thread.</doc>
      <virtual-method name="fill_gl_memory">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="GLBaseSrc" c:type="GstGLBaseSrc*"/>
          </instance-parameter>
          <parameter name="mem" transfer-ownership="none">
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="gl_start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="GLBaseSrc" c:type="GstGLBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="gl_stop">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="GLBaseSrc" c:type="GstGLBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <property name="timestamp-offset" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <field name="parent">
        <type name="GstBase.PushSrc" c:type="GstPushSrc"/>
      </field>
      <field name="display">
        <doc xml:space="preserve">the currently configured #GstGLDisplay</doc>
        <type name="GLDisplay" c:type="GstGLDisplay*"/>
      </field>
      <field name="context">
        <doc xml:space="preserve">the currently configured #GstGLContext</doc>
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="out_info">
        <doc xml:space="preserve">the currently configured output #GstVideoInfo</doc>
        <type name="GstVideo.VideoInfo" c:type="GstVideoInfo"/>
      </field>
      <field name="out_caps">
        <doc xml:space="preserve">the currently configured output #GstCaps</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="running_time">
        <doc xml:space="preserve">the total running time</doc>
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLBaseSrcPrivate" c:type="GstGLBaseSrcPrivate*"/>
      </field>
    </class>
    <record name="GLBaseSrcClass" c:type="GstGLBaseSrcClass" glib:is-gtype-struct-for="GLBaseSrc" version="1.18">
      <doc xml:space="preserve">The base class for GStreamer GL Video sources.</doc>
      <field name="parent_class">
        <type name="GstBase.PushSrcClass" c:type="GstPushSrcClass"/>
      </field>
      <field name="supported_gl_api">
        <doc xml:space="preserve">the logical-OR of #GstGLAPI's supported by this element</doc>
        <type name="GLAPI" c:type="GstGLAPI"/>
      </field>
      <field name="gl_start">
        <callback name="gl_start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="GLBaseSrc" c:type="GstGLBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="gl_stop">
        <callback name="gl_stop">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="GLBaseSrc" c:type="GstGLBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fill_gl_memory">
        <callback name="fill_gl_memory">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="GLBaseSrc" c:type="GstGLBaseSrc*"/>
            </parameter>
            <parameter name="mem" transfer-ownership="none">
              <type name="GLMemory" c:type="GstGLMemory*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GLBaseSrcPrivate" c:type="GstGLBaseSrcPrivate" disguised="1"/>
    <record name="GLBuffer" c:type="GstGLBuffer">
      <doc xml:space="preserve">GstGLBuffer is a #GstMemory subclass providing support for the mapping of
GL buffers.

Data is uploaded or downloaded from the GPU as is necessary.</doc>
      <field name="mem" writable="1">
        <doc xml:space="preserve">the parent object</doc>
        <type name="GLBaseMemory" c:type="GstGLBaseMemory"/>
      </field>
      <field name="id" writable="1">
        <doc xml:space="preserve">the buffer id for this memory</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="target" writable="1">
        <doc xml:space="preserve">the OpenGL target of this texture for binding purposes</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="usage_hints" writable="1">
        <doc xml:space="preserve">the OpenGL usage hints this buffer was created with</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <function name="init_once" c:identifier="gst_gl_buffer_init_once" version="1.8">
        <doc xml:space="preserve">Initializes the GL Buffer allocator. It is safe to call this function
multiple times.  This must be called before any other #GstGLBuffer operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
    </record>
    <record name="GLBufferAllocationParams" c:type="GstGLBufferAllocationParams" glib:type-name="GstGLBufferAllocationParams" glib:get-type="gst_gl_buffer_allocation_params_get_type" c:symbol-prefix="gl_buffer_allocation_params">
      <field name="parent" writable="1">
        <doc xml:space="preserve">parent object</doc>
        <type name="GLAllocationParams" c:type="GstGLAllocationParams"/>
      </field>
      <field name="gl_target" writable="1">
        <doc xml:space="preserve">the OpenGL target to bind the buffer to</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="gl_usage" writable="1">
        <doc xml:space="preserve">the OpenGL usage hint to create the buffer with</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <constructor name="new" c:identifier="gst_gl_buffer_allocation_params_new" version="1.8">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLBufferAllocationParams for allocating OpenGL buffer
         objects</doc>
          <type name="GLBufferAllocationParams" c:type="GstGLBufferAllocationParams*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="alloc_size" transfer-ownership="none">
            <doc xml:space="preserve">the size in bytes to allocate</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="alloc_params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GstAllocationParams for @tex_id</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
          <parameter name="gl_target" transfer-ownership="none">
            <doc xml:space="preserve">the OpenGL target to allocate</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="gl_usage" transfer-ownership="none">
            <doc xml:space="preserve">the OpenGL usage hint to allocate with</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
    </record>
    <class name="GLBufferAllocator" c:symbol-prefix="gl_buffer_allocator" c:type="GstGLBufferAllocator" parent="GLBaseMemoryAllocator" glib:type-name="GstGLBufferAllocator" glib:get-type="gst_gl_buffer_allocator_get_type" glib:type-struct="GLBufferAllocatorClass">
      <doc xml:space="preserve">Opaque #GstGLBufferAllocator struct</doc>
      <field name="parent">
        <type name="GLBaseMemoryAllocator" c:type="GstGLBaseMemoryAllocator"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLBufferAllocatorClass" c:type="GstGLBufferAllocatorClass" glib:is-gtype-struct-for="GLBufferAllocator">
      <doc xml:space="preserve">The #GstGLBufferAllocatorClass only contains private data</doc>
      <field name="parent_class">
        <type name="GLBaseMemoryAllocatorClass" c:type="GstGLBaseMemoryAllocatorClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="GLBufferPool" c:symbol-prefix="gl_buffer_pool" c:type="GstGLBufferPool" parent="Gst.BufferPool" glib:type-name="GstGLBufferPool" glib:get-type="gst_gl_buffer_pool_get_type" glib:type-struct="GLBufferPoolClass">
      <doc xml:space="preserve">a #GstGLBufferPool is an object that allocates buffers with #GstGLBaseMemory

A #GstGLBufferPool is created with gst_gl_buffer_pool_new()

#GstGLBufferPool implements the VideoMeta buffer pool option
%GST_BUFFER_POOL_OPTION_VIDEO_META, the VideoAligment buffer pool option
%GST_BUFFER_POOL_OPTION_VIDEO_ALIGNMENT as well as the OpenGL specific
%GST_BUFFER_POOL_OPTION_GL_SYNC_META buffer pool option.</doc>
      <constructor name="new" c:identifier="gst_gl_buffer_pool_new">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GstBufferPool that allocates buffers with #GstGLMemory</doc>
          <type name="Gst.BufferPool" c:type="GstBufferPool*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLContext to use</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="bufferpool">
        <type name="Gst.BufferPool" c:type="GstBufferPool"/>
      </field>
      <field name="context">
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLBufferPoolPrivate" c:type="GstGLBufferPoolPrivate*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLBufferPoolClass" c:type="GstGLBufferPoolClass" glib:is-gtype-struct-for="GLBufferPool">
      <doc xml:space="preserve">The #GstGLBufferPoolClass structure contains only private data</doc>
      <field name="parent_class">
        <type name="Gst.BufferPoolClass" c:type="GstBufferPoolClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GLBufferPoolPrivate" c:type="GstGLBufferPoolPrivate" disguised="1"/>
    <class name="GLColorConvert" c:symbol-prefix="gl_color_convert" c:type="GstGLColorConvert" parent="Gst.Object" glib:type-name="GstGLColorConvert" glib:get-type="gst_gl_color_convert_get_type" glib:type-struct="GLColorConvertClass">
      <doc xml:space="preserve">#GstGLColorConvert is an object that converts between color spaces and/or
formats using OpenGL Shaders.

A #GstGLColorConvert can be created with gst_gl_color_convert_new(), the
configuration negotiated with gst_gl_color_convert_transform_caps() and the
conversion performed with gst_gl_color_convert_perform().

The glcolorconvertelement provides a GStreamer element that uses
#GstGLColorConvert to convert between video formats and color spaces.</doc>
      <constructor name="new" c:identifier="gst_gl_color_convert_new" version="1.4">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLColorConvert object</doc>
          <type name="GLColorConvert" c:type="GstGLColorConvert*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="fixate_caps" c:identifier="gst_gl_color_convert_fixate_caps" version="1.8">
        <doc xml:space="preserve">Provides an implementation of #GstBaseTransformClass.fixate_caps()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the fixated #GstCaps</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext to use for transforming @caps</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">a #GstPadDirection</doc>
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve">the #GstCaps of @direction</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="other" transfer-ownership="full">
            <doc xml:space="preserve">the #GstCaps to fixate</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </function>
      <function name="transform_caps" c:identifier="gst_gl_color_convert_transform_caps" version="1.6">
        <doc xml:space="preserve">Provides an implementation of #GstBaseTransformClass.transform_caps()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the converted #GstCaps</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext to use for transforming @caps</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">a #GstPadDirection</doc>
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve">the #GstCaps to transform</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a set of filter #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </function>
      <method name="decide_allocation" c:identifier="gst_gl_color_convert_decide_allocation" version="1.8">
        <doc xml:space="preserve">Provides an implementation of #GstBaseTransformClass.decide_allocation()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the allocation parameters were successfully chosen</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLColorConvert</doc>
            <type name="GLColorConvert" c:type="GstGLColorConvert*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">a completed ALLOCATION #GstQuery</doc>
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="perform" c:identifier="gst_gl_color_convert_perform" version="1.4">
        <doc xml:space="preserve">Converts the data contained by @inbuf using the formats specified by the
#GstCaps passed to gst_gl_color_convert_set_caps()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a converted #GstBuffer or %NULL</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLColorConvert</doc>
            <type name="GLColorConvert" c:type="GstGLColorConvert*"/>
          </instance-parameter>
          <parameter name="inbuf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLMemory filled #GstBuffer to convert</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_caps" c:identifier="gst_gl_color_convert_set_caps" version="1.6">
        <doc xml:space="preserve">Initializes @convert with the information required for conversion.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLColorConvert</doc>
            <type name="GLColorConvert" c:type="GstGLColorConvert*"/>
          </instance-parameter>
          <parameter name="in_caps" transfer-ownership="none">
            <doc xml:space="preserve">input #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="out_caps" transfer-ownership="none">
            <doc xml:space="preserve">output #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="context" readable="0" private="1">
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="in_info" readable="0" private="1">
        <type name="GstVideo.VideoInfo" c:type="GstVideoInfo"/>
      </field>
      <field name="out_info" readable="0" private="1">
        <type name="GstVideo.VideoInfo" c:type="GstVideoInfo"/>
      </field>
      <field name="initted" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="passthrough" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="inbuf" readable="0" private="1">
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="outbuf" readable="0" private="1">
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="fbo" readable="0" private="1">
        <type name="GLFramebuffer" c:type="GstGLFramebuffer*"/>
      </field>
      <field name="shader" readable="0" private="1">
        <type name="GLShader" c:type="GstGLShader*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLColorConvertPrivate" c:type="GstGLColorConvertPrivate*"/>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLColorConvertClass" c:type="GstGLColorConvertClass" glib:is-gtype-struct-for="GLColorConvert">
      <doc xml:space="preserve">The #GstGLColorConvertClass struct only contains private data</doc>
      <field name="object_class" readable="0" private="1">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GLColorConvertPrivate" c:type="GstGLColorConvertPrivate" disguised="1"/>
    <class name="GLContext" c:symbol-prefix="gl_context" c:type="GstGLContext" parent="Gst.Object" abstract="1" glib:type-name="GstGLContext" glib:get-type="gst_gl_context_get_type" glib:type-struct="GLContextClass">
      <doc xml:space="preserve">#GstGLContext wraps an OpenGL context object in a uniform API.  As a result
of the limitation on OpenGL context, this object is not thread safe unless
specified and must only be activated in a single thread.</doc>
      <constructor name="new" c:identifier="gst_gl_context_new" version="1.4">
        <doc xml:space="preserve">Create a new #GstGLContext with the specified @display</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </return-value>
        <parameters>
          <parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_wrapped" c:identifier="gst_gl_context_new_wrapped" version="1.4">
        <doc xml:space="preserve">Wraps an existing OpenGL context into a #GstGLContext.

Note: The caller is responsible for ensuring that the OpenGL context
represented by @handle stays alive while the returned #GstGLContext is
active.

@context_type must not be %GST_GL_PLATFORM_NONE or %GST_GL_PLATFORM_ANY

@available_apis must not be %GST_GL_API_NONE or %GST_GL_API_ANY</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GstGLContext wrapping @handle</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </return-value>
        <parameters>
          <parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">the OpenGL context to wrap</doc>
            <type name="guintptr" c:type="guintptr"/>
          </parameter>
          <parameter name="context_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLPlatform specifying the type of context in @handle</doc>
            <type name="GLPlatform" c:type="GstGLPlatform"/>
          </parameter>
          <parameter name="available_apis" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLAPI containing the available OpenGL apis in @handle</doc>
            <type name="GLAPI" c:type="GstGLAPI"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="default_get_proc_address" c:identifier="gst_gl_context_default_get_proc_address" version="1.4">
        <doc xml:space="preserve">A default implementation of the various GetProcAddress functions that looks
for @name in the OpenGL shared libraries or in the current process.

See also: gst_gl_context_get_proc_address()</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">an address pointing to @name or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="gl_api" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLAPI</doc>
            <type name="GLAPI" c:type="GstGLAPI"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">then function to get the address of</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_current" c:identifier="gst_gl_context_get_current" version="1.6">
        <doc xml:space="preserve">See also gst_gl_context_activate().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLContext active in the current thread or %NULL</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </return-value>
      </function>
      <function name="get_current_gl_api" c:identifier="gst_gl_context_get_current_gl_api" version="1.6">
        <doc xml:space="preserve">If an error occurs, @major and @minor are not modified and %GST_GL_API_NONE is
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The version supported by the OpenGL context current in the calling
         thread or %GST_GL_API_NONE</doc>
          <type name="GLAPI" c:type="GstGLAPI"/>
        </return-value>
        <parameters>
          <parameter name="platform" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLPlatform to retrieve the API for</doc>
            <type name="GLPlatform" c:type="GstGLPlatform"/>
          </parameter>
          <parameter name="major" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the major version</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="minor" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the minor version</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_current_gl_context" c:identifier="gst_gl_context_get_current_gl_context" version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The OpenGL context handle current in the calling thread or %NULL</doc>
          <type name="guintptr" c:type="guintptr"/>
        </return-value>
        <parameters>
          <parameter name="context_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLPlatform specifying the type of context to retrieve</doc>
            <type name="GLPlatform" c:type="GstGLPlatform"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_proc_address_with_platform" c:identifier="gst_gl_context_get_proc_address_with_platform" version="1.6">
        <doc xml:space="preserve">Attempts to use the @context_type specific GetProcAddress implementations
to retrieve @name.

See also gst_gl_context_get_proc_address().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a function pointer for @name, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="context_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLPlatform</doc>
            <type name="GLPlatform" c:type="GstGLPlatform"/>
          </parameter>
          <parameter name="gl_api" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLAPI</doc>
            <type name="GLAPI" c:type="GstGLAPI"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the function to retrieve</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="activate" invoker="activate" version="1.4">
        <doc xml:space="preserve">(De)activate the OpenGL context represented by this @context.

In OpenGL terms, calls eglMakeCurrent or similar with this context and the
currently set window.  See gst_gl_context_set_window() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the activation succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="activate" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to activate, %FALSE to deactivate</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="check_feature" invoker="check_feature" version="1.4">
        <doc xml:space="preserve">Check for an OpenGL @feature being supported.

Note: Most features require that the context be created before it is
possible to determine their existence and so will fail if that is not the
case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @feature is supported by @context</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">a platform specific feature</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="choose_format" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_context" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="gl_api" transfer-ownership="none">
            <type name="GLAPI" c:type="GstGLAPI"/>
          </parameter>
          <parameter name="other_context" transfer-ownership="none">
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="destroy_context">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_gl_api" invoker="get_gl_api" version="1.4">
        <doc xml:space="preserve">Get the currently enabled OpenGL api.

The currently available API may be limited by the #GstGLDisplay in use and/or
the #GstGLWindow chosen.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the available OpenGL api</doc>
          <type name="GLAPI" c:type="GstGLAPI"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_gl_context" invoker="get_gl_context" version="1.4">
        <doc xml:space="preserve">Gets the backing OpenGL context used by @context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The platform specific backing OpenGL context</doc>
          <type name="guintptr" c:type="guintptr"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext:</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_gl_platform" invoker="get_gl_platform" version="1.4">
        <doc xml:space="preserve">Gets the OpenGL platform that used by @context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The platform specific backing OpenGL context</doc>
          <type name="GLPlatform" c:type="GstGLPlatform"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext:</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_gl_platform_version" invoker="get_gl_platform_version">
        <doc xml:space="preserve">Get the version of the OpenGL platform (GLX, EGL, etc) used.  Only valid
after a call to gst_gl_context_create().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="major" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return for the major version</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="minor" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return for the minor version</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="swap_buffers" invoker="swap_buffers">
        <doc xml:space="preserve">Swap the front and back buffers on the window attached to @context.
This will display the frame on the next refresh cycle.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="activate" c:identifier="gst_gl_context_activate" version="1.4">
        <doc xml:space="preserve">(De)activate the OpenGL context represented by this @context.

In OpenGL terms, calls eglMakeCurrent or similar with this context and the
currently set window.  See gst_gl_context_set_window() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the activation succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="activate" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to activate, %FALSE to deactivate</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_share" c:identifier="gst_gl_context_can_share" version="1.6">
        <doc xml:space="preserve">Note: This will always fail for two wrapped #GstGLContext's</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @context and @other_context are able to share OpenGL
     resources.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="other_context" transfer-ownership="none">
            <doc xml:space="preserve">another #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_feature" c:identifier="gst_gl_context_check_feature" version="1.4">
        <doc xml:space="preserve">Check for an OpenGL @feature being supported.

Note: Most features require that the context be created before it is
possible to determine their existence and so will fail if that is not the
case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @feature is supported by @context</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">a platform specific feature</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_framebuffer_status" c:identifier="gst_gl_context_check_framebuffer_status" version="1.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether whether the current framebuffer is complete</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="fbo_target" transfer-ownership="none">
            <doc xml:space="preserve">the GL value of the framebuffer target, GL_FRAMEBUFFER,
             GL_READ_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_gl_version" c:identifier="gst_gl_context_check_gl_version" version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether OpenGL context implements the required api and specified
version.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="api" transfer-ownership="none">
            <doc xml:space="preserve">api type required</doc>
            <type name="GLAPI" c:type="GstGLAPI"/>
          </parameter>
          <parameter name="maj" transfer-ownership="none">
            <doc xml:space="preserve">major version required</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="min" transfer-ownership="none">
            <doc xml:space="preserve">minor version required</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_framebuffer" c:identifier="gst_gl_context_clear_framebuffer" version="1.10">
        <doc xml:space="preserve">Unbind the current framebuffer</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_shader" c:identifier="gst_gl_context_clear_shader">
        <doc xml:space="preserve">Clear's the currently set shader from the GL state machine.

Note: must be called in the GL thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="create" c:identifier="gst_gl_context_create" version="1.4" throws="1">
        <doc xml:space="preserve">Creates an OpenGL context with the specified @other_context as a context
to share shareable OpenGL objects with.  See the OpenGL specification for
what is shared between OpenGL contexts.

If an error occurs, and @error is not %NULL, then error will contain details
of the error and %FALSE will be returned.

Should only be called once.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the context could successfully be created</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext:</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="other_context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GstGLContext to share OpenGL objects with</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="gst_gl_context_destroy" version="1.6">
        <doc xml:space="preserve">Destroys an OpenGL context.

Should only be called after gst_gl_context_create() has been successfully
called for this context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext:</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="fill_info" c:identifier="gst_gl_context_fill_info" version="1.6" throws="1">
        <doc xml:space="preserve">Fills @context's info (version, extensions, vtable, etc) from the GL
context in the current thread.  Typically used with wrapped contexts to
allow wrapped contexts to be used as regular #GstGLContext's.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext:</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_display" c:identifier="gst_gl_context_get_display" version="1.4">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GstGLDisplay associated with this @context</doc>
          <type name="GLDisplay" c:type="GstGLDisplay*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext:</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gl_api" c:identifier="gst_gl_context_get_gl_api" version="1.4">
        <doc xml:space="preserve">Get the currently enabled OpenGL api.

The currently available API may be limited by the #GstGLDisplay in use and/or
the #GstGLWindow chosen.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the available OpenGL api</doc>
          <type name="GLAPI" c:type="GstGLAPI"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gl_context" c:identifier="gst_gl_context_get_gl_context" version="1.4">
        <doc xml:space="preserve">Gets the backing OpenGL context used by @context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The platform specific backing OpenGL context</doc>
          <type name="guintptr" c:type="guintptr"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext:</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gl_platform" c:identifier="gst_gl_context_get_gl_platform" version="1.4">
        <doc xml:space="preserve">Gets the OpenGL platform that used by @context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The platform specific backing OpenGL context</doc>
          <type name="GLPlatform" c:type="GstGLPlatform"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext:</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gl_platform_version" c:identifier="gst_gl_context_get_gl_platform_version">
        <doc xml:space="preserve">Get the version of the OpenGL platform (GLX, EGL, etc) used.  Only valid
after a call to gst_gl_context_create().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="major" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return for the major version</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="minor" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return for the minor version</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_gl_version" c:identifier="gst_gl_context_get_gl_version" version="1.4">
        <doc xml:space="preserve">Returns the OpenGL version implemented by @context.  See
gst_gl_context_get_gl_api() for retrieving the OpenGL api implemented by
@context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="maj" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">resulting major version</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="min" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">resulting minor version</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_proc_address" c:identifier="gst_gl_context_get_proc_address" version="1.4">
        <doc xml:space="preserve">Get a function pointer to a specified opengl function, @name.  If the the
specific function does not exist, NULL is returned instead.

Platform specific functions (names starting 'egl', 'glX', 'wgl', etc) can also
be retrieved using this method.

Note: This function may return valid function pointers that may not be valid
to call in @context.  The caller is responsible for ensuring that the
returned function is a valid function to call in @context by either checking
the OpenGL API and version or for an appropriate OpenGL extension.

Note: On success, you need to cast the returned function pointer to the
correct type to be able to call it correctly.  On 32-bit Windows, this will
include the `GSTGLAPI` identifier to use the correct calling convention.
e.g.

|[&lt;!-- language="C" --&gt;
void (GSTGLAPI *PFN_glGetIntegerv) (GLenum name, GLint * ret)
]|</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a function pointer or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">an opengl function name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_thread" c:identifier="gst_gl_context_get_thread" version="1.6">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The #GThread, @context is current in or NULL</doc>
          <type name="GLib.Thread" c:type="GThread*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_window" c:identifier="gst_gl_context_get_window" version="1.4">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the currently set window</doc>
          <type name="GLWindow" c:type="GstGLWindow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_shared" c:identifier="gst_gl_context_is_shared" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the #GstGLContext has been shared with another #GstGLContext</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_shared_with" c:identifier="gst_gl_context_set_shared_with" version="1.8">
        <doc xml:space="preserve">Will internally set @context as shared with @share</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a wrapped #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="share" transfer-ownership="none">
            <doc xml:space="preserve">another #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_window" c:identifier="gst_gl_context_set_window" version="1.4">
        <doc xml:space="preserve">Set's the current window on @context to @window.  The window can only be
changed before gst_gl_context_create() has been called and the @window is not
already running.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the window was successfully updated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="window" transfer-ownership="full">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_glsl_profile_version" c:identifier="gst_gl_context_supports_glsl_profile_version">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @context supports the combination of @version with @profile</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion"/>
          </parameter>
          <parameter name="profile" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLProfile</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_precision" c:identifier="gst_gl_context_supports_precision" version="1.16">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @context supports the 'precision' specifier in GLSL shaders</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion"/>
          </parameter>
          <parameter name="profile" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLProfile</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_precision_highp" c:identifier="gst_gl_context_supports_precision_highp" version="1.16">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @context supports the 'precision highp' specifier in GLSL shaders</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion"/>
          </parameter>
          <parameter name="profile" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLProfile</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile"/>
          </parameter>
        </parameters>
      </method>
      <method name="swap_buffers" c:identifier="gst_gl_context_swap_buffers">
        <doc xml:space="preserve">Swap the front and back buffers on the window attached to @context.
This will display the frame on the next refresh cycle.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="thread_add" c:identifier="gst_gl_context_thread_add" version="1.4">
        <doc xml:space="preserve">Execute @func in the OpenGL thread of @context with @data

MT-safe</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">a #GstGLContextThreadFunc</doc>
            <type name="GLContextThreadFunc" c:type="GstGLContextThreadFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to call @func with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="display" readable="0" private="1">
        <type name="GLDisplay" c:type="GstGLDisplay*"/>
      </field>
      <field name="window" readable="0" private="1">
        <type name="GLWindow" c:type="GstGLWindow*"/>
      </field>
      <field name="gl_vtable">
        <doc xml:space="preserve">a list of OpenGL function pointers</doc>
        <type name="GLFuncs" c:type="GstGLFuncs*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLContextPrivate" c:type="GstGLContextPrivate*"/>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLContextClass" c:type="GstGLContextClass" glib:is-gtype-struct-for="GLContext">
      <field name="parent_class">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="get_current_context">
        <callback name="get_current_context">
          <return-value transfer-ownership="none">
            <type name="guintptr" c:type="guintptr"/>
          </return-value>
        </callback>
      </field>
      <field name="get_gl_context">
        <callback name="get_gl_context">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The platform specific backing OpenGL context</doc>
            <type name="guintptr" c:type="guintptr"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLContext:</doc>
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_gl_api">
        <callback name="get_gl_api">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the available OpenGL api</doc>
            <type name="GLAPI" c:type="GstGLAPI"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLContext</doc>
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_gl_platform">
        <callback name="get_gl_platform">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The platform specific backing OpenGL context</doc>
            <type name="GLPlatform" c:type="GstGLPlatform"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLContext:</doc>
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_proc_address">
        <callback name="get_proc_address">
          <return-value transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="gl_api" transfer-ownership="none">
              <type name="GLAPI" c:type="GstGLAPI"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the activation succeeded</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLContext</doc>
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
            <parameter name="activate" transfer-ownership="none">
              <doc xml:space="preserve">%TRUE to activate, %FALSE to deactivate</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="choose_format">
        <callback name="choose_format" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_context">
        <callback name="create_context" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
            <parameter name="gl_api" transfer-ownership="none">
              <type name="GLAPI" c:type="GstGLAPI"/>
            </parameter>
            <parameter name="other_context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="destroy_context">
        <callback name="destroy_context">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="swap_buffers">
        <callback name="swap_buffers">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLContext</doc>
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="check_feature">
        <callback name="check_feature">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether @feature is supported by @context</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLContext</doc>
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
            <parameter name="feature" transfer-ownership="none">
              <doc xml:space="preserve">a platform specific feature</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_gl_platform_version">
        <callback name="get_gl_platform_version">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLContext</doc>
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
            <parameter name="major" direction="out" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">return for the major version</doc>
              <type name="gint" c:type="gint*"/>
            </parameter>
            <parameter name="minor" direction="out" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">return for the minor version</doc>
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="GLContextError" glib:type-name="GstGLContextError" glib:get-type="gst_gl_context_error_get_type" c:type="GstGLContextError" glib:error-domain="gst-gl-context-error-quark">
      <doc xml:space="preserve">OpenGL context errors.</doc>
      <member name="failed" value="0" c:identifier="GST_GL_CONTEXT_ERROR_FAILED" glib:nick="failed">
        <doc xml:space="preserve">Failed for an unspecified reason</doc>
      </member>
      <member name="wrong_config" value="1" c:identifier="GST_GL_CONTEXT_ERROR_WRONG_CONFIG" glib:nick="wrong-config">
        <doc xml:space="preserve">The configuration requested is not correct</doc>
      </member>
      <member name="wrong_api" value="2" c:identifier="GST_GL_CONTEXT_ERROR_WRONG_API" glib:nick="wrong-api">
        <doc xml:space="preserve">The OpenGL API requested is not correct</doc>
      </member>
      <member name="old_libs" value="3" c:identifier="GST_GL_CONTEXT_ERROR_OLD_LIBS" glib:nick="old-libs">
        <doc xml:space="preserve">The OpenGL libraries are too old</doc>
      </member>
      <member name="create_context" value="4" c:identifier="GST_GL_CONTEXT_ERROR_CREATE_CONTEXT" glib:nick="create-context">
        <doc xml:space="preserve">glXCreateContext (or similar) failed</doc>
      </member>
      <member name="resource_unavailable" value="5" c:identifier="GST_GL_CONTEXT_ERROR_RESOURCE_UNAVAILABLE" glib:nick="resource-unavailable">
        <doc xml:space="preserve">A resource is not available</doc>
      </member>
      <function name="quark" c:identifier="gst_gl_context_error_quark">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for #GstGLContext in #GError's</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="GLContextPrivate" c:type="GstGLContextPrivate" disguised="1"/>
    <callback name="GLContextThreadFunc" c:type="GstGLContextThreadFunc">
      <doc xml:space="preserve">Represents a function to run in the GL thread with @context and @data</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="GLDisplay" c:symbol-prefix="gl_display" c:type="GstGLDisplay" parent="Gst.Object" glib:type-name="GstGLDisplay" glib:get-type="gst_gl_display_get_type" glib:type-struct="GLDisplayClass">
      <doc xml:space="preserve">#GstGLDisplay represents a connection to the underlying windowing system.
Elements are required to make use of #GstContext to share and propagate
a #GstGLDisplay.

There are a number of environment variables that influence the choice of
platform and window system specific functionality.
- GST_GL_WINDOW influences the window system to use.  Common values are
  'x11', 'wayland', 'win32' or 'cocoa'.
- GST_GL_PLATFORM influences the OpenGL platform to use.  Common values are
  'egl', 'glx', 'wgl' or 'cgl'.
- GST_GL_API influences the OpenGL API requested by the OpenGL platform.
  Common values are 'opengl', 'opengl3' and 'gles2'.

&gt; Certain window systems require a special function to be called to
&gt; initialize threading support.  As this GStreamer GL library does not preclude
&gt; concurrent access to the windowing system, it is strongly advised that
&gt; applications ensure that threading support has been initialized before any
&gt; other toolkit/library functionality is accessed.  Failure to do so could
&gt; result in sudden application abortion during execution.  The most notably
&gt; example of such a function is X11's XInitThreads\().</doc>
      <constructor name="new" c:identifier="gst_gl_display_new" version="1.4">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLDisplay</doc>
          <type name="GLDisplay" c:type="GstGLDisplay*"/>
        </return-value>
      </constructor>
      <virtual-method name="create_window" invoker="create_window">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLWindow for @display or %NULL.</doc>
          <type name="GLWindow" c:type="GstGLWindow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_handle" invoker="get_handle" version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the native handle for the display</doc>
          <type name="guintptr" c:type="guintptr"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_context" c:identifier="gst_gl_display_add_context" version="1.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @context was successfully added. %FALSE may be returned
if there already exists another context for @context's active thread.

Must be called with the object lock held.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_context" c:identifier="gst_gl_display_create_context" version="1.6" throws="1">
        <doc xml:space="preserve">It requires the display's object lock to be held.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether a new context could be created.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
          <parameter name="other_context" transfer-ownership="none">
            <doc xml:space="preserve">other #GstGLContext to share resources with.</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="p_context" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">resulting #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext**"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_window" c:identifier="gst_gl_display_create_window">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLWindow for @display or %NULL.</doc>
          <type name="GLWindow" c:type="GstGLWindow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="filter_gl_api" c:identifier="gst_gl_display_filter_gl_api">
        <doc xml:space="preserve">limit the use of OpenGL to the requested @gl_api.  This is intended to allow
application and elements to request a specific set of OpenGL API's based on
what they support.  See gst_gl_context_get_gl_api() for the retrieving the
API supported by a #GstGLContext.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
          <parameter name="gl_api" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLAPI to filter with</doc>
            <type name="GLAPI" c:type="GstGLAPI"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_window" c:identifier="gst_gl_display_find_window" version="1.12">
        <doc xml:space="preserve">Deprecated for gst_gl_display_retrieve_window().

Execute @compare_func over the list of windows stored by @display.  The
first argument to @compare_func is the #GstGLWindow being checked and the
second argument is @data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The first #GstGLWindow that causes a match
         from @compare_func</doc>
          <type name="GLWindow" c:type="GstGLWindow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">some data to pass to @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">a comparison function to run</doc>
            <type name="GLib.CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_gl_api" c:identifier="gst_gl_display_get_gl_api">
        <doc xml:space="preserve">see gst_gl_display_filter_gl_api() for what the returned value represents</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLAPI configured for @display</doc>
          <type name="GLAPI" c:type="GstGLAPI"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gl_api_unlocked" c:identifier="gst_gl_display_get_gl_api_unlocked">
        <return-value transfer-ownership="none">
          <type name="GLAPI" c:type="GstGLAPI"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gl_context_for_thread" c:identifier="gst_gl_display_get_gl_context_for_thread" version="1.6">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GstGLContext current on @thread or %NULL

Must be called with the object lock held.</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
          <parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">a #GThread</doc>
            <type name="GLib.Thread" c:type="GThread*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_handle" c:identifier="gst_gl_display_get_handle" version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the native handle for the display</doc>
          <type name="guintptr" c:type="guintptr"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_handle_type" c:identifier="gst_gl_display_get_handle_type" version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLDisplayType of @display</doc>
          <type name="GLDisplayType" c:type="GstGLDisplayType"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_context" c:identifier="gst_gl_display_remove_context" version="1.18">
        <doc xml:space="preserve">Must be called with the object lock held.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLContext to remove</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_window" c:identifier="gst_gl_display_remove_window" version="1.12">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @window could be removed from @display</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
          <parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow to remove</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </parameter>
        </parameters>
      </method>
      <method name="retrieve_window" c:identifier="gst_gl_display_retrieve_window" version="1.18">
        <doc xml:space="preserve">Execute @compare_func over the list of windows stored by @display.  The
first argument to @compare_func is the #GstGLWindow being checked and the
second argument is @data.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The first #GstGLWindow that causes a match
         from @compare_func</doc>
          <type name="GLWindow" c:type="GstGLWindow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">some data to pass to @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">a comparison function to run</doc>
            <type name="GLib.CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </method>
      <field name="object" readable="0" private="1">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="type" readable="0" private="1">
        <type name="GLDisplayType" c:type="GstGLDisplayType"/>
      </field>
      <field name="windows" readable="0" private="1">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="main_context" readable="0" private="1">
        <type name="GLib.MainContext" c:type="GMainContext*"/>
      </field>
      <field name="main_loop" readable="0" private="1">
        <type name="GLib.MainLoop" c:type="GMainLoop*"/>
      </field>
      <field name="event_source" readable="0" private="1">
        <type name="GLib.Source" c:type="GSource*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLDisplayPrivate" c:type="GstGLDisplayPrivate*"/>
      </field>
      <glib:signal name="create-context" when="last">
        <doc xml:space="preserve">Overrides the @GstGLContext creation mechanism.
It can be called in any thread and it is emitted with
display's object lock held.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new context.</doc>
          <type name="GLContext"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">other context to share resources with.</doc>
            <type name="GLContext"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="GLDisplayClass" c:type="GstGLDisplayClass" glib:is-gtype-struct-for="GLDisplay">
      <field name="object_class">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="get_handle">
        <callback name="get_handle">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the native handle for the display</doc>
            <type name="guintptr" c:type="guintptr"/>
          </return-value>
          <parameters>
            <parameter name="display" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLDisplay</doc>
              <type name="GLDisplay" c:type="GstGLDisplay*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_window">
        <callback name="create_window">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a new #GstGLWindow for @display or %NULL.</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </return-value>
          <parameters>
            <parameter name="display" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLDisplay</doc>
              <type name="GLDisplay" c:type="GstGLDisplay*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GLDisplayPrivate" c:type="GstGLDisplayPrivate" disguised="1"/>
    <bitfield name="GLDisplayType" glib:type-name="GstGLDisplayType" glib:get-type="gst_gl_display_type_get_type" c:type="GstGLDisplayType">
      <member name="none" value="0" c:identifier="GST_GL_DISPLAY_TYPE_NONE" glib:nick="none">
        <doc xml:space="preserve">no display type</doc>
      </member>
      <member name="x11" value="1" c:identifier="GST_GL_DISPLAY_TYPE_X11" glib:nick="x11">
        <doc xml:space="preserve">X11 display</doc>
      </member>
      <member name="wayland" value="2" c:identifier="GST_GL_DISPLAY_TYPE_WAYLAND" glib:nick="wayland">
        <doc xml:space="preserve">Wayland display</doc>
      </member>
      <member name="cocoa" value="4" c:identifier="GST_GL_DISPLAY_TYPE_COCOA" glib:nick="cocoa">
        <doc xml:space="preserve">Cocoa display</doc>
      </member>
      <member name="win32" value="8" c:identifier="GST_GL_DISPLAY_TYPE_WIN32" glib:nick="win32">
        <doc xml:space="preserve">Win32 display</doc>
      </member>
      <member name="dispmanx" value="16" c:identifier="GST_GL_DISPLAY_TYPE_DISPMANX" glib:nick="dispmanx">
        <doc xml:space="preserve">Dispmanx display</doc>
      </member>
      <member name="egl" value="32" c:identifier="GST_GL_DISPLAY_TYPE_EGL" glib:nick="egl">
        <doc xml:space="preserve">EGL display</doc>
      </member>
      <member name="viv_fb" value="64" c:identifier="GST_GL_DISPLAY_TYPE_VIV_FB" glib:nick="viv-fb">
        <doc xml:space="preserve">Vivante Framebuffer display</doc>
      </member>
      <member name="gbm" value="128" c:identifier="GST_GL_DISPLAY_TYPE_GBM" glib:nick="gbm">
        <doc xml:space="preserve">Mesa3D GBM display</doc>
      </member>
      <member name="egl_device" value="256" c:identifier="GST_GL_DISPLAY_TYPE_EGL_DEVICE" glib:nick="egl-device">
        <doc xml:space="preserve">EGLDevice display (Since: 1.18)</doc>
      </member>
      <member name="any" value="4294967295" c:identifier="GST_GL_DISPLAY_TYPE_ANY" glib:nick="any">
        <doc xml:space="preserve">any display type</doc>
      </member>
    </bitfield>
    <class name="GLFilter" c:symbol-prefix="gl_filter" c:type="GstGLFilter" parent="GLBaseFilter" glib:type-name="GstGLFilter" glib:get-type="gst_gl_filter_get_type" glib:type-struct="GLFilterClass">
      <doc xml:space="preserve">#GstGLFilter helps to implement simple OpenGL filter elements taking a
single input and producing a single output with a #GstGLFramebuffer</doc>
      <function name="add_rgba_pad_templates" c:identifier="gst_gl_filter_add_rgba_pad_templates">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <type name="GLFilterClass" c:type="GstGLFilterClass*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="filter">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <type name="GLFilter" c:type="GstGLFilter*"/>
          </instance-parameter>
          <parameter name="inbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="filter_texture" invoker="filter_texture" version="1.4">
        <doc xml:space="preserve">Calls filter_texture vfunc with correctly mapped #GstGLMemorys</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the transformation succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLFilter</doc>
            <type name="GLFilter" c:type="GstGLFilter*"/>
          </instance-parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">an input buffer</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </parameter>
          <parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve">an output buffer</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="init_fbo">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <type name="GLFilter" c:type="GstGLFilter*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_caps">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <type name="GLFilter" c:type="GstGLFilter*"/>
          </instance-parameter>
          <parameter name="incaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="outcaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_internal_caps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <type name="GLFilter" c:type="GstGLFilter*"/>
          </instance-parameter>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="filter_caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="draw_fullscreen_quad" c:identifier="gst_gl_filter_draw_fullscreen_quad" version="1.10">
        <doc xml:space="preserve">Render a fullscreen quad using the current GL state.  The only GL state this
modifies is the necessary vertex/index buffers and, if necessary, a
Vertex Array Object for drawing a fullscreen quad.  Framebuffer state,
any shaders, viewport state, etc must be setup by the caller.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLFilter</doc>
            <type name="GLFilter" c:type="GstGLFilter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="filter_texture" c:identifier="gst_gl_filter_filter_texture" version="1.4">
        <doc xml:space="preserve">Calls filter_texture vfunc with correctly mapped #GstGLMemorys</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the transformation succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLFilter</doc>
            <type name="GLFilter" c:type="GstGLFilter*"/>
          </instance-parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">an input buffer</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve">an output buffer</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render_to_target" c:identifier="gst_gl_filter_render_to_target" version="1.10">
        <doc xml:space="preserve">Transforms @input into @output using @func on through FBO.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the return value of @func</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLFilter</doc>
            <type name="GLFilter" c:type="GstGLFilter*"/>
          </instance-parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">the input texture</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </parameter>
          <parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve">the output texture</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="3">
            <doc xml:space="preserve">the function to transform @input into @output. called with @data</doc>
            <type name="GLFilterRenderFunc" c:type="GstGLFilterRenderFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data associated with @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="render_to_target_with_shader" c:identifier="gst_gl_filter_render_to_target_with_shader" version="1.4">
        <doc xml:space="preserve">Transforms @input into @output using @shader with a FBO.

See also: gst_gl_filter_render_to_target()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLFilter</doc>
            <type name="GLFilter" c:type="GstGLFilter*"/>
          </instance-parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">the input texture</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </parameter>
          <parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve">the output texture</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </parameter>
          <parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">the shader to use.</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GLBaseFilter" c:type="GstGLBaseFilter"/>
      </field>
      <field name="in_info">
        <doc xml:space="preserve">the video info for input buffers</doc>
        <type name="GstVideo.VideoInfo" c:type="GstVideoInfo"/>
      </field>
      <field name="out_info">
        <doc xml:space="preserve">the video info for output buffers</doc>
        <type name="GstVideo.VideoInfo" c:type="GstVideoInfo"/>
      </field>
      <field name="in_texture_target">
        <doc xml:space="preserve">The texture target of the input buffers (usually 2D)</doc>
        <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
      </field>
      <field name="out_texture_target">
        <doc xml:space="preserve">The texture target of the output buffers (usually 2D)</doc>
        <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
      </field>
      <field name="out_caps">
        <doc xml:space="preserve">the output #GstCaps</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="fbo">
        <doc xml:space="preserve">#GstGLFramebuffer object used for transformations (only for subclass usage)</doc>
        <type name="GLFramebuffer" c:type="GstGLFramebuffer*"/>
      </field>
      <field name="gl_result" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="inbuf" readable="0" private="1">
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="outbuf" readable="0" private="1">
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="default_shader" readable="0" private="1">
        <type name="GLShader" c:type="GstGLShader*"/>
      </field>
      <field name="valid_attributes" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="vao" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="vbo_indices" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="vertex_buffer" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="draw_attr_position_loc" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="draw_attr_texture_loc" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLFilterClass" c:type="GstGLFilterClass" glib:is-gtype-struct-for="GLFilter">
      <field name="parent_class">
        <type name="GLBaseFilterClass" c:type="GstGLBaseFilterClass"/>
      </field>
      <field name="set_caps">
        <callback name="set_caps">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <type name="GLFilter" c:type="GstGLFilter*"/>
            </parameter>
            <parameter name="incaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="outcaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="filter">
        <callback name="filter">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <type name="GLFilter" c:type="GstGLFilter*"/>
            </parameter>
            <parameter name="inbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="outbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="filter_texture">
        <callback name="filter_texture">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether the transformation succeeded</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLFilter</doc>
              <type name="GLFilter" c:type="GstGLFilter*"/>
            </parameter>
            <parameter name="input" transfer-ownership="none">
              <doc xml:space="preserve">an input buffer</doc>
              <type name="GLMemory" c:type="GstGLMemory*"/>
            </parameter>
            <parameter name="output" transfer-ownership="none">
              <doc xml:space="preserve">an output buffer</doc>
              <type name="GLMemory" c:type="GstGLMemory*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="init_fbo">
        <callback name="init_fbo">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <type name="GLFilter" c:type="GstGLFilter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_internal_caps">
        <callback name="transform_internal_caps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <type name="GLFilter" c:type="GstGLFilter*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="filter_caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="GLFilterRenderFunc" c:type="GstGLFilterRenderFunc" version="1.10">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the render succeeded</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filter" transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLFilter</doc>
          <type name="GLFilter" c:type="GstGLFilter*"/>
        </parameter>
        <parameter name="in_tex" transfer-ownership="none">
          <doc xml:space="preserve">the input #GstGLMemory to render</doc>
          <type name="GLMemory" c:type="GstGLMemory*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="GLFormat" glib:type-name="GstGLFormat" glib:get-type="gst_gl_format_get_type" c:type="GstGLFormat">
      <member name="luminance" value="6409" c:identifier="GST_GL_LUMINANCE" glib:nick="luminance">
        <doc xml:space="preserve">Single component replicated across R, G, and B textures
                   components</doc>
      </member>
      <member name="alpha" value="6406" c:identifier="GST_GL_ALPHA" glib:nick="alpha">
        <doc xml:space="preserve">Single component stored in the A texture component</doc>
      </member>
      <member name="luminance_alpha" value="6410" c:identifier="GST_GL_LUMINANCE_ALPHA" glib:nick="luminance-alpha">
        <doc xml:space="preserve">Combination of #GST_GL_LUMINANCE and #GST_GL_ALPHA</doc>
      </member>
      <member name="red" value="6403" c:identifier="GST_GL_RED" glib:nick="red">
        <doc xml:space="preserve">Single component stored in the R texture component</doc>
      </member>
      <member name="r8" value="33321" c:identifier="GST_GL_R8" glib:nick="r8">
        <doc xml:space="preserve">Single 8-bit component stored in the R texture component</doc>
      </member>
      <member name="rg" value="33319" c:identifier="GST_GL_RG" glib:nick="rg">
        <doc xml:space="preserve">Two components stored in the R and G texture components</doc>
      </member>
      <member name="rg8" value="33323" c:identifier="GST_GL_RG8" glib:nick="rg8">
        <doc xml:space="preserve">Two 8-bit components stored in the R and G texture components</doc>
      </member>
      <member name="rgb" value="6407" c:identifier="GST_GL_RGB" glib:nick="rgb">
        <doc xml:space="preserve">Three components stored in the R, G, and B texture components</doc>
      </member>
      <member name="rgb8" value="32849" c:identifier="GST_GL_RGB8" glib:nick="rgb8">
        <doc xml:space="preserve">Three 8-bit components stored in the R, G, and B
              texture components</doc>
      </member>
      <member name="rgb565" value="36194" c:identifier="GST_GL_RGB565" glib:nick="rgb565">
        <doc xml:space="preserve">Three components of bit depth 5, 6 and 5 stored in the R, G,
                and B texture components respectively.</doc>
      </member>
      <member name="rgb16" value="32852" c:identifier="GST_GL_RGB16" glib:nick="rgb16">
        <doc xml:space="preserve">Three 16-bit components stored in the R, G, and B
              texture components</doc>
      </member>
      <member name="rgba" value="6408" c:identifier="GST_GL_RGBA" glib:nick="rgba">
        <doc xml:space="preserve">Four components stored in the R, G, B, and A texture
              components respectively.</doc>
      </member>
      <member name="rgba8" value="32856" c:identifier="GST_GL_RGBA8" glib:nick="rgba8">
        <doc xml:space="preserve">Four 8-bit components stored in the R, G, B, and A texture
               components respectively.</doc>
      </member>
      <member name="rgba16" value="32859" c:identifier="GST_GL_RGBA16" glib:nick="rgba16">
        <doc xml:space="preserve">Four 16-bit components stored in the R, G, B, and A texture
               components respectively.</doc>
      </member>
      <member name="depth_component16" value="33189" c:identifier="GST_GL_DEPTH_COMPONENT16" glib:nick="depth-component16">
        <doc xml:space="preserve">A single 16-bit component for depth information.</doc>
      </member>
      <member name="depth24_stencil8" value="35056" c:identifier="GST_GL_DEPTH24_STENCIL8" glib:nick="depth24-stencil8">
        <doc xml:space="preserve">A 24-bit component for depth information and
                          a 8-bit component for stencil informat.</doc>
      </member>
      <member name="rgb10_a2" value="32857" c:identifier="GST_GL_RGB10_A2" glib:nick="rgb10-a2">
      </member>
      <member name="r16" value="33322" c:identifier="GST_GL_R16" glib:nick="r16">
        <doc xml:space="preserve">Single 16-bit component stored in the R texture component</doc>
      </member>
      <member name="rg16" value="33324" c:identifier="GST_GL_RG16" glib:nick="rg16">
        <doc xml:space="preserve">Two 16-bit components stored in the R and G texture components</doc>
      </member>
      <function name="from_video_info" c:identifier="gst_gl_format_from_video_info">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLFormat necessary for holding the data in @plane of @vinfo</doc>
          <type name="GLFormat" c:type="GstGLFormat"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="vinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #GstVideoInfo</doc>
            <type name="GstVideo.VideoInfo" c:type="GstVideoInfo*"/>
          </parameter>
          <parameter name="plane" transfer-ownership="none">
            <doc xml:space="preserve">the plane number in @vinfo</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_supported" c:identifier="gst_gl_format_is_supported" version="1.16">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @format is supported by @context based on the OpenGL API,
         version, or available OpenGL extension/s.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLFormat to check is supported by @context</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_from_sized_gl_format" c:identifier="gst_gl_format_type_from_sized_gl_format" version="1.16">
        <doc xml:space="preserve">Get the unsized format and type from @format for usage in glReadPixels,
glTex{Sub}Image*, glTexImage* and similar functions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the sized internal #GstGLFormat</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
          <parameter name="unsized_format" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location for the resulting unsized #GstGLFormat</doc>
            <type name="GLFormat" c:type="GstGLFormat*"/>
          </parameter>
          <parameter name="gl_type" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location for the resulting GL type</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_n_bytes" c:identifier="gst_gl_format_type_n_bytes">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes the specified @format, @type combination takes
per pixel</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the OpenGL format, `GL_RGBA`, `GL_LUMINANCE`, etc</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the OpenGL type, `GL_UNSIGNED_BYTE`, `GL_FLOAT`, etc</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <class name="GLFramebuffer" c:symbol-prefix="gl_framebuffer" c:type="GstGLFramebuffer" version="1.10" parent="Gst.Object" glib:type-name="GstGLFramebuffer" glib:get-type="gst_gl_framebuffer_get_type" glib:type-struct="GLFramebufferClass">
      <doc xml:space="preserve">A #GstGLFramebuffer represents and holds an OpenGL framebuffer object with
it's associated attachments.

A #GstGLFramebuffer can be created with gst_gl_framebuffer_new() or
gst_gl_framebuffer_new_with_default_depth() and bound with
gst_gl_framebuffer_bind().  Other resources can be bound with
gst_gl_framebuffer_attach()

Note: OpenGL framebuffers are not shareable resources so cannot be used
between multiple OpenGL contexts.</doc>
      <constructor name="new" c:identifier="gst_gl_framebuffer_new" version="1.10">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLFramebuffer</doc>
          <type name="GLFramebuffer" c:type="GstGLFramebuffer*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_default_depth" c:identifier="gst_gl_framebuffer_new_with_default_depth" version="1.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #GstGLFramebuffer with a depth buffer of @width and @height</doc>
          <type name="GLFramebuffer" c:type="GstGLFramebuffer*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">width for the depth buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">for the depth buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="attach" c:identifier="gst_gl_framebuffer_attach" version="1.10">
        <doc xml:space="preserve">attach @mem to @attachment_point</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fb" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLFramebuffer</doc>
            <type name="GLFramebuffer" c:type="GstGLFramebuffer*"/>
          </instance-parameter>
          <parameter name="attachment_point" transfer-ownership="none">
            <doc xml:space="preserve">the OpenGL attachment point to bind @mem to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="mem" transfer-ownership="none">
            <doc xml:space="preserve">the memory object to bind to @attachment_point</doc>
            <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind" c:identifier="gst_gl_framebuffer_bind" version="1.10">
        <doc xml:space="preserve">Bind @fb into the current thread</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fb" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLFramebuffer</doc>
            <type name="GLFramebuffer" c:type="GstGLFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="draw_to_texture" c:identifier="gst_gl_framebuffer_draw_to_texture" version="1.10">
        <doc xml:space="preserve">Perform the steps necessary to have the output of a glDraw* command in
@func update the contents of @mem.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the result of executing @func</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="fb" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLFramebuffer</doc>
            <type name="GLFramebuffer" c:type="GstGLFramebuffer*"/>
          </instance-parameter>
          <parameter name="mem" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLMemory to draw to</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to run</doc>
            <type name="GLFramebufferFunc" c:type="GstGLFramebufferFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_effective_dimensions" c:identifier="gst_gl_framebuffer_get_effective_dimensions" version="1.10">
        <doc xml:space="preserve">Retrieve the effective dimensions from the current attachments attached to
@fb.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fb" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLFramebuffer</doc>
            <type name="GLFramebuffer" c:type="GstGLFramebuffer*"/>
          </instance-parameter>
          <parameter name="width" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">output width</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="height" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">output height</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="gst_gl_framebuffer_get_id" version="1.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the OpenGL id for @fb</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="fb" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLFramebuffer</doc>
            <type name="GLFramebuffer" c:type="GstGLFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="object" readable="0" private="1">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="context" readable="0" private="1">
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="fbo_id" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="attachments" readable="0" private="1">
        <array name="GLib.Array" c:type="GArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLFramebufferPrivate" c:type="GstGLFramebufferPrivate*"/>
      </field>
    </class>
    <record name="GLFramebufferClass" c:type="GstGLFramebufferClass" glib:is-gtype-struct-for="GLFramebuffer">
      <doc xml:space="preserve">Opaque #GstGLFramebufferClass struct</doc>
      <field name="object_class" readable="0" private="1">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="GLFramebufferFunc" c:type="GstGLFramebufferFunc">
      <doc xml:space="preserve">callback definition for operating through a #GstGLFramebuffer object</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="stuff" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="GLFramebufferPrivate" c:type="GstGLFramebufferPrivate" disguised="1"/>
    <record name="GLFuncs" c:type="GstGLFuncs" disguised="1">
      <doc xml:space="preserve">Structure containing function pointers to OpenGL functions.

Each field is named exactly the same as the OpenGL function without the
`gl` prefix.</doc>
    </record>
    <record name="GLMemory" c:type="GstGLMemory">
      <doc xml:space="preserve">GstGLMemory is a #GstGLBaseMemory subclass providing support for the mapping of
OpenGL textures.

#GstGLMemory is created or wrapped through gst_gl_base_memory_alloc()
with #GstGLVideoAllocationParams.

Data is uploaded or downloaded from the GPU as is necessary.</doc>
      <field name="mem" writable="1">
        <doc xml:space="preserve">the parent #GstGLBaseMemory object</doc>
        <type name="GLBaseMemory" c:type="GstGLBaseMemory"/>
      </field>
      <field name="tex_id" writable="1">
        <doc xml:space="preserve">the GL texture id for this memory</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="tex_target" writable="1">
        <doc xml:space="preserve">the GL texture target for this memory</doc>
        <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
      </field>
      <field name="tex_format" writable="1">
        <doc xml:space="preserve">the texture type</doc>
        <type name="GLFormat" c:type="GstGLFormat"/>
      </field>
      <field name="info" writable="1">
        <doc xml:space="preserve">the texture's #GstVideoInfo</doc>
        <type name="GstVideo.VideoInfo" c:type="GstVideoInfo"/>
      </field>
      <field name="valign" writable="1">
        <doc xml:space="preserve">data alignment for system memory mapping</doc>
        <type name="GstVideo.VideoAlignment" c:type="GstVideoAlignment"/>
      </field>
      <field name="plane" writable="1">
        <doc xml:space="preserve">data plane in @info</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="tex_scaling" writable="1">
        <doc xml:space="preserve">GL shader scaling parameters for @valign and/or width/height</doc>
        <array zero-terminated="0" fixed-size="2">
          <type name="gfloat" c:type="gfloat"/>
        </array>
      </field>
      <field name="texture_wrapped" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="unpack_length" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="tex_width" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="copy_into" c:identifier="gst_gl_memory_copy_into" version="1.8">
        <doc xml:space="preserve">Copies @gl_mem into the texture specified by @tex_id.  The format of @tex_id
is specified by @tex_format, @width and @height.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the copy succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLMemory</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </instance-parameter>
          <parameter name="tex_id" transfer-ownership="none">
            <doc xml:space="preserve">OpenGL texture id</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLTextureTarget</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
          <parameter name="tex_format" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLFormat</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">width of @tex_id</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">height of @tex_id</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_teximage" c:identifier="gst_gl_memory_copy_teximage" version="1.8">
        <doc xml:space="preserve">Copies the texture in #GstGLMemory into the texture specified by @tex_id,
@out_target, @out_tex_format, @out_width and @out_height.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the copy succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the source #GstGLMemory</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </instance-parameter>
          <parameter name="tex_id" transfer-ownership="none">
            <doc xml:space="preserve">the destination texture id</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="out_target" transfer-ownership="none">
            <doc xml:space="preserve">the destination #GstGLTextureTarget</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
          <parameter name="out_tex_format" transfer-ownership="none">
            <doc xml:space="preserve">the destination #GstGLFormat</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
          <parameter name="out_width" transfer-ownership="none">
            <doc xml:space="preserve">the destination width</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_height" transfer-ownership="none">
            <doc xml:space="preserve">the destination height</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_texture_format" c:identifier="gst_gl_memory_get_texture_format" version="1.12">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLFormat of @gl_mem</doc>
          <type name="GLFormat" c:type="GstGLFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLMemory</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_texture_height" c:identifier="gst_gl_memory_get_texture_height" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the texture height of @gl_mem</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLMemory</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_texture_id" c:identifier="gst_gl_memory_get_texture_id" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the OpenGL texture handle of @gl_mem</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLMemory</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_texture_target" c:identifier="gst_gl_memory_get_texture_target" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLTextureTarget of @gl_mem</doc>
          <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLMemory</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_texture_width" c:identifier="gst_gl_memory_get_texture_width" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the texture width of @gl_mem</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLMemory</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_gl_memory_init" version="1.8">
        <doc xml:space="preserve">Initializes @mem with the required parameters.  @info is assumed to have
already have been modified with gst_video_info_align().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLBaseMemory to initialize</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </instance-parameter>
          <parameter name="allocator" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAllocator to initialize with</doc>
            <type name="Gst.Allocator" c:type="GstAllocator*"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the parent #GstMemory to initialize with</doc>
            <type name="Gst.Memory" c:type="GstMemory*"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLContext to initialize with</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLTextureTarget for this #GstGLMemory</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
          <parameter name="tex_format" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLFormat for this #GstGLMemory</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the @GstAllocationParams to initialize with</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">the #GstVideoInfo for this #GstGLMemory</doc>
            <type name="GstVideo.VideoInfo" c:type="GstVideoInfo*"/>
          </parameter>
          <parameter name="plane" transfer-ownership="none">
            <doc xml:space="preserve">the plane number (starting from 0) for this #GstGLMemory</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="valign" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional #GstVideoAlignment parameters</doc>
            <type name="GstVideo.VideoAlignment" c:type="GstVideoAlignment*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to call @notify with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_pixels" c:identifier="gst_gl_memory_read_pixels" version="1.8">
        <doc xml:space="preserve">Reads the texture in #GstGLMemory into @write_pointer if no buffer is bound
to `GL_PIXEL_PACK_BUFFER`.  Otherwise @write_pointer is the byte offset into
the currently bound `GL_PIXEL_PACK_BUFFER` buffer to store the result of
glReadPixels.  See the OpenGL specification for glReadPixels for more
details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether theread operation succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLMemory</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </instance-parameter>
          <parameter name="write_pointer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data pointer to pass to glReadPixels</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="texsubimage" c:identifier="gst_gl_memory_texsubimage" version="1.8">
        <doc xml:space="preserve">Reads the texture in @read_pointer into @gl_mem.

See gst_gl_memory_read_pixels() for what @read_pointer signifies.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLMemory</doc>
            <type name="GLMemory" c:type="GstGLMemory*"/>
          </instance-parameter>
          <parameter name="read_pointer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data pointer to pass to glTexSubImage</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <function name="init_once" c:identifier="gst_gl_memory_init_once" version="1.4">
        <doc xml:space="preserve">Initializes the GL Base Texture allocator. It is safe to call this function
multiple times.  This must be called before any other GstGLMemory operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="setup_buffer" c:identifier="gst_gl_memory_setup_buffer" version="1.8" introspectable="0">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the buffer was correctly setup</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="allocator" transfer-ownership="none">
            <doc xml:space="preserve">the @GstGLMemoryAllocator to allocate from</doc>
            <type name="GLMemoryAllocator" c:type="GstGLMemoryAllocator*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GstBuffer to setup</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLVideoAllocationParams to allocate with</doc>
            <type name="GLVideoAllocationParams" c:type="GstGLVideoAllocationParams*"/>
          </parameter>
          <parameter name="tex_formats" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">
    a list of #GstGLFormat's to allocate with.</doc>
            <array length="5" zero-terminated="0" c:type="GstGLFormat*">
              <type name="GLFormat" c:type="GstGLFormat"/>
            </array>
          </parameter>
          <parameter name="wrapped_data" transfer-ownership="none">
            <doc xml:space="preserve">
    a list of wrapped data pointers</doc>
            <array length="5" zero-terminated="0" c:type="gpointer*">
              <type name="gpointer"/>
            </array>
          </parameter>
          <parameter name="n_wrapped_pointers" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @tex_formats and @wrapped_data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="GLMemoryAllocator" c:symbol-prefix="gl_memory_allocator" c:type="GstGLMemoryAllocator" parent="GLBaseMemoryAllocator" glib:type-name="GstGLMemoryAllocator" glib:get-type="gst_gl_memory_allocator_get_type" glib:type-struct="GLMemoryAllocatorClass">
      <doc xml:space="preserve">Opaque #GstGLMemoryAllocator struct</doc>
      <function name="get_default" c:identifier="gst_gl_memory_allocator_get_default" version="1.8">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the default #GstGLMemoryAllocator supported by
         @context</doc>
          <type name="GLMemoryAllocator" c:type="GstGLMemoryAllocator*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </function>
      <field name="parent" readable="0" private="1">
        <type name="GLBaseMemoryAllocator" c:type="GstGLBaseMemoryAllocator"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLMemoryAllocatorClass" c:type="GstGLMemoryAllocatorClass" glib:is-gtype-struct-for="GLMemoryAllocator">
      <field name="parent_class" readable="0" private="1">
        <type name="GLBaseMemoryAllocatorClass" c:type="GstGLBaseMemoryAllocatorClass"/>
      </field>
      <field name="map">
        <doc xml:space="preserve">provide a custom map implementation</doc>
        <type name="GLBaseMemoryAllocatorMapFunction" c:type="GstGLBaseMemoryAllocatorMapFunction"/>
      </field>
      <field name="copy">
        <doc xml:space="preserve">provide a custom copy implementation</doc>
        <type name="GLBaseMemoryAllocatorCopyFunction" c:type="GstGLBaseMemoryAllocatorCopyFunction"/>
      </field>
      <field name="unmap">
        <doc xml:space="preserve">provide a custom unmap implementation</doc>
        <type name="GLBaseMemoryAllocatorUnmapFunction" c:type="GstGLBaseMemoryAllocatorUnmapFunction"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GLMemoryPBO" c:type="GstGLMemoryPBO">
      <doc xml:space="preserve">#GstGLMemoryPBO is created or wrapped through gst_gl_base_memory_alloc()
with #GstGLVideoAllocationParams.

Data is uploaded or downloaded from the GPU as is necessary.</doc>
      <field name="mem" readable="0" private="1">
        <type name="GLMemory" c:type="GstGLMemory"/>
      </field>
      <field name="pbo" readable="0" private="1">
        <type name="GLBuffer" c:type="GstGLBuffer*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="copy_into_texture" c:identifier="gst_gl_memory_pbo_copy_into_texture" version="1.8">
        <doc xml:space="preserve">Copies @gl_mem into the texture specified by @tex_id.  The format of @tex_id
is specified by @tex_format, @width and @height.

If @respecify is %TRUE, then the copy is performed in terms of the texture
data.  This is useful for splitting RGBA textures into RG or R textures or
vice versa. The requirement for this to succeed is that the backing texture
data must be the same size, i.e. say a RGBA8 texture is converted into a RG8
texture, then the RG texture must have twice as many pixels available for
output as the RGBA texture.

Otherwise, if @respecify is %FALSE, then the copy is performed per texel
using glCopyTexImage.  See the OpenGL specification for details on the
mappings between texture formats.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the copy succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLMemoryPBO</doc>
            <type name="GLMemoryPBO" c:type="GstGLMemoryPBO*"/>
          </instance-parameter>
          <parameter name="tex_id" transfer-ownership="none">
            <doc xml:space="preserve">the destination texture id</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the destination #GstGLTextureTarget</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
          <parameter name="tex_format" transfer-ownership="none">
            <doc xml:space="preserve">the destination #GstGLFormat</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">width of @tex_id</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">height of @tex_id</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="stride" transfer-ownership="none">
            <doc xml:space="preserve">stride of the backing texture data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="respecify" transfer-ownership="none">
            <doc xml:space="preserve">whether to copy the data or copy per texel</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="download_transfer" c:identifier="gst_gl_memory_pbo_download_transfer" version="1.8">
        <doc xml:space="preserve">Transfer the texture data from the texture into the PBO if necessary.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLMemoryPBO</doc>
            <type name="GLMemoryPBO" c:type="GstGLMemoryPBO*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="upload_transfer" c:identifier="gst_gl_memory_pbo_upload_transfer" version="1.8">
        <doc xml:space="preserve">Transfer the texture data from the PBO into the texture if necessary.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLMemoryPBO</doc>
            <type name="GLMemoryPBO" c:type="GstGLMemoryPBO*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="init_once" c:identifier="gst_gl_memory_pbo_init_once">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
    </record>
    <class name="GLMemoryPBOAllocator" c:symbol-prefix="gl_memory_pbo_allocator" c:type="GstGLMemoryPBOAllocator" parent="GLMemoryAllocator" glib:type-name="GstGLMemoryPBOAllocator" glib:get-type="gst_gl_memory_pbo_allocator_get_type" glib:type-struct="GLMemoryPBOAllocatorClass">
      <doc xml:space="preserve">Opaque #GstGLMemoryPBOAllocator struct</doc>
      <field name="parent">
        <type name="GLMemoryAllocator" c:type="GstGLMemoryAllocator"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLMemoryPBOAllocatorClass" c:type="GstGLMemoryPBOAllocatorClass" glib:is-gtype-struct-for="GLMemoryPBOAllocator">
      <doc xml:space="preserve">Only contains private data</doc>
      <field name="parent_class">
        <type name="GLMemoryAllocatorClass" c:type="GstGLMemoryAllocatorClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="GLOverlayCompositor" c:symbol-prefix="gl_overlay_compositor" c:type="GstGLOverlayCompositor" parent="Gst.Object" glib:type-name="GstGLOverlayCompositor" glib:get-type="gst_gl_overlay_compositor_get_type" glib:type-struct="GLOverlayCompositorClass">
      <doc xml:space="preserve">Opaque #GstGLOverlayCompositor object</doc>
      <constructor name="new" c:identifier="gst_gl_overlay_compositor_new">
        <return-value transfer-ownership="none">
          <type name="GLOverlayCompositor" c:type="GstGLOverlayCompositor*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="add_caps" c:identifier="gst_gl_overlay_compositor_add_caps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </function>
      <method name="draw_overlays" c:identifier="gst_gl_overlay_compositor_draw_overlays">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="compositor" transfer-ownership="none">
            <type name="GLOverlayCompositor" c:type="GstGLOverlayCompositor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_overlays" c:identifier="gst_gl_overlay_compositor_free_overlays">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="compositor" transfer-ownership="none">
            <type name="GLOverlayCompositor" c:type="GstGLOverlayCompositor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="upload_overlays" c:identifier="gst_gl_overlay_compositor_upload_overlays">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="compositor" transfer-ownership="none">
            <type name="GLOverlayCompositor" c:type="GstGLOverlayCompositor*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <property name="yinvert" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="context" readable="0" private="1">
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="last_window_width" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="last_window_height" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="overlays" readable="0" private="1">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="shader" readable="0" private="1">
        <type name="GLShader" c:type="GstGLShader*"/>
      </field>
      <field name="position_attrib" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="texcoord_attrib" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLOverlayCompositorClass" c:type="GstGLOverlayCompositorClass" glib:is-gtype-struct-for="GLOverlayCompositor">
      <field name="object_class">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="GLPlatform" glib:type-name="GstGLPlatform" glib:get-type="gst_gl_platform_get_type" c:type="GstGLPlatform">
      <member name="none" value="0" c:identifier="GST_GL_PLATFORM_NONE" glib:nick="none">
        <doc xml:space="preserve">no platform</doc>
      </member>
      <member name="egl" value="1" c:identifier="GST_GL_PLATFORM_EGL" glib:nick="egl">
        <doc xml:space="preserve">the EGL platform used primarily with the X11, wayland
                     and android window systems as well as on embedded Linux</doc>
      </member>
      <member name="glx" value="2" c:identifier="GST_GL_PLATFORM_GLX" glib:nick="glx">
        <doc xml:space="preserve">the GLX platform used primarily with the X11 window system</doc>
      </member>
      <member name="wgl" value="4" c:identifier="GST_GL_PLATFORM_WGL" glib:nick="wgl">
        <doc xml:space="preserve">the WGL platform used primarily on Windows</doc>
      </member>
      <member name="cgl" value="8" c:identifier="GST_GL_PLATFORM_CGL" glib:nick="cgl">
        <doc xml:space="preserve">the CGL platform used primarily on OS X</doc>
      </member>
      <member name="eagl" value="16" c:identifier="GST_GL_PLATFORM_EAGL" glib:nick="eagl">
        <doc xml:space="preserve">the EAGL platform used primarily on iOS</doc>
      </member>
      <member name="any" value="4294967295" c:identifier="GST_GL_PLATFORM_ANY" glib:nick="any">
        <doc xml:space="preserve">any OpenGL platform</doc>
      </member>
      <function name="from_string" c:identifier="gst_gl_platform_from_string">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #GstGLPlatform represented by @platform_s</doc>
          <type name="GLPlatform" c:type="GstGLPlatform"/>
        </return-value>
        <parameters>
          <parameter name="platform_s" transfer-ownership="none">
            <doc xml:space="preserve">a space separated string of OpenGL platformss</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_string" c:identifier="gst_gl_platform_to_string">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A space separated string of the OpenGL platforms enabled in @platform</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="platform" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLPlatform to stringify</doc>
            <type name="GLPlatform" c:type="GstGLPlatform"/>
          </parameter>
        </parameters>
      </function>
    </bitfield>
    <record name="GLQuery" c:type="GstGLQuery" version="1.10">
      <doc xml:space="preserve">A #GstGLQuery represents and holds an OpenGL query object.  Various types of
queries can be run or counters retrieved.</doc>
      <field name="context" readable="0" private="1">
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="query_type" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="query_id" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="supported" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="start_called" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="debug" readable="0" private="1">
        <type name="GLAsyncDebug" c:type="GstGLAsyncDebug"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="counter" c:identifier="gst_gl_query_counter" version="1.10">
        <doc xml:space="preserve">Record the result of a counter</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLQuery</doc>
            <type name="GLQuery" c:type="GstGLQuery*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="end" c:identifier="gst_gl_query_end" version="1.10">
        <doc xml:space="preserve">End counting the query</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLQuery</doc>
            <type name="GLQuery" c:type="GstGLQuery*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_gl_query_free" version="1.10">
        <doc xml:space="preserve">Frees a #GstGLQuery</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLQuery</doc>
            <type name="GLQuery" c:type="GstGLQuery*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_gl_query_init" version="1.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLQuery</doc>
            <type name="GLQuery" c:type="GstGLQuery*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="query_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLQueryType</doc>
            <type name="GLQueryType" c:type="GstGLQueryType"/>
          </parameter>
        </parameters>
      </method>
      <method name="result" c:identifier="gst_gl_query_result" version="1.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the result of the query</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLQuery</doc>
            <type name="GLQuery" c:type="GstGLQuery*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="gst_gl_query_start" version="1.10">
        <doc xml:space="preserve">Start counting the query</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLQuery</doc>
            <type name="GLQuery" c:type="GstGLQuery*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unset" c:identifier="gst_gl_query_unset" version="1.10">
        <doc xml:space="preserve">Free any dynamically allocated resources</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLQuery</doc>
            <type name="GLQuery" c:type="GstGLQuery*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="local_gl_context" c:identifier="gst_gl_query_local_gl_context">
        <doc xml:space="preserve">Performs a GST_QUERY_CONTEXT query of type "gst.gl.local_context" on all
#GstPads in @element of @direction for the local OpenGL context used by
GStreamer elements.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @context_ptr contains a #GstGLContext</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:space="preserve">a #GstElement to query from</doc>
            <type name="Gst.Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">the #GstPadDirection to query</doc>
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="context_ptr" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location containing the current and/or resulting
                     #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext**"/>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="gst_gl_query_new" version="1.10" introspectable="0">
        <doc xml:space="preserve">Free with gst_gl_query_free()</doc>
        <return-value>
          <doc xml:space="preserve">a new #GstGLQuery</doc>
          <type name="GLQuery" c:type="GstGLQuery*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="query_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLQueryType to create</doc>
            <type name="GLQueryType" c:type="GstGLQueryType"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="GLQueryType" glib:type-name="GstGLQueryType" glib:get-type="gst_gl_query_type_get_type" c:type="GstGLQueryType">
      <member name="none" value="0" c:identifier="GST_GL_QUERY_NONE" glib:nick="none">
        <doc xml:space="preserve">no query</doc>
      </member>
      <member name="time_elapsed" value="1" c:identifier="GST_GL_QUERY_TIME_ELAPSED" glib:nick="time-elapsed">
        <doc xml:space="preserve">query the time elapsed</doc>
      </member>
      <member name="timestamp" value="2" c:identifier="GST_GL_QUERY_TIMESTAMP" glib:nick="timestamp">
        <doc xml:space="preserve">query the current time</doc>
      </member>
    </enumeration>
    <record name="GLRenderbuffer" c:type="GstGLRenderbuffer" version="1.10">
      <doc xml:space="preserve">GstGLRenderbuffer is a #GstGLBaseMemory subclass providing support for
OpenGL renderbuffers.

#GstGLRenderbuffer is created or wrapped through gst_gl_base_memory_alloc()
with #GstGLRenderbufferAllocationParams.</doc>
      <field name="mem" readable="0" private="1">
        <type name="GLBaseMemory" c:type="GstGLBaseMemory"/>
      </field>
      <field name="renderbuffer_id" writable="1">
        <doc xml:space="preserve">the GL texture id for this memory</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="renderbuffer_format" writable="1">
        <doc xml:space="preserve">the texture type</doc>
        <type name="GLFormat" c:type="GstGLFormat"/>
      </field>
      <field name="width" writable="1">
        <doc xml:space="preserve">the width</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="height" writable="1">
        <doc xml:space="preserve">the height</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="renderbuffer_wrapped" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="get_format" c:identifier="gst_gl_renderbuffer_get_format" version="1.12">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLFormat of @gl_mem</doc>
          <type name="GLFormat" c:type="GstGLFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLRenderbuffer</doc>
            <type name="GLRenderbuffer" c:type="GstGLRenderbuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="gst_gl_renderbuffer_get_height" version="1.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configured height of @gl_mem</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLRenderbuffer</doc>
            <type name="GLRenderbuffer" c:type="GstGLRenderbuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="gst_gl_renderbuffer_get_id" version="1.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the OpenGL renderbuffer handle of @gl_mem</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLRenderbuffer</doc>
            <type name="GLRenderbuffer" c:type="GstGLRenderbuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="gst_gl_renderbuffer_get_width" version="1.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configured width of @gl_mem</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="gl_mem" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLRenderbuffer</doc>
            <type name="GLRenderbuffer" c:type="GstGLRenderbuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="init_once" c:identifier="gst_gl_renderbuffer_init_once" version="1.10">
        <doc xml:space="preserve">Initializes the GL Base Texture allocator. It is safe to call this function
multiple times.  This must be called before any other GstGLRenderbuffer operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
    </record>
    <record name="GLRenderbufferAllocationParams" c:type="GstGLRenderbufferAllocationParams" glib:type-name="GstGLRenderbufferAllocationParams" glib:get-type="gst_gl_renderbuffer_allocation_params_get_type" c:symbol-prefix="gl_renderbuffer_allocation_params">
      <doc xml:space="preserve">Allocation parameters</doc>
      <field name="parent" readable="0" private="1">
        <type name="GLAllocationParams" c:type="GstGLAllocationParams"/>
      </field>
      <field name="renderbuffer_format" writable="1">
        <doc xml:space="preserve">the #GstGLFormat</doc>
        <type name="GLFormat" c:type="GstGLFormat"/>
      </field>
      <field name="width" writable="1">
        <doc xml:space="preserve">the width</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="height" writable="1">
        <doc xml:space="preserve">the height</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <constructor name="new" c:identifier="gst_gl_renderbuffer_allocation_params_new" version="1.10">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLRenderbufferAllocationParams for allocating #GstGLRenderbuffer's</doc>
          <type name="GLRenderbufferAllocationParams" c:type="GstGLRenderbufferAllocationParams*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="alloc_params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GstAllocationParams for sysmem mappings of the texture</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
          <parameter name="renderbuffer_format" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLFormat for the created textures</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">the width of the renderbuffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">the height of the renderbuffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_wrapped" c:identifier="gst_gl_renderbuffer_allocation_params_new_wrapped" version="1.10">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLRenderbufferAllocationParams for wrapping @gl_handle as a
         renderbuffer</doc>
          <type name="GLRenderbufferAllocationParams" c:type="GstGLRenderbufferAllocationParams*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="alloc_params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GstAllocationParams for @tex_id</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
          <parameter name="renderbuffer_format" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLFormat for @tex_id</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">the width of the renderbuffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">the height of the renderbuffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="gl_handle" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the GL handle to wrap</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to call @notify with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
    </record>
    <class name="GLRenderbufferAllocator" c:symbol-prefix="gl_renderbuffer_allocator" c:type="GstGLRenderbufferAllocator" parent="GLBaseMemoryAllocator" glib:type-name="GstGLRenderbufferAllocator" glib:get-type="gst_gl_renderbuffer_allocator_get_type" glib:type-struct="GLRenderbufferAllocatorClass">
      <doc xml:space="preserve">Opaque #GstGLRenderbufferAllocator struct</doc>
      <field name="parent">
        <type name="GLBaseMemoryAllocator" c:type="GstGLBaseMemoryAllocator"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLRenderbufferAllocatorClass" c:type="GstGLRenderbufferAllocatorClass" glib:is-gtype-struct-for="GLRenderbufferAllocator">
      <doc xml:space="preserve">The #GstGLRenderbufferAllocatorClass only contains private data</doc>
      <field name="parent_class">
        <type name="GLBaseMemoryAllocatorClass" c:type="GstGLBaseMemoryAllocatorClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="GLSLError" version="1.8" glib:type-name="GstGLSLError" glib:get-type="gst_glsl_error_get_type" c:type="GstGLSLError" glib:error-domain="gst-glsl-error-quark">
      <doc xml:space="preserve">Compilation stage that caused an error</doc>
      <member name="compile" value="0" c:identifier="GST_GLSL_ERROR_COMPILE" glib:nick="compile">
        <doc xml:space="preserve">Compilation error occurred</doc>
      </member>
      <member name="link" value="1" c:identifier="GST_GLSL_ERROR_LINK" glib:nick="link">
        <doc xml:space="preserve">Link error occurred</doc>
      </member>
      <member name="program" value="2" c:identifier="GST_GLSL_ERROR_PROGRAM" glib:nick="program">
        <doc xml:space="preserve">General program error occurred</doc>
      </member>
      <function name="quark" c:identifier="gst_glsl_error_quark">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for GstGLSL in #GError's</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="GLSLProfile" version="1.8" glib:type-name="GstGLSLProfile" glib:get-type="gst_glsl_profile_get_type" c:type="GstGLSLProfile">
      <doc xml:space="preserve">GLSL profiles</doc>
      <member name="none" value="0" c:identifier="GST_GLSL_PROFILE_NONE" glib:nick="none">
        <doc xml:space="preserve">no profile supported/available</doc>
      </member>
      <member name="es" value="1" c:identifier="GST_GLSL_PROFILE_ES" glib:nick="es">
        <doc xml:space="preserve">OpenGL|ES profile</doc>
      </member>
      <member name="core" value="2" c:identifier="GST_GLSL_PROFILE_CORE" glib:nick="core">
        <doc xml:space="preserve">OpenGL core profile</doc>
      </member>
      <member name="compatibility" value="4" c:identifier="GST_GLSL_PROFILE_COMPATIBILITY" glib:nick="compatibility">
        <doc xml:space="preserve">OpenGL compatibility profile</doc>
      </member>
      <member name="any" value="4294967295" c:identifier="GST_GLSL_PROFILE_ANY" glib:nick="any">
        <doc xml:space="preserve">any OpenGL/OpenGL|ES profile</doc>
      </member>
      <function name="from_string" c:identifier="gst_glsl_profile_from_string">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLSLProfile of @string or %GST_GLSL_PROFILE_NONE on error</doc>
          <type name="GLSLProfile" c:type="GstGLSLProfile"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a GLSL version string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_string" c:identifier="gst_glsl_profile_to_string">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the name for @profile or %NULL on error</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="profile" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLProfile</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile"/>
          </parameter>
        </parameters>
      </function>
    </bitfield>
    <class name="GLSLStage" c:symbol-prefix="glsl_stage" c:type="GstGLSLStage" parent="Gst.Object" glib:type-name="GstGLSLStage" glib:get-type="gst_glsl_stage_get_type" glib:type-struct="GLSLStageClass">
      <doc xml:space="preserve">#GstGLSLStage holds and represents a single OpenGL shader stage.</doc>
      <constructor name="new" c:identifier="gst_glsl_stage_new" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #GstGLSLStage of the specified @type</doc>
          <type name="GLSLStage" c:type="GstGLSLStage*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the GL enum shader stage type</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_default_fragment" c:identifier="gst_glsl_stage_new_default_fragment">
        <return-value transfer-ownership="none">
          <type name="GLSLStage" c:type="GstGLSLStage*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_default_vertex" c:identifier="gst_glsl_stage_new_default_vertex">
        <return-value transfer-ownership="none">
          <type name="GLSLStage" c:type="GstGLSLStage*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_string" c:identifier="gst_glsl_stage_new_with_string" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #GstGLSLStage of the specified @type</doc>
          <type name="GLSLStage" c:type="GstGLSLStage*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the GL enum shader stage type</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion"/>
          </parameter>
          <parameter name="profile" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLSLProfile</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">a shader string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_strings" c:identifier="gst_glsl_stage_new_with_strings" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #GstGLSLStage of the specified @type</doc>
          <type name="GLSLStage" c:type="GstGLSLStage*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the GL enum shader stage type</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion"/>
          </parameter>
          <parameter name="profile" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLSLProfile</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile"/>
          </parameter>
          <parameter name="n_strings" transfer-ownership="none">
            <doc xml:space="preserve">the number of strings in @str</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">
    an array of strings concatted together to produce a shader</doc>
            <array length="4" zero-terminated="0" c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <method name="compile" c:identifier="gst_glsl_stage_compile" version="1.8" throws="1">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the compilation succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLStage</doc>
            <type name="GLSLStage" c:type="GstGLSLStage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_handle" c:identifier="gst_glsl_stage_get_handle" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The GL handle for this shader stage</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLStage</doc>
            <type name="GLSLStage" c:type="GstGLSLStage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_profile" c:identifier="gst_glsl_stage_get_profile" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The GLSL profile for the current shader stage</doc>
          <type name="GLSLProfile" c:type="GstGLSLProfile"/>
        </return-value>
        <parameters>
          <instance-parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLStage</doc>
            <type name="GLSLStage" c:type="GstGLSLStage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_shader_type" c:identifier="gst_glsl_stage_get_shader_type" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The GL shader type for this shader stage</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLStage</doc>
            <type name="GLSLStage" c:type="GstGLSLStage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_version" c:identifier="gst_glsl_stage_get_version" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The GLSL version for the current shader stage</doc>
          <type name="GLSLVersion" c:type="GstGLSLVersion"/>
        </return-value>
        <parameters>
          <instance-parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLStage</doc>
            <type name="GLSLStage" c:type="GstGLSLStage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_strings" c:identifier="gst_glsl_stage_set_strings" version="1.8">
        <doc xml:space="preserve">Replaces the current shader string with @str.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLStage</doc>
            <type name="GLSLStage" c:type="GstGLSLStage*"/>
          </instance-parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion"/>
          </parameter>
          <parameter name="profile" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLProfile</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile"/>
          </parameter>
          <parameter name="n_strings" transfer-ownership="none">
            <doc xml:space="preserve">number of strings in @str</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">a GLSL shader string</doc>
            <array length="2" zero-terminated="0" c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="context" readable="0" private="1">
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLSLStagePrivate" c:type="GstGLSLStagePrivate*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLSLStageClass" c:type="GstGLSLStageClass" glib:is-gtype-struct-for="GLSLStage">
      <doc xml:space="preserve">Opaque #GstGLSLStageClass struct</doc>
      <field name="parent" readable="0" private="1">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GLSLStagePrivate" c:type="GstGLSLStagePrivate" disguised="1"/>
    <enumeration name="GLSLVersion" version="1.8" glib:type-name="GstGLSLVersion" glib:get-type="gst_glsl_version_get_type" c:type="GstGLSLVersion">
      <doc xml:space="preserve">GLSL version list</doc>
      <member name="none" value="0" c:identifier="GST_GLSL_VERSION_NONE" glib:nick="none">
        <doc xml:space="preserve">no version</doc>
      </member>
      <member name="100" value="100" c:identifier="GST_GLSL_VERSION_100" glib:nick="100">
        <doc xml:space="preserve">version 100 (only valid for ES)</doc>
      </member>
      <member name="110" value="110" c:identifier="GST_GLSL_VERSION_110" glib:nick="110">
        <doc xml:space="preserve">version 110 (only valid for compatibility desktop GL)</doc>
      </member>
      <member name="120" value="120" c:identifier="GST_GLSL_VERSION_120" glib:nick="120">
        <doc xml:space="preserve">version 120 (only valid for compatibility desktop GL)</doc>
      </member>
      <member name="130" value="130" c:identifier="GST_GLSL_VERSION_130" glib:nick="130">
        <doc xml:space="preserve">version 130 (only valid for compatibility desktop GL)</doc>
      </member>
      <member name="140" value="140" c:identifier="GST_GLSL_VERSION_140" glib:nick="140">
        <doc xml:space="preserve">version 140 (only valid for compatibility desktop GL)</doc>
      </member>
      <member name="150" value="150" c:identifier="GST_GLSL_VERSION_150" glib:nick="150">
        <doc xml:space="preserve">version 150 (valid for compatibility/core desktop GL)</doc>
      </member>
      <member name="300" value="300" c:identifier="GST_GLSL_VERSION_300" glib:nick="300">
        <doc xml:space="preserve">version 300 (only valid for ES)</doc>
      </member>
      <member name="310" value="310" c:identifier="GST_GLSL_VERSION_310" glib:nick="310">
        <doc xml:space="preserve">version 310 (only valid for ES)</doc>
      </member>
      <member name="320" value="320" c:identifier="GST_GLSL_VERSION_320" glib:nick="320">
        <doc xml:space="preserve">version 320 (only valid for ES)</doc>
      </member>
      <member name="330" value="330" c:identifier="GST_GLSL_VERSION_330" glib:nick="330">
        <doc xml:space="preserve">version 330 (valid for compatibility/core desktop GL)</doc>
      </member>
      <member name="400" value="400" c:identifier="GST_GLSL_VERSION_400" glib:nick="400">
        <doc xml:space="preserve">version 400 (valid for compatibility/core desktop GL)</doc>
      </member>
      <member name="410" value="410" c:identifier="GST_GLSL_VERSION_410" glib:nick="410">
        <doc xml:space="preserve">version 410 (valid for compatibility/core desktop GL)</doc>
      </member>
      <member name="420" value="420" c:identifier="GST_GLSL_VERSION_420" glib:nick="420">
        <doc xml:space="preserve">version 420 (valid for compatibility/core desktop GL)</doc>
      </member>
      <member name="430" value="430" c:identifier="GST_GLSL_VERSION_430" glib:nick="430">
        <doc xml:space="preserve">version 430 (valid for compatibility/core desktop GL)</doc>
      </member>
      <member name="440" value="440" c:identifier="GST_GLSL_VERSION_440" glib:nick="440">
        <doc xml:space="preserve">version 440 (valid for compatibility/core desktop GL)</doc>
      </member>
      <member name="450" value="450" c:identifier="GST_GLSL_VERSION_450" glib:nick="450">
        <doc xml:space="preserve">version 450 (valid for compatibility/core desktop GL)</doc>
      </member>
      <function name="from_string" c:identifier="gst_glsl_version_from_string">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLSLVersion of @string or %GST_GLSL_VERSION_NONE on error</doc>
          <type name="GLSLVersion" c:type="GstGLSLVersion"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a GLSL version string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="profile_from_string" c:identifier="gst_glsl_version_profile_from_string">
        <doc xml:space="preserve">Note: this function expects either a `#version` GLSL preprocesser directive
or a valid GLSL version and/or profile.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if a valid `#version` string was found, FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a valid GLSL `#version` string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="version_ret" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">resulting #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion*"/>
          </parameter>
          <parameter name="profile_ret" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">resulting #GstGLSLVersion</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile*"/>
          </parameter>
        </parameters>
      </function>
      <function name="profile_to_string" c:identifier="gst_glsl_version_profile_to_string">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the combined GLSL `#version` string for @version and @profile</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion"/>
          </parameter>
          <parameter name="profile" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLVersion</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_string" c:identifier="gst_glsl_version_to_string">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the name of @version or %NULL on error</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <function-macro name="GLSL_STAGE" c:identifier="GST_GLSL_STAGE" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GLSL_STAGE_CLASS" c:identifier="GST_GLSL_STAGE_CLASS" introspectable="0">
      <parameters>
        <parameter name="k">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GLSL_STAGE_GET_CLASS" c:identifier="GST_GLSL_STAGE_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <class name="GLShader" c:symbol-prefix="gl_shader" c:type="GstGLShader" parent="Gst.Object" glib:type-name="GstGLShader" glib:get-type="gst_gl_shader_get_type" glib:type-struct="GLShaderClass">
      <constructor name="new" c:identifier="gst_gl_shader_new">
        <doc xml:space="preserve">Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new empty @shader</doc>
          <type name="GLShader" c:type="GstGLShader*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_default" c:identifier="gst_gl_shader_new_default" version="1.8" throws="1">
        <doc xml:space="preserve">Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a default @shader or %NULL on failure</doc>
          <type name="GLShader" c:type="GstGLShader*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_link_with_stages" c:identifier="gst_gl_shader_new_link_with_stages" version="1.8" introspectable="0">
        <doc xml:space="preserve">Each stage will attempt to be compiled and attached to @shader.  Then
the shader will be linked. On error, %NULL will be returned and @error will
contain the details of the error.

Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new @shader with the specified stages.</doc>
          <type name="GLShader" c:type="GstGLShader*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">a NULL terminated list of #GstGLSLStage's</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_stages" c:identifier="gst_gl_shader_new_with_stages" version="1.8" introspectable="0">
        <doc xml:space="preserve">Each stage will attempt to be compiled and attached to @shader.  On error,
%NULL will be returned and @error will contain the details of the error.

Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new @shader with the specified stages.</doc>
          <type name="GLShader" c:type="GstGLShader*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">a NULL terminated list of #GstGLSLStage's</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <function name="string_fragment_external_oes_get_default" c:identifier="gst_gl_shader_string_fragment_external_oes_get_default" version="1.16">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a passthrough shader string for copying an input external-oes
         texture to the output</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion"/>
          </parameter>
          <parameter name="profile" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLProfile</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile"/>
          </parameter>
        </parameters>
      </function>
      <function name="string_fragment_get_default" c:identifier="gst_gl_shader_string_fragment_get_default" version="1.16">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a passthrough shader string for copying an input texture to
         the output</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion"/>
          </parameter>
          <parameter name="profile" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLProfile</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile"/>
          </parameter>
        </parameters>
      </function>
      <function name="string_get_highest_precision" c:identifier="gst_gl_shader_string_get_highest_precision" version="1.16">
        <doc xml:space="preserve">Generates a shader string that defines the precision of float types in
GLSL shaders.  This is particularly needed for fragment shaders in a
GLSL ES context where there is no default precision specified.

Practically, this will return the string 'precision mediump float'
or 'precision highp float' depending on if high precision floats are
determined to be supported.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a shader string defining the precision of float types based on
     @context, @version and @profile</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLVersion</doc>
            <type name="GLSLVersion" c:type="GstGLSLVersion"/>
          </parameter>
          <parameter name="profile" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLProfile</doc>
            <type name="GLSLProfile" c:type="GstGLSLProfile"/>
          </parameter>
        </parameters>
      </function>
      <method name="attach" c:identifier="gst_gl_shader_attach" version="1.8">
        <doc xml:space="preserve">Attaches @stage to @shader.  @stage must have been successfully compiled
with gst_glsl_stage_compile().

Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @stage could be attached to @shader</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLStage to attach</doc>
            <type name="GLSLStage" c:type="GstGLSLStage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="attach_unlocked" c:identifier="gst_gl_shader_attach_unlocked" version="1.8">
        <doc xml:space="preserve">Attaches @stage to @shader.  @stage must have been successfully compiled
with gst_glsl_stage_compile().

Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @stage could be attached to @shader</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLStage to attach</doc>
            <type name="GLSLStage" c:type="GstGLSLStage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_attribute_location" c:identifier="gst_gl_shader_bind_attribute_location">
        <doc xml:space="preserve">Bind attribute @name to the specified location @index using
`glBindAttributeLocation()`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">attribute index to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the attribute</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_frag_data_location" c:identifier="gst_gl_shader_bind_frag_data_location">
        <doc xml:space="preserve">Bind attribute @name to the specified location @index using
`glBindFragDataLocation()`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">attribute index to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the attribute</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="compile_attach_stage" c:identifier="gst_gl_shader_compile_attach_stage" version="1.8" throws="1">
        <doc xml:space="preserve">Compiles @stage and attaches it to @shader.

Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @stage could be compiled and attached to @shader</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLStage to attach</doc>
            <type name="GLSLStage" c:type="GstGLSLStage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="detach" c:identifier="gst_gl_shader_detach" version="1.8">
        <doc xml:space="preserve">Detaches @stage from @shader.  @stage must have been successfully attached
to @shader with gst_gl_shader_attach() or gst_gl_shader_attach_unlocked().

Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLStage to attach</doc>
            <type name="GLSLStage" c:type="GstGLSLStage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="detach_unlocked" c:identifier="gst_gl_shader_detach_unlocked" version="1.8">
        <doc xml:space="preserve">Detaches @stage from @shader.  @stage must have been successfully attached
to @shader with gst_gl_shader_attach() or gst_gl_shader_attach_unlocked().

Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="stage" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSLStage to attach</doc>
            <type name="GLSLStage" c:type="GstGLSLStage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_location" c:identifier="gst_gl_shader_get_attribute_location">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the attribute index for @name in @shader or -1 on failure</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the attribute</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_program_handle" c:identifier="gst_gl_shader_get_program_handle" version="1.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the GL program handle for this shader</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_linked" c:identifier="gst_gl_shader_is_linked" version="1.8">
        <doc xml:space="preserve">Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @shader has been successfully linked</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="link" c:identifier="gst_gl_shader_link" version="1.8" throws="1">
        <doc xml:space="preserve">Links the current list of #GstGLSLStage's in @shader.

Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @shader could be linked together.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="release" c:identifier="gst_gl_shader_release" version="1.8">
        <doc xml:space="preserve">Releases the shader and stages.

Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="release_unlocked" c:identifier="gst_gl_shader_release_unlocked" version="1.8">
        <doc xml:space="preserve">Releases the shader and stages.

Note: must be called in the GL thread</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_uniform_1f" c:identifier="gst_gl_shader_set_uniform_1f">
        <doc xml:space="preserve">Perform `glUniform1f()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1fv" c:identifier="gst_gl_shader_set_uniform_1fv">
        <doc xml:space="preserve">Perform `glUniform1fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of values to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <array length="1" zero-terminated="0" c:type="const gfloat*">
              <type name="gfloat" c:type="gfloat"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1i" c:identifier="gst_gl_shader_set_uniform_1i">
        <doc xml:space="preserve">Perform `glUniform1i()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1iv" c:identifier="gst_gl_shader_set_uniform_1iv">
        <doc xml:space="preserve">Perform `glUniform1iv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of values to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <array length="1" zero-terminated="0" c:type="const gint*">
              <type name="gint" c:type="gint"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_2f" c:identifier="gst_gl_shader_set_uniform_2f">
        <doc xml:space="preserve">Perform `glUniform2f()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="v0" transfer-ownership="none">
            <doc xml:space="preserve">first value to set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">second value to set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_2fv" c:identifier="gst_gl_shader_set_uniform_2fv">
        <doc xml:space="preserve">Perform `glUniform2fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of values to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <array length="1" zero-terminated="0" c:type="const gfloat*">
              <type name="gfloat" c:type="gfloat"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_2i" c:identifier="gst_gl_shader_set_uniform_2i">
        <doc xml:space="preserve">Perform `glUniform2i()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="v0" transfer-ownership="none">
            <doc xml:space="preserve">first value to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">second value to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_2iv" c:identifier="gst_gl_shader_set_uniform_2iv">
        <doc xml:space="preserve">Perform `glUniform2iv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of values to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <array length="1" zero-terminated="0" c:type="const gint*">
              <type name="gint" c:type="gint"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_3f" c:identifier="gst_gl_shader_set_uniform_3f">
        <doc xml:space="preserve">Perform `glUniform3f()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="v0" transfer-ownership="none">
            <doc xml:space="preserve">first value to set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">second value to set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">third value to set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_3fv" c:identifier="gst_gl_shader_set_uniform_3fv">
        <doc xml:space="preserve">Perform `glUniform3fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of values to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <array length="1" zero-terminated="0" c:type="const gfloat*">
              <type name="gfloat" c:type="gfloat"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_3i" c:identifier="gst_gl_shader_set_uniform_3i">
        <doc xml:space="preserve">Perform `glUniform3i()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="v0" transfer-ownership="none">
            <doc xml:space="preserve">first value to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">second value to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">third value to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_3iv" c:identifier="gst_gl_shader_set_uniform_3iv">
        <doc xml:space="preserve">Perform `glUniform3iv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of values to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <array length="1" zero-terminated="0" c:type="const gint*">
              <type name="gint" c:type="gint"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_4f" c:identifier="gst_gl_shader_set_uniform_4f">
        <doc xml:space="preserve">Perform `glUniform4f()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="v0" transfer-ownership="none">
            <doc xml:space="preserve">first value to set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">second value to set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">third value to set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="v3" transfer-ownership="none">
            <doc xml:space="preserve">fourth value to set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_4fv" c:identifier="gst_gl_shader_set_uniform_4fv">
        <doc xml:space="preserve">Perform `glUniform4fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of values to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <array length="1" zero-terminated="0" c:type="const gfloat*">
              <type name="gfloat" c:type="gfloat"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_4i" c:identifier="gst_gl_shader_set_uniform_4i">
        <doc xml:space="preserve">Perform `glUniform4i()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="v0" transfer-ownership="none">
            <doc xml:space="preserve">first value to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">second value to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">third value to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="v3" transfer-ownership="none">
            <doc xml:space="preserve">fourth value to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_4iv" c:identifier="gst_gl_shader_set_uniform_4iv">
        <doc xml:space="preserve">Perform `glUniform4iv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of values to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <array length="1" zero-terminated="0" c:type="const gint*">
              <type name="gint" c:type="gint"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix_2fv" c:identifier="gst_gl_shader_set_uniform_matrix_2fv">
        <doc xml:space="preserve">Perform `glUniformMatrix2fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of 2x2 matrices to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve">transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">matrix to set</doc>
            <type name="gfloat" c:type="const gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix_2x3fv" c:identifier="gst_gl_shader_set_uniform_matrix_2x3fv">
        <doc xml:space="preserve">Perform `glUniformMatrix2x3fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of 2x3 matrices to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve">transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <type name="gfloat" c:type="const gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix_2x4fv" c:identifier="gst_gl_shader_set_uniform_matrix_2x4fv">
        <doc xml:space="preserve">Perform `glUniformMatrix2x4fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of 2x4 matrices to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve">transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <type name="gfloat" c:type="const gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix_3fv" c:identifier="gst_gl_shader_set_uniform_matrix_3fv">
        <doc xml:space="preserve">Perform `glUniformMatrix3fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of 3x3 matrices to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve">transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <type name="gfloat" c:type="const gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix_3x2fv" c:identifier="gst_gl_shader_set_uniform_matrix_3x2fv">
        <doc xml:space="preserve">Perform `glUniformMatrix3x2fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of 3x2 matrices to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve">transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <type name="gfloat" c:type="const gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix_3x4fv" c:identifier="gst_gl_shader_set_uniform_matrix_3x4fv">
        <doc xml:space="preserve">Perform `glUniformMatrix3x4fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of 3x4 matrices to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve">transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <type name="gfloat" c:type="const gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix_4fv" c:identifier="gst_gl_shader_set_uniform_matrix_4fv">
        <doc xml:space="preserve">Perform `glUniformMatrix4fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of 4x4 matrices to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve">transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <type name="gfloat" c:type="const gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix_4x2fv" c:identifier="gst_gl_shader_set_uniform_matrix_4x2fv">
        <doc xml:space="preserve">Perform `glUniformMatrix4x2fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of 4x2 matrices to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve">transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <type name="gfloat" c:type="const gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix_4x3fv" c:identifier="gst_gl_shader_set_uniform_matrix_4x3fv">
        <doc xml:space="preserve">Perform `glUniformMatrix4x3fv()` for @name on @shader</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the uniform</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of 4x3 matrices to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve">transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">values to set</doc>
            <type name="gfloat" c:type="const gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="use" c:identifier="gst_gl_shader_use">
        <doc xml:space="preserve">Mark's @shader as being used for the next GL draw command.

Note: must be called in the GL thread and @shader must have been linked.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLShader</doc>
            <type name="GLShader" c:type="GstGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="linked" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="context">
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLShaderPrivate" c:type="GstGLShaderPrivate*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLShaderClass" c:type="GstGLShaderClass" glib:is-gtype-struct-for="GLShader">
      <field name="parent_class" readable="0" private="1">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
    </record>
    <record name="GLShaderPrivate" c:type="GstGLShaderPrivate" disguised="1"/>
    <enumeration name="GLStereoDownmix" glib:type-name="GstGLStereoDownmix" glib:get-type="gst_gl_stereo_downmix_get_type" c:type="GstGLStereoDownmix">
      <doc xml:space="preserve">Output anaglyph type to generate when downmixing to mono</doc>
      <member name="green_magenta_dubois" value="0" c:identifier="GST_GL_STEREO_DOWNMIX_ANAGLYPH_GREEN_MAGENTA_DUBOIS" glib:nick="green-magenta-dubois">
        <doc xml:space="preserve">Dubois optimised Green-Magenta anaglyph</doc>
      </member>
      <member name="red_cyan_dubois" value="1" c:identifier="GST_GL_STEREO_DOWNMIX_ANAGLYPH_RED_CYAN_DUBOIS" glib:nick="red-cyan-dubois">
        <doc xml:space="preserve">Dubois optimised Red-Cyan anaglyph</doc>
      </member>
      <member name="amber_blue_dubois" value="2" c:identifier="GST_GL_STEREO_DOWNMIX_ANAGLYPH_AMBER_BLUE_DUBOIS" glib:nick="amber-blue-dubois">
        <doc xml:space="preserve">Dubois optimised Amber-Blue anaglyph</doc>
      </member>
    </enumeration>
    <record name="GLSyncMeta" c:type="GstGLSyncMeta">
      <doc xml:space="preserve">#GstGLSyncMeta provides the ability to synchronize the OpenGL command stream
with the CPU or with other OpenGL contexts.</doc>
      <field name="parent" writable="1">
        <doc xml:space="preserve">the parent #GstMeta</doc>
        <type name="Gst.Meta" c:type="GstMeta"/>
      </field>
      <field name="context" writable="1">
        <doc xml:space="preserve">the #GstGLContext used to allocate the meta</doc>
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="data" writable="1">
        <doc xml:space="preserve">a custom data pointer for the implementation</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="set_sync">
        <callback name="set_sync">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sync" transfer-ownership="none">
              <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
            </parameter>
            <parameter name="context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_sync_gl">
        <callback name="set_sync_gl">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sync" transfer-ownership="none">
              <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
            </parameter>
            <parameter name="context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wait">
        <callback name="wait">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sync" transfer-ownership="none">
              <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
            </parameter>
            <parameter name="context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wait_gl">
        <callback name="wait_gl">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sync" transfer-ownership="none">
              <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
            </parameter>
            <parameter name="context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wait_cpu">
        <callback name="wait_cpu">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sync" transfer-ownership="none">
              <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
            </parameter>
            <parameter name="context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wait_cpu_gl">
        <callback name="wait_cpu_gl">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sync" transfer-ownership="none">
              <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
            </parameter>
            <parameter name="context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="copy">
        <callback name="copy">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
            </parameter>
            <parameter name="sbuffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="dest" transfer-ownership="none">
              <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
            </parameter>
            <parameter name="dbuffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="free">
        <callback name="free">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sync" transfer-ownership="none">
              <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
            </parameter>
            <parameter name="context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="free_gl">
        <callback name="free_gl">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sync" transfer-ownership="none">
              <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
            </parameter>
            <parameter name="context" transfer-ownership="none">
              <type name="GLContext" c:type="GstGLContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <method name="set_sync_point" c:identifier="gst_gl_sync_meta_set_sync_point" version="1.6">
        <doc xml:space="preserve">Set a sync point to possibly wait on at a later time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sync_meta" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSyncMeta</doc>
            <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait" c:identifier="gst_gl_sync_meta_wait" version="1.6">
        <doc xml:space="preserve">Insert a wait into @context's command stream ensuring all previous OpenGL
commands before @sync_meta have completed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sync_meta" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSyncMeta</doc>
            <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_cpu" c:identifier="gst_gl_sync_meta_wait_cpu" version="1.8">
        <doc xml:space="preserve">Perform a wait so that the sync point has passed from the CPU's perspective
What that means, is that all GL operations changing CPU-visible data before
the sync point are now visible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sync_meta" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLSyncMeta</doc>
            <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </method>
      <function name="get_info" c:identifier="gst_gl_sync_meta_get_info">
        <return-value transfer-ownership="none">
          <type name="Gst.MetaInfo" c:type="const GstMetaInfo*"/>
        </return-value>
      </function>
    </record>
    <enumeration name="GLTextureTarget" version="1.8" glib:type-name="GstGLTextureTarget" glib:get-type="gst_gl_texture_target_get_type" c:type="GstGLTextureTarget">
      <member name="none" value="0" c:identifier="GST_GL_TEXTURE_TARGET_NONE" glib:nick="none">
        <doc xml:space="preserve">no texture target</doc>
      </member>
      <member name="2d" value="1" c:identifier="GST_GL_TEXTURE_TARGET_2D" glib:nick="2d">
        <doc xml:space="preserve">2D texture target</doc>
      </member>
      <member name="rectangle" value="2" c:identifier="GST_GL_TEXTURE_TARGET_RECTANGLE" glib:nick="rectangle">
        <doc xml:space="preserve">rectangle texture target</doc>
      </member>
      <member name="external_oes" value="3" c:identifier="GST_GL_TEXTURE_TARGET_EXTERNAL_OES" glib:nick="external-oes">
        <doc xml:space="preserve">external oes texture target</doc>
      </member>
      <function name="from_gl" c:identifier="gst_gl_texture_target_from_gl">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLTextureTarget that's equiavalant to @target or
         %GST_GL_TEXTURE_TARGET_NONE</doc>
          <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
        </return-value>
        <parameters>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">an OpenGL texture binding target</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="from_string" c:identifier="gst_gl_texture_target_from_string">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLTextureTarget represented by @str or
         %GST_GL_TEXTURE_TARGET_NONE</doc>
          <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
        </return-value>
        <parameters>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">a string equivalent to one of the GST_GL_TEXTURE_TARGET_*_STR values</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_buffer_pool_option" c:identifier="gst_gl_texture_target_to_buffer_pool_option">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string representing the @GstBufferPoolOption specified by @target</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLTextureTarget</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_gl" c:identifier="gst_gl_texture_target_to_gl">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the OpenGL value for binding the @target with glBindTexture() and
         similar functions or 0</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLTextureTarget</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_string" c:identifier="gst_gl_texture_target_to_string">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the stringified version of @target or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLTextureTarget</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <class name="GLUpload" c:symbol-prefix="gl_upload" c:type="GstGLUpload" parent="Gst.Object" glib:type-name="GstGLUpload" glib:get-type="gst_gl_upload_get_type" glib:type-struct="GLUploadClass">
      <doc xml:space="preserve">#GstGLUpload is an object that uploads data from system memory into GL textures.

A #GstGLUpload can be created with gst_gl_upload_new()</doc>
      <constructor name="new" c:identifier="gst_gl_upload_new">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLUpload object</doc>
          <type name="GLUpload" c:type="GstGLUpload*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_input_template_caps" c:identifier="gst_gl_upload_get_input_template_caps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
      </function>
      <method name="get_caps" c:identifier="gst_gl_upload_get_caps">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="upload" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLUpload</doc>
            <type name="GLUpload" c:type="GstGLUpload*"/>
          </instance-parameter>
          <parameter name="in_caps" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the input #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps**"/>
          </parameter>
          <parameter name="out_caps" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the output #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps**"/>
          </parameter>
        </parameters>
      </method>
      <method name="perform_with_buffer" c:identifier="gst_gl_upload_perform_with_buffer">
        <doc xml:space="preserve">Uploads @buffer using the transformation specified by
gst_gl_upload_set_caps() creating a new #GstBuffer in @outbuf_ptr.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the upload was successful</doc>
          <type name="GLUploadReturn" c:type="GstGLUploadReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="upload" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLUpload</doc>
            <type name="GLUpload" c:type="GstGLUpload*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">input #GstBuffer</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="outbuf_ptr" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">resulting #GstBuffer</doc>
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </method>
      <method name="propose_allocation" c:identifier="gst_gl_upload_propose_allocation">
        <doc xml:space="preserve">Adds the required allocation parameters to support uploading.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="upload" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLUpload</doc>
            <type name="GLUpload" c:type="GstGLUpload*"/>
          </instance-parameter>
          <parameter name="decide_query" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GstQuery from a decide allocation</doc>
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
          <parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">the proposed allocation query</doc>
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_caps" c:identifier="gst_gl_upload_set_caps">
        <doc xml:space="preserve">Initializes @upload with the information required for upload.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @in_caps and @out_caps could be set on @upload</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="upload" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLUpload</doc>
            <type name="GLUpload" c:type="GstGLUpload*"/>
          </instance-parameter>
          <parameter name="in_caps" transfer-ownership="none">
            <doc xml:space="preserve">input #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="out_caps" transfer-ownership="none">
            <doc xml:space="preserve">output #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_context" c:identifier="gst_gl_upload_set_context">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="upload" transfer-ownership="none">
            <type name="GLUpload" c:type="GstGLUpload*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_caps" c:identifier="gst_gl_upload_transform_caps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="upload" transfer-ownership="none">
            <type name="GLUpload" c:type="GstGLUpload*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="context">
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLUploadPrivate" c:type="GstGLUploadPrivate*"/>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLUploadClass" c:type="GstGLUploadClass" glib:is-gtype-struct-for="GLUpload">
      <doc xml:space="preserve">The #GstGLUploadClass struct only contains private data</doc>
      <field name="object_class">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GLUploadPrivate" c:type="GstGLUploadPrivate" disguised="1"/>
    <enumeration name="GLUploadReturn" glib:type-name="GstGLUploadReturn" glib:get-type="gst_gl_upload_return_get_type" c:type="GstGLUploadReturn">
      <member name="done" value="1" c:identifier="GST_GL_UPLOAD_DONE" glib:nick="done">
        <doc xml:space="preserve">No further processing required</doc>
      </member>
      <member name="error" value="-1" c:identifier="GST_GL_UPLOAD_ERROR" glib:nick="error">
        <doc xml:space="preserve">An unspecified error occurred</doc>
      </member>
      <member name="unsupported" value="-2" c:identifier="GST_GL_UPLOAD_UNSUPPORTED" glib:nick="unsupported">
        <doc xml:space="preserve">The configuration is unsupported.</doc>
      </member>
      <member name="reconfigure" value="-3" c:identifier="GST_GL_UPLOAD_RECONFIGURE" glib:nick="reconfigure">
        <doc xml:space="preserve">This element requires a reconfiguration.</doc>
      </member>
      <member name="unshared_gl_context" value="-100" c:identifier="GST_GL_UPLOAD_UNSHARED_GL_CONTEXT" glib:nick="unshared-gl-context">
        <doc xml:space="preserve">private return value.</doc>
      </member>
    </enumeration>
    <record name="GLVideoAllocationParams" c:type="GstGLVideoAllocationParams" glib:type-name="GstGLVideoAllocationParams" glib:get-type="gst_gl_video_allocation_params_get_type" c:symbol-prefix="gl_video_allocation_params">
      <field name="parent" writable="1">
        <doc xml:space="preserve">the parent #GstGLAllocationParams structure</doc>
        <type name="GLAllocationParams" c:type="GstGLAllocationParams"/>
      </field>
      <field name="v_info" writable="1">
        <doc xml:space="preserve">the #GstVideoInfo to allocate</doc>
        <type name="GstVideo.VideoInfo" c:type="GstVideoInfo*"/>
      </field>
      <field name="plane" writable="1">
        <doc xml:space="preserve">the video plane index to allocate</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="valign" writable="1">
        <doc xml:space="preserve">the #GstVideoAlignment to align the system representation to (may be %NULL for the default)</doc>
        <type name="GstVideo.VideoAlignment" c:type="GstVideoAlignment*"/>
      </field>
      <field name="target" writable="1">
        <doc xml:space="preserve">the #GstGLTextureTarget to allocate</doc>
        <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
      </field>
      <field name="tex_format" writable="1">
        <doc xml:space="preserve">the #GstGLFormat to allocate</doc>
        <type name="GLFormat" c:type="GstGLFormat"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <constructor name="new" c:identifier="gst_gl_video_allocation_params_new" version="1.8">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLVideoAllocationParams for allocating #GstGLMemory's</doc>
          <type name="GLVideoAllocationParams" c:type="GstGLVideoAllocationParams*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="alloc_params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GstAllocationParams for sysmem mappings of the texture</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
          <parameter name="v_info" transfer-ownership="none">
            <doc xml:space="preserve">the #GstVideoInfo for the texture</doc>
            <type name="GstVideo.VideoInfo" c:type="GstVideoInfo*"/>
          </parameter>
          <parameter name="plane" transfer-ownership="none">
            <doc xml:space="preserve">the video plane of @v_info to allocate</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="valign" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">any #GstVideoAlignment applied to symem mappings of the texture</doc>
            <type name="GstVideo.VideoAlignment" c:type="GstVideoAlignment*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLTextureTarget for the created textures</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
          <parameter name="tex_format" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLFormat for the created textures</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_wrapped_data" c:identifier="gst_gl_video_allocation_params_new_wrapped_data" version="1.8">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLVideoAllocationParams for wrapping @wrapped_data</doc>
          <type name="GLVideoAllocationParams" c:type="GstGLVideoAllocationParams*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="alloc_params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GstAllocationParams for @wrapped_data</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
          <parameter name="v_info" transfer-ownership="none">
            <doc xml:space="preserve">the #GstVideoInfo for @wrapped_data</doc>
            <type name="GstVideo.VideoInfo" c:type="GstVideoInfo*"/>
          </parameter>
          <parameter name="plane" transfer-ownership="none">
            <doc xml:space="preserve">the video plane @wrapped_data represents</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="valign" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">any #GstVideoAlignment applied to symem mappings of @wrapped_data</doc>
            <type name="GstVideo.VideoAlignment" c:type="GstVideoAlignment*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLTextureTarget for @wrapped_data</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
          <parameter name="tex_format" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLFormat for @wrapped_data</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
          <parameter name="wrapped_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data pointer to wrap</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to call @notify with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_wrapped_gl_handle" c:identifier="gst_gl_video_allocation_params_new_wrapped_gl_handle" version="1.8">
        <doc xml:space="preserve">@gl_handle is defined by the specific OpenGL handle being wrapped
For #GstGLMemory and #GstGLMemoryPBO it is an OpenGL texture id.
Other memory types may define it to require a different type of parameter.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLVideoAllocationParams for wrapping @gl_handle</doc>
          <type name="GLVideoAllocationParams" c:type="GstGLVideoAllocationParams*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="alloc_params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GstAllocationParams for @tex_id</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
          <parameter name="v_info" transfer-ownership="none">
            <doc xml:space="preserve">the #GstVideoInfo for @tex_id</doc>
            <type name="GstVideo.VideoInfo" c:type="GstVideoInfo*"/>
          </parameter>
          <parameter name="plane" transfer-ownership="none">
            <doc xml:space="preserve">the video plane @tex_id represents</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="valign" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">any #GstVideoAlignment applied to symem mappings of @tex_id</doc>
            <type name="GstVideo.VideoAlignment" c:type="GstVideoAlignment*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLTextureTarget for @tex_id</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
          <parameter name="tex_format" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLFormat for @tex_id</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
          <parameter name="gl_handle" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the GL handle to wrap</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to call @notify with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_wrapped_texture" c:identifier="gst_gl_video_allocation_params_new_wrapped_texture" version="1.8">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLVideoAllocationParams for wrapping @tex_id</doc>
          <type name="GLVideoAllocationParams" c:type="GstGLVideoAllocationParams*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="alloc_params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GstAllocationParams for @tex_id</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
          <parameter name="v_info" transfer-ownership="none">
            <doc xml:space="preserve">the #GstVideoInfo for @tex_id</doc>
            <type name="GstVideo.VideoInfo" c:type="GstVideoInfo*"/>
          </parameter>
          <parameter name="plane" transfer-ownership="none">
            <doc xml:space="preserve">the video plane @tex_id represents</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="valign" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">any #GstVideoAlignment applied to symem mappings of @tex_id</doc>
            <type name="GstVideo.VideoAlignment" c:type="GstVideoAlignment*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLTextureTarget for @tex_id</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
          <parameter name="tex_format" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLFormat for @tex_id</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
          <parameter name="tex_id" transfer-ownership="none">
            <doc xml:space="preserve">the GL texture to wrap</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to call @notify with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy_data" c:identifier="gst_gl_video_allocation_params_copy_data" version="1.8">
        <doc xml:space="preserve">Copy and set any dynamically allocated resources in @dest_vid.  Intended
for subclass usage only to chain up at the end of a subclass copy function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src_vid" transfer-ownership="none">
            <doc xml:space="preserve">source #GstGLVideoAllocationParams to copy from</doc>
            <type name="GLVideoAllocationParams" c:type="GstGLVideoAllocationParams*"/>
          </instance-parameter>
          <parameter name="dest_vid" transfer-ownership="none">
            <doc xml:space="preserve">destination #GstGLVideoAllocationParams to copy into</doc>
            <type name="GLVideoAllocationParams" c:type="GstGLVideoAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free_data" c:identifier="gst_gl_video_allocation_params_free_data" version="1.8">
        <doc xml:space="preserve">Unset and free any dynamically allocated resources.  Intended for subclass
usage only to chain up at the end of a subclass free function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLVideoAllocationParams</doc>
            <type name="GLVideoAllocationParams" c:type="GstGLVideoAllocationParams*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_full" c:identifier="gst_gl_video_allocation_params_init_full" version="1.8" introspectable="0">
        <doc xml:space="preserve">Intended for subclass usage</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">initializes @params with the parameters specified</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLVideoAllocationParams to initialize</doc>
            <type name="GLVideoAllocationParams" c:type="GstGLVideoAllocationParams*"/>
          </instance-parameter>
          <parameter name="struct_size" transfer-ownership="none">
            <doc xml:space="preserve">the size of the struct in @params</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="alloc_flags" transfer-ownership="none">
            <doc xml:space="preserve">some allocation flags</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="copy" transfer-ownership="none">
            <doc xml:space="preserve">a copy function</doc>
            <type name="GLAllocationParamsCopyFunc" c:type="GstGLAllocationParamsCopyFunc"/>
          </parameter>
          <parameter name="free" transfer-ownership="none" scope="notified" closure="13" destroy="14">
            <doc xml:space="preserve">a free function</doc>
            <type name="GLAllocationParamsFreeFunc" c:type="GstGLAllocationParamsFreeFunc"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLContext</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
          <parameter name="alloc_params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GstAllocationParams for @wrapped_data</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
          <parameter name="v_info" transfer-ownership="none">
            <doc xml:space="preserve">the #GstVideoInfo for @wrapped_data</doc>
            <type name="GstVideo.VideoInfo" c:type="GstVideoInfo*"/>
          </parameter>
          <parameter name="plane" transfer-ownership="none">
            <doc xml:space="preserve">the video plane @wrapped_data represents</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="valign" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">any #GstVideoAlignment applied to symem mappings of @wrapped_data</doc>
            <type name="GstVideo.VideoAlignment" c:type="GstVideoAlignment*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLTextureTarget</doc>
            <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
          </parameter>
          <parameter name="tex_format" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLFormat</doc>
            <type name="GLFormat" c:type="GstGLFormat"/>
          </parameter>
          <parameter name="wrapped_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the optional data pointer to wrap</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="gl_handle" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the optional OpenGL handle to wrap or 0</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to call @notify with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="GLViewConvert" c:symbol-prefix="gl_view_convert" c:type="GstGLViewConvert" parent="Gst.Object" glib:type-name="GstGLViewConvert" glib:get-type="gst_gl_view_convert_get_type" glib:type-struct="GLViewConvertClass">
      <doc xml:space="preserve">Convert stereoscopic/multiview video using fragment shaders.</doc>
      <constructor name="new" c:identifier="gst_gl_view_convert_new" version="1.6">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLViewConvert</doc>
          <type name="GLViewConvert" c:type="GstGLViewConvert*"/>
        </return-value>
      </constructor>
      <method name="fixate_caps" c:identifier="gst_gl_view_convert_fixate_caps" version="1.6">
        <doc xml:space="preserve">Provides an implementation of #GstBaseTransformClass.fixate_caps()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the fixated #GstCaps</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="viewconvert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLViewConvert</doc>
            <type name="GLViewConvert" c:type="GstGLViewConvert*"/>
          </instance-parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">a #GstPadDirection</doc>
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve">the #GstCaps of @direction</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="othercaps" transfer-ownership="full">
            <doc xml:space="preserve">the #GstCaps to fixate</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_output" c:identifier="gst_gl_view_convert_get_output" version="1.6">
        <doc xml:space="preserve">Retrieve the processed output buffer placing the output in @outbuf_ptr.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GstFlowReturn</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="viewconvert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLViewConvert</doc>
            <type name="GLViewConvert" c:type="GstGLViewConvert*"/>
          </instance-parameter>
          <parameter name="outbuf_ptr" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a #GstBuffer</doc>
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </method>
      <method name="perform" c:identifier="gst_gl_view_convert_perform" version="1.6">
        <doc xml:space="preserve">Converts the data contained by @inbuf using the formats specified by the
#GstCaps passed to gst_gl_view_convert_set_caps()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a converted #GstBuffer or %NULL</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="viewconvert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLViewConvert</doc>
            <type name="GLViewConvert" c:type="GstGLViewConvert*"/>
          </instance-parameter>
          <parameter name="inbuf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLMemory filled #GstBuffer to convert</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="gst_gl_view_convert_reset" version="1.6">
        <doc xml:space="preserve">Reset @viewconvert to the default state.  Further operation will require
setting the caps with gst_gl_view_convert_set_caps().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="viewconvert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLViewConvert</doc>
            <type name="GLViewConvert" c:type="GstGLViewConvert*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_caps" c:identifier="gst_gl_view_convert_set_caps" version="1.6">
        <doc xml:space="preserve">Initializes @viewconvert with the information required for conversion.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="viewconvert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLViewConvert</doc>
            <type name="GLViewConvert" c:type="GstGLViewConvert*"/>
          </instance-parameter>
          <parameter name="in_caps" transfer-ownership="none">
            <doc xml:space="preserve">input #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="out_caps" transfer-ownership="none">
            <doc xml:space="preserve">output #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_context" c:identifier="gst_gl_view_convert_set_context" version="1.6">
        <doc xml:space="preserve">Set @context on @viewconvert</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="viewconvert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLViewConvert</doc>
            <type name="GLViewConvert" c:type="GstGLViewConvert*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">the #GstGLContext to set</doc>
            <type name="GLContext" c:type="GstGLContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="submit_input_buffer" c:identifier="gst_gl_view_convert_submit_input_buffer" version="1.6">
        <doc xml:space="preserve">Submit @input to be processed by @viewconvert</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GstFlowReturn</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="viewconvert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLViewConvert</doc>
            <type name="GLViewConvert" c:type="GstGLViewConvert*"/>
          </instance-parameter>
          <parameter name="is_discont" transfer-ownership="none">
            <doc xml:space="preserve">true if we have a discontinuity</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="input" transfer-ownership="full">
            <doc xml:space="preserve">a #GstBuffer</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_caps" c:identifier="gst_gl_view_convert_transform_caps" version="1.6">
        <doc xml:space="preserve">Provides an implementation of #GstBaseTransformClass.transform_caps()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the converted #GstCaps</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="viewconvert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLViewConvert</doc>
            <type name="GLViewConvert" c:type="GstGLViewConvert*"/>
          </instance-parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">a #GstPadDirection</doc>
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve">the #GstCaps to transform</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a set of filter #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <property name="downmix-mode" writable="1" transfer-ownership="none">
        <type name="GLStereoDownmix"/>
      </property>
      <property name="input-flags-override" writable="1" transfer-ownership="none">
        <type name="GstVideo.VideoMultiviewFlags"/>
      </property>
      <property name="input-mode-override" writable="1" transfer-ownership="none">
        <type name="GstVideo.VideoMultiviewMode"/>
      </property>
      <property name="output-flags-override" writable="1" transfer-ownership="none">
        <type name="GstVideo.VideoMultiviewFlags"/>
      </property>
      <property name="output-mode-override" writable="1" transfer-ownership="none">
        <type name="GstVideo.VideoMultiviewMode"/>
      </property>
      <field name="object">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="context">
        <type name="GLContext" c:type="GstGLContext*"/>
      </field>
      <field name="shader">
        <type name="GLShader" c:type="GstGLShader*"/>
      </field>
      <field name="input_mode_override">
        <type name="GstVideo.VideoMultiviewMode" c:type="GstVideoMultiviewMode"/>
      </field>
      <field name="input_flags_override">
        <type name="GstVideo.VideoMultiviewFlags" c:type="GstVideoMultiviewFlags"/>
      </field>
      <field name="output_mode_override">
        <type name="GstVideo.VideoMultiviewMode" c:type="GstVideoMultiviewMode"/>
      </field>
      <field name="output_flags_override">
        <type name="GstVideo.VideoMultiviewFlags" c:type="GstVideoMultiviewFlags"/>
      </field>
      <field name="downmix_mode">
        <type name="GLStereoDownmix" c:type="GstGLStereoDownmix"/>
      </field>
      <field name="in_info">
        <type name="GstVideo.VideoInfo" c:type="GstVideoInfo"/>
      </field>
      <field name="out_info">
        <type name="GstVideo.VideoInfo" c:type="GstVideoInfo"/>
      </field>
      <field name="from_texture_target">
        <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
      </field>
      <field name="to_texture_target">
        <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
      </field>
      <field name="caps_passthrough">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="initted">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="reconfigure">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="fbo">
        <type name="GLFramebuffer" c:type="GstGLFramebuffer*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLViewConvertPrivate" c:type="GstGLViewConvertPrivate*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="GLViewConvertClass" c:type="GstGLViewConvertClass" glib:is-gtype-struct-for="GLViewConvert">
      <doc xml:space="preserve">Opaque #GstGLViewConvertClass struct</doc>
      <field name="object_class" readable="0" private="1">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GLViewConvertPrivate" c:type="GstGLViewConvertPrivate" disguised="1"/>
    <class name="GLWindow" c:symbol-prefix="gl_window" c:type="GstGLWindow" parent="Gst.Object" abstract="1" glib:type-name="GstGLWindow" glib:get-type="gst_gl_window_get_type" glib:type-struct="GLWindowClass">
      <doc xml:space="preserve">GstGLWindow represents a window that elements can render into.  A window can
either be a user visible window (onscreen) or hidden (offscreen).</doc>
      <constructor name="new" c:identifier="gst_gl_window_new" version="1.4">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstGLWindow using @display's connection</doc>
          <type name="GLWindow" c:type="GstGLWindow*"/>
        </return-value>
        <parameters>
          <parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLDisplay</doc>
            <type name="GLDisplay" c:type="GstGLDisplay*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="controls_viewport" invoker="controls_viewport" version="1.16">
        <doc xml:space="preserve">Checks if @window controls the GL viewport.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @window controls the GL viewport, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="draw" invoker="draw" version="1.4">
        <doc xml:space="preserve">Redraw the window contents.  Implementations should invoke the draw callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_display" invoker="get_display" version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the windowing system display handle for this @window</doc>
          <type name="guintptr" c:type="guintptr"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_window_handle" invoker="get_window_handle" version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the window handle we are currently rendering into</doc>
          <type name="guintptr" c:type="guintptr"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_events" invoker="handle_events">
        <doc xml:space="preserve">Tell a @window that it should handle events from the window system. These
events are forwarded upstream as navigation events. In some window systems
events are not propagated in the window hierarchy if a client is listening
for them. This method allows you to disable events handling completely
from the @window.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="handle_events" transfer-ownership="none">
            <doc xml:space="preserve">a #gboolean indicating if events should be handled or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_output_surface" invoker="has_output_surface" version="1.18">
        <doc xml:space="preserve">Query whether @window has output surface or not</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @window has useable output surface</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="queue_resize" invoker="queue_resize">
        <doc xml:space="preserve">Queue resizing of @window.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="quit" invoker="quit" version="1.4">
        <doc xml:space="preserve">Quit the runloop's execution.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="run" invoker="run" version="1.4">
        <doc xml:space="preserve">Start the execution of the runloop.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send_message" invoker="send_message" version="1.4">
        <doc xml:space="preserve">Invoke @callback with data on the window thread.  @callback is guaranteed to
have executed when this function returns.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="1">
            <doc xml:space="preserve">function to invoke</doc>
            <type name="GLWindowCB" c:type="GstGLWindowCB"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to invoke @callback with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send_message_async" invoker="send_message_async" version="1.4">
        <doc xml:space="preserve">Invoke @callback with @data on the window thread.  The callback may not
have been executed when this function returns.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">function to invoke</doc>
            <type name="GLWindowCB" c:type="GstGLWindowCB"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to invoke @callback with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called when @data is not needed anymore</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_preferred_size" invoker="set_preferred_size" version="1.6">
        <doc xml:space="preserve">Set the preferred width and height of the window.  Implementations are free
to ignore this information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">new preferred width</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">new preferred height</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_render_rectangle" invoker="set_render_rectangle">
        <doc xml:space="preserve">Tell a @window that it should render into a specific region of the window
according to the #GstVideoOverlay interface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the specified region could be set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x position</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y position</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">width</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">height</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_window_handle" invoker="set_window_handle" version="1.4">
        <doc xml:space="preserve">Sets the window that this @window should render into.  Some implementations
require this to be called with a valid handle before drawing can commence.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">handle to the window</doc>
            <type name="guintptr" c:type="guintptr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="show" invoker="show" version="1.6">
        <doc xml:space="preserve">Present the window to the screen.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="controls_viewport" c:identifier="gst_gl_window_controls_viewport" version="1.16">
        <doc xml:space="preserve">Checks if @window controls the GL viewport.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @window controls the GL viewport, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="draw" c:identifier="gst_gl_window_draw" version="1.4">
        <doc xml:space="preserve">Redraw the window contents.  Implementations should invoke the draw callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_context" c:identifier="gst_gl_window_get_context" version="1.4">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GstGLContext associated with this @window</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_display" c:identifier="gst_gl_window_get_display" version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the windowing system display handle for this @window</doc>
          <type name="guintptr" c:type="guintptr"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_surface_dimensions" c:identifier="gst_gl_window_get_surface_dimensions" version="1.6">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="width" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">resulting surface width</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="height" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">resulting surface height</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_window_handle" c:identifier="gst_gl_window_get_window_handle" version="1.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the window handle we are currently rendering into</doc>
          <type name="guintptr" c:type="guintptr"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="handle_events" c:identifier="gst_gl_window_handle_events">
        <doc xml:space="preserve">Tell a @window that it should handle events from the window system. These
events are forwarded upstream as navigation events. In some window systems
events are not propagated in the window hierarchy if a client is listening
for them. This method allows you to disable events handling completely
from the @window.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="handle_events" transfer-ownership="none">
            <doc xml:space="preserve">a #gboolean indicating if events should be handled or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_output_surface" c:identifier="gst_gl_window_has_output_surface" version="1.18">
        <doc xml:space="preserve">Query whether @window has output surface or not</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @window has useable output surface</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="queue_resize" c:identifier="gst_gl_window_queue_resize">
        <doc xml:space="preserve">Queue resizing of @window.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="quit" c:identifier="gst_gl_window_quit" version="1.4">
        <doc xml:space="preserve">Quit the runloop's execution.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="resize" c:identifier="gst_gl_window_resize">
        <doc xml:space="preserve">Resize @window to the given @width and @height.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">new width</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">new height</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="run" c:identifier="gst_gl_window_run" version="1.4">
        <doc xml:space="preserve">Start the execution of the runloop.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="send_key_event" c:identifier="gst_gl_window_send_key_event">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="event_type" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="key_str" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message" c:identifier="gst_gl_window_send_message" version="1.4">
        <doc xml:space="preserve">Invoke @callback with data on the window thread.  @callback is guaranteed to
have executed when this function returns.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="1">
            <doc xml:space="preserve">function to invoke</doc>
            <type name="GLWindowCB" c:type="GstGLWindowCB"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to invoke @callback with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message_async" c:identifier="gst_gl_window_send_message_async" version="1.4">
        <doc xml:space="preserve">Invoke @callback with @data on the window thread.  The callback may not
have been executed when this function returns.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">function to invoke</doc>
            <type name="GLWindowCB" c:type="GstGLWindowCB"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to invoke @callback with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called when @data is not needed anymore</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_mouse_event" c:identifier="gst_gl_window_send_mouse_event">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="event_type" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="button" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="posx" transfer-ownership="none">
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="posy" transfer-ownership="none">
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_scroll_event" c:identifier="gst_gl_window_send_scroll_event" version="1.18">
        <doc xml:space="preserve">Notify a @window about a scroll event. A scroll signal holding the event
coordinates will be emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="posx" transfer-ownership="none">
            <doc xml:space="preserve">x position of the mouse cursor</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="posy" transfer-ownership="none">
            <doc xml:space="preserve">y position of the mouse cursor</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="delta_x" transfer-ownership="none">
            <doc xml:space="preserve">the x offset of the scroll event</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="delta_y" transfer-ownership="none">
            <doc xml:space="preserve">the y offset of the scroll event</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_close_callback" c:identifier="gst_gl_window_set_close_callback" version="1.4">
        <doc xml:space="preserve">Sets the callback called when the window is about to close.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">function to invoke</doc>
            <type name="GLWindowCB" c:type="GstGLWindowCB"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to invoke @callback with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called when @data is not needed any more</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_draw_callback" c:identifier="gst_gl_window_set_draw_callback" version="1.4">
        <doc xml:space="preserve">Sets the draw callback called every time gst_gl_window_draw() is called</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">function to invoke</doc>
            <type name="GLWindowCB" c:type="GstGLWindowCB"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to invoke @callback with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called when @data is not needed any more</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_preferred_size" c:identifier="gst_gl_window_set_preferred_size" version="1.6">
        <doc xml:space="preserve">Set the preferred width and height of the window.  Implementations are free
to ignore this information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">new preferred width</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">new preferred height</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_render_rectangle" c:identifier="gst_gl_window_set_render_rectangle">
        <doc xml:space="preserve">Tell a @window that it should render into a specific region of the window
according to the #GstVideoOverlay interface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the specified region could be set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x position</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y position</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">width</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">height</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resize_callback" c:identifier="gst_gl_window_set_resize_callback" version="1.4">
        <doc xml:space="preserve">Sets the resize callback called every time a resize of the window occurs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">function to invoke</doc>
            <type name="GLWindowResizeCB" c:type="GstGLWindowResizeCB"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to invoke @callback with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called when @data is not needed any more</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_window_handle" c:identifier="gst_gl_window_set_window_handle" version="1.4">
        <doc xml:space="preserve">Sets the window that this @window should render into.  Some implementations
require this to be called with a valid handle before drawing can commence.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:space="preserve">handle to the window</doc>
            <type name="guintptr" c:type="guintptr"/>
          </parameter>
        </parameters>
      </method>
      <method name="show" c:identifier="gst_gl_window_show" version="1.6">
        <doc xml:space="preserve">Present the window to the screen.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GstGLWindow</doc>
            <type name="GLWindow" c:type="GstGLWindow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="lock" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex"/>
      </field>
      <field name="display" readable="0" private="1">
        <type name="GLDisplay" c:type="GstGLDisplay*"/>
      </field>
      <field name="context_ref" readable="0" private="1">
        <type name="GObject.WeakRef" c:type="GWeakRef"/>
      </field>
      <field name="is_drawing" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="draw" readable="0" private="1">
        <type name="GLWindowCB" c:type="GstGLWindowCB"/>
      </field>
      <field name="draw_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="draw_notify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="close" readable="0" private="1">
        <type name="GLWindowCB" c:type="GstGLWindowCB"/>
      </field>
      <field name="close_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="close_notify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="resize" readable="0" private="1">
        <type name="GLWindowResizeCB" c:type="GstGLWindowResizeCB"/>
      </field>
      <field name="resize_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="resize_notify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="queue_resize" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="main_context" readable="0" private="1">
        <type name="GLib.MainContext" c:type="GMainContext*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GLWindowPrivate" c:type="GstGLWindowPrivate*"/>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="key-event" when="last" version="1.6">
        <doc xml:space="preserve">Will be emitted when a key event is received by the GstGLwindow.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">the name of the event</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the id of the key pressed</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="mouse-event" when="last" version="1.6">
        <doc xml:space="preserve">Will be emitted when a mouse event is received by the GstGLwindow.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">the name of the event</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="button" transfer-ownership="none">
            <doc xml:space="preserve">the id of the button</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the mouse event</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the mouse event</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="scroll-event" when="last" version="1.18">
        <doc xml:space="preserve">Will be emitted when a mouse scroll event is received by the GstGLwindow.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the mouse event</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the mouse event</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="delta_x" transfer-ownership="none">
            <doc xml:space="preserve">the x offset of the scroll event</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="delta_y" transfer-ownership="none">
            <doc xml:space="preserve">the y offset of the scroll event</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="GLWindowCB" c:type="GstGLWindowCB">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="GLWindowClass" c:type="GstGLWindowClass" glib:is-gtype-struct-for="GLWindow">
      <field name="parent_class">
        <doc xml:space="preserve">Parent class</doc>
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="get_display">
        <callback name="get_display">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the windowing system display handle for this @window</doc>
            <type name="guintptr" c:type="guintptr"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_window_handle">
        <callback name="set_window_handle">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
            <parameter name="handle" transfer-ownership="none">
              <doc xml:space="preserve">handle to the window</doc>
              <type name="guintptr" c:type="guintptr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_window_handle">
        <callback name="get_window_handle">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the window handle we are currently rendering into</doc>
            <type name="guintptr" c:type="guintptr"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="draw">
        <callback name="draw">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="run">
        <callback name="run">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="quit">
        <callback name="quit">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send_message">
        <callback name="send_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" scope="async" closure="2">
              <doc xml:space="preserve">function to invoke</doc>
              <type name="GLWindowCB" c:type="GstGLWindowCB"/>
            </parameter>
            <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">data to invoke @callback with</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send_message_async">
        <callback name="send_message_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" scope="notified" closure="2" destroy="3">
              <doc xml:space="preserve">function to invoke</doc>
              <type name="GLWindowCB" c:type="GstGLWindowCB"/>
            </parameter>
            <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">data to invoke @callback with</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="destroy" transfer-ownership="none" scope="async">
              <doc xml:space="preserve">called when @data is not needed anymore</doc>
              <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open">
        <callback name="open" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_events">
        <callback name="handle_events">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
            <parameter name="handle_events" transfer-ownership="none">
              <doc xml:space="preserve">a #gboolean indicating if events should be handled or not.</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_preferred_size">
        <callback name="set_preferred_size">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <doc xml:space="preserve">new preferred width</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <doc xml:space="preserve">new preferred height</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="show">
        <callback name="show">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_render_rectangle">
        <callback name="set_render_rectangle">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether the specified region could be set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
            <parameter name="x" transfer-ownership="none">
              <doc xml:space="preserve">x position</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <doc xml:space="preserve">y position</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <doc xml:space="preserve">width</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <doc xml:space="preserve">height</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="queue_resize">
        <callback name="queue_resize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="controls_viewport">
        <callback name="controls_viewport">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @window controls the GL viewport, otherwise %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_output_surface">
        <callback name="has_output_surface">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @window has useable output surface</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="window" transfer-ownership="none">
              <doc xml:space="preserve">a #GstGLWindow</doc>
              <type name="GLWindow" c:type="GstGLWindow*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="GLWindowError" glib:type-name="GstGLWindowError" glib:get-type="gst_gl_window_error_get_type" c:type="GstGLWindowError" glib:error-domain="gst-gl-window-error-quark">
      <member name="failed" value="0" c:identifier="GST_GL_WINDOW_ERROR_FAILED" glib:nick="failed">
        <doc xml:space="preserve">failed for a unspecified reason</doc>
      </member>
      <member name="old_libs" value="1" c:identifier="GST_GL_WINDOW_ERROR_OLD_LIBS" glib:nick="old-libs">
        <doc xml:space="preserve">the implementation is too old</doc>
      </member>
      <member name="resource_unavailable" value="2" c:identifier="GST_GL_WINDOW_ERROR_RESOURCE_UNAVAILABLE" glib:nick="resource-unavailable">
        <doc xml:space="preserve">no such resource was found</doc>
      </member>
      <function name="quark" c:identifier="gst_gl_window_error_quark">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quark used for #GstGLWindow in #GError's</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="GLWindowPrivate" c:type="GstGLWindowPrivate" disguised="1"/>
    <callback name="GLWindowResizeCB" c:type="GstGLWindowResizeCB">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="GL_ALLOCATION_PARAMS_ALLOC_FLAG_ALLOC" value="1" c:type="GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_ALLOC">
      <doc xml:space="preserve">GL Allocation flag indicating that the implementation should allocate the
necessary resources.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="GL_ALLOCATION_PARAMS_ALLOC_FLAG_BUFFER" value="16" c:type="GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_BUFFER">
      <doc xml:space="preserve">GL allocation flag indicating the allocation of a GL buffer.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER" value="65536" c:type="GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER">
      <doc xml:space="preserve">Values &gt;= than #GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER can be used for
user-defined purposes.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="GL_ALLOCATION_PARAMS_ALLOC_FLAG_VIDEO" value="8" c:type="GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_VIDEO">
      <doc xml:space="preserve">GL allocation flag indicating the allocation of 2D video frames</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_GPU_HANDLE" value="4" c:type="GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_GPU_HANDLE">
      <doc xml:space="preserve">GL Allocation flag for using the provided GPU handle as storage.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_SYSMEM" value="2" c:type="GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_SYSMEM">
      <doc xml:space="preserve">GL Allocation flag for using the provided system memory data as storage.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="GL_API_GLES1_NAME" value="gles1" c:type="GST_GL_API_GLES1_NAME">
      <doc xml:space="preserve">The name for %GST_GL_API_GLES1 used in various places</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_API_GLES2_NAME" value="gles2" c:type="GST_GL_API_GLES2_NAME">
      <doc xml:space="preserve">The name for %GST_GL_API_GLES2 used in various places</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_API_OPENGL3_NAME" value="opengl3" c:type="GST_GL_API_OPENGL3_NAME">
      <doc xml:space="preserve">The name for %GST_GL_API_OPENGL3 used in various places</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_API_OPENGL_NAME" value="opengl" c:type="GST_GL_API_OPENGL_NAME">
      <doc xml:space="preserve">The name for %GST_GL_API_OPENGL used in various places</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GL_ASYNC_CAT_LEVEL_LOG_valist" c:identifier="GST_GL_ASYNC_CAT_LEVEL_LOG_valist" introspectable="0">
      <doc xml:space="preserve">Stores a debug message in @ad for later output</doc>
      <parameters>
        <parameter name="ad">
          <doc xml:space="preserve">the #GstGLAsyncDebug to store the message in</doc>
        </parameter>
        <parameter name="cat">
          <doc xml:space="preserve">the #GstDebugCategory to output the message in</doc>
        </parameter>
        <parameter name="level">
          <doc xml:space="preserve">the #GstDebugLevel</doc>
        </parameter>
        <parameter name="object">
          <doc xml:space="preserve">a #GObject to associate with the debug message</doc>
        </parameter>
        <parameter name="format">
          <doc xml:space="preserve">a printf style format string</doc>
        </parameter>
        <parameter name="varargs">
          <doc xml:space="preserve">the list of arguments for @format</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BASE_FILTER" c:identifier="GST_GL_BASE_FILTER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BASE_FILTER_CLASS" c:identifier="GST_GL_BASE_FILTER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BASE_FILTER_GET_CLASS" c:identifier="GST_GL_BASE_FILTER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BASE_MEMORY_ALLOCATOR" c:identifier="GST_GL_BASE_MEMORY_ALLOCATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BASE_MEMORY_ALLOCATOR_CAST" c:identifier="GST_GL_BASE_MEMORY_ALLOCATOR_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BASE_MEMORY_ALLOCATOR_CLASS" c:identifier="GST_GL_BASE_MEMORY_ALLOCATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BASE_MEMORY_ALLOCATOR_GET_CLASS" c:identifier="GST_GL_BASE_MEMORY_ALLOCATOR_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GL_BASE_MEMORY_ALLOCATOR_NAME" value="GLBaseMemory" c:type="GST_GL_BASE_MEMORY_ALLOCATOR_NAME" version="1.8">
      <doc xml:space="preserve">The name of the GL buffer allocator</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GL_BASE_MEMORY_CAST" c:identifier="GST_GL_BASE_MEMORY_CAST" introspectable="0">
      <parameters>
        <parameter name="mem">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BASE_SRC" c:identifier="GST_GL_BASE_SRC" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BASE_SRC_CLASS" c:identifier="GST_GL_BASE_SRC_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BASE_SRC_GET_CLASS" c:identifier="GST_GL_BASE_SRC_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BUFFER_ALLOCATOR" c:identifier="GST_GL_BUFFER_ALLOCATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BUFFER_ALLOCATOR_CAST" c:identifier="GST_GL_BUFFER_ALLOCATOR_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BUFFER_ALLOCATOR_CLASS" c:identifier="GST_GL_BUFFER_ALLOCATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BUFFER_ALLOCATOR_GET_CLASS" c:identifier="GST_GL_BUFFER_ALLOCATOR_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GL_BUFFER_ALLOCATOR_NAME" value="GLBuffer" c:type="GST_GL_BUFFER_ALLOCATOR_NAME">
      <doc xml:space="preserve">The name of the GL buffer allocator</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GL_BUFFER_POOL" c:identifier="GST_GL_BUFFER_POOL" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_BUFFER_POOL_CAST" c:identifier="GST_GL_BUFFER_POOL_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_COLOR_CONVERT" c:identifier="GST_GL_COLOR_CONVERT" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_COLOR_CONVERT_CAST" c:identifier="GST_GL_COLOR_CONVERT_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_COLOR_CONVERT_CLASS" c:identifier="GST_GL_COLOR_CONVERT_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GL_COLOR_CONVERT_EXT_FORMATS" value=", BGR10A2_LE, RGB10A2_LE, P010_10LE, P012_LE, P016_LE, Y212_LE, Y412_LE" c:type="GST_GL_COLOR_CONVERT_EXT_FORMATS" introspectable="0">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_COLOR_CONVERT_FORMATS" value="{ RGBA, RGB, RGBx, BGR, BGRx, BGRA, xRGB, xBGR, ARGB, ABGR, Y444, I420, YV12, Y42B, Y41B, NV12, NV21, NV16, NV61, YUY2, UYVY, Y210, AYUV, VUYA, Y410, GRAY8, GRAY16_LE, GRAY16_BE, RGB16, BGR16, ARGB64 " c:type="GST_GL_COLOR_CONVERT_FORMATS">
      <doc xml:space="preserve">The currently supported formats that can be converted</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_COLOR_CONVERT_VIDEO_CAPS" value="video/x-raw(" c:type="GST_GL_COLOR_CONVERT_VIDEO_CAPS">
      <doc xml:space="preserve">The currently supported #GstCaps that can be converted</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GL_CONTEXT" c:identifier="GST_GL_CONTEXT" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_CONTEXT_CLASS" c:identifier="GST_GL_CONTEXT_CLASS" introspectable="0">
      <parameters>
        <parameter name="k">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_CONTEXT_GET_CLASS" c:identifier="GST_GL_CONTEXT_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GL_CONTEXT_TYPE_CGL" value="gst.gl.context.CGL" c:type="GST_GL_CONTEXT_TYPE_CGL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_CONTEXT_TYPE_EAGL" value="gst.gl.context.EAGL" c:type="GST_GL_CONTEXT_TYPE_EAGL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_CONTEXT_TYPE_EGL" value="gst.gl.context.EGL" c:type="GST_GL_CONTEXT_TYPE_EGL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_CONTEXT_TYPE_GLX" value="gst.gl.context.GLX" c:type="GST_GL_CONTEXT_TYPE_GLX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_CONTEXT_TYPE_WGL" value="gst.gl.context.WGL" c:type="GST_GL_CONTEXT_TYPE_WGL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GL_DISPLAY" c:identifier="GST_GL_DISPLAY" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_DISPLAY_CAST" c:identifier="GST_GL_DISPLAY_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_DISPLAY_CLASS" c:identifier="GST_GL_DISPLAY_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GL_DISPLAY_CONTEXT_TYPE" value="gst.gl.GLDisplay" c:type="GST_GL_DISPLAY_CONTEXT_TYPE">
      <doc xml:space="preserve">The name used in #GstContext queries for requesting a #GstGLDisplay</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GL_DISPLAY_GET_CLASS" c:identifier="GST_GL_DISPLAY_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_FILTER" c:identifier="GST_GL_FILTER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_FILTER_CLASS" c:identifier="GST_GL_FILTER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_FILTER_GET_CLASS" c:identifier="GST_GL_FILTER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_FRAMEBUFFER" c:identifier="GST_GL_FRAMEBUFFER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_FRAMEBUFFER_CAST" c:identifier="GST_GL_FRAMEBUFFER_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_FRAMEBUFFER_CLASS" c:identifier="GST_GL_FRAMEBUFFER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_MEMORY_ALLOCATOR" c:identifier="GST_GL_MEMORY_ALLOCATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_MEMORY_ALLOCATOR_CAST" c:identifier="GST_GL_MEMORY_ALLOCATOR_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_MEMORY_ALLOCATOR_CLASS" c:identifier="GST_GL_MEMORY_ALLOCATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_MEMORY_ALLOCATOR_GET_CLASS" c:identifier="GST_GL_MEMORY_ALLOCATOR_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GL_MEMORY_ALLOCATOR_NAME" value="GLMemory" c:type="GST_GL_MEMORY_ALLOCATOR_NAME">
      <doc xml:space="preserve">The name of the GL memory allocator</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GL_MEMORY_CAST" c:identifier="GST_GL_MEMORY_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_MEMORY_PBO_ALLOCATOR" c:identifier="GST_GL_MEMORY_PBO_ALLOCATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_MEMORY_PBO_ALLOCATOR_CAST" c:identifier="GST_GL_MEMORY_PBO_ALLOCATOR_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_MEMORY_PBO_ALLOCATOR_CLASS" c:identifier="GST_GL_MEMORY_PBO_ALLOCATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_MEMORY_PBO_ALLOCATOR_GET_CLASS" c:identifier="GST_GL_MEMORY_PBO_ALLOCATOR_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GL_MEMORY_PBO_ALLOCATOR_NAME" value="GLMemoryPBO" c:type="GST_GL_MEMORY_PBO_ALLOCATOR_NAME">
      <doc xml:space="preserve">The name of the GL Memory PBO allocator</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_MEMORY_VIDEO_EXT_FORMATS" value=", BGR10A2_LE, RGB10A2_LE, P010_10LE, P012_LE, P016_LE, Y212_LE, Y412_LE" c:type="GST_GL_MEMORY_VIDEO_EXT_FORMATS" introspectable="0">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_MEMORY_VIDEO_FORMATS_STR" value="{ RGBA, BGRA, RGBx, BGRx, ARGB, ABGR, xRGB, xBGR, RGB, BGR, RGB16, BGR16, AYUV, VUYA, Y410, I420, YV12, NV12, NV21, NV16, NV61, YUY2, UYVY, Y210, Y41B, Y42B, Y444, GRAY8, GRAY16_LE, GRAY16_BE, ARGB64" c:type="GST_GL_MEMORY_VIDEO_FORMATS_STR">
      <doc xml:space="preserve">List of video formats that are supported by #GstGLMemory</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GL_OVERLAY_COMPOSITOR" c:identifier="GST_GL_OVERLAY_COMPOSITOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_OVERLAY_COMPOSITOR_CAST" c:identifier="GST_GL_OVERLAY_COMPOSITOR_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_OVERLAY_COMPOSITOR_CLASS" c:identifier="GST_GL_OVERLAY_COMPOSITOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_RENDERBUFFER_ALLOCATOR" c:identifier="GST_GL_RENDERBUFFER_ALLOCATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_RENDERBUFFER_ALLOCATOR_CAST" c:identifier="GST_GL_RENDERBUFFER_ALLOCATOR_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_RENDERBUFFER_ALLOCATOR_CLASS" c:identifier="GST_GL_RENDERBUFFER_ALLOCATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_RENDERBUFFER_ALLOCATOR_GET_CLASS" c:identifier="GST_GL_RENDERBUFFER_ALLOCATOR_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GL_RENDERBUFFER_ALLOCATOR_NAME" value="GLRenderbuffer" c:type="GST_GL_RENDERBUFFER_ALLOCATOR_NAME">
      <doc xml:space="preserve">The name of the GL renderbuffer allocator</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GL_RENDERBUFFER_CAST" c:identifier="GST_GL_RENDERBUFFER_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_SHADER" c:identifier="GST_GL_SHADER" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_SHADER_CLASS" c:identifier="GST_GL_SHADER_CLASS" introspectable="0">
      <parameters>
        <parameter name="k">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_SHADER_GET_CLASS" c:identifier="GST_GL_SHADER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GL_TEXTURE_TARGET_2D_STR" value="2D" c:type="GST_GL_TEXTURE_TARGET_2D_STR">
      <doc xml:space="preserve">String used for %GST_GL_TEXTURE_TARGET_2D in things like caps values</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_TEXTURE_TARGET_EXTERNAL_OES_STR" value="external-oes" c:type="GST_GL_TEXTURE_TARGET_EXTERNAL_OES_STR">
      <doc xml:space="preserve">String used for %GST_GL_TEXTURE_TARGET_EXTERNAL_OES in things like caps values</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GL_TEXTURE_TARGET_RECTANGLE_STR" value="rectangle" c:type="GST_GL_TEXTURE_TARGET_RECTANGLE_STR">
      <doc xml:space="preserve">String used for %GST_GL_TEXTURE_TARGET_RECTANGLE in things like caps values</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GL_UPLOAD" c:identifier="GST_GL_UPLOAD" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_UPLOAD_CAST" c:identifier="GST_GL_UPLOAD_CAST" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_UPLOAD_CLASS" c:identifier="GST_GL_UPLOAD_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_VIEW_CONVERT" c:identifier="GST_GL_VIEW_CONVERT" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_VIEW_CONVERT_CLASS" c:identifier="GST_GL_VIEW_CONVERT_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_VIEW_CONVERT_GET_CLASS" c:identifier="GST_GL_VIEW_CONVERT_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_WINDOW" c:identifier="GST_GL_WINDOW" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_WINDOW_CB" c:identifier="GST_GL_WINDOW_CB" introspectable="0">
      <doc xml:space="preserve">Cast to the current function type for generic window callbacks</doc>
      <parameters>
        <parameter name="f">
          <doc xml:space="preserve">the function to cast</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_WINDOW_CLASS" c:identifier="GST_GL_WINDOW_CLASS" introspectable="0">
      <parameters>
        <parameter name="k">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_WINDOW_GET_CLASS" c:identifier="GST_GL_WINDOW_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_WINDOW_GET_LOCK" c:identifier="GST_GL_WINDOW_GET_LOCK" introspectable="0">
      <parameters>
        <parameter name="w">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_WINDOW_LOCK" c:identifier="GST_GL_WINDOW_LOCK" introspectable="0">
      <parameters>
        <parameter name="w">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_WINDOW_RESIZE_CB" c:identifier="GST_GL_WINDOW_RESIZE_CB" introspectable="0">
      <doc xml:space="preserve">Cast to the current function type for window resize callbacks</doc>
      <parameters>
        <parameter name="f">
          <doc xml:space="preserve">the function to cast</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_WINDOW_UNLOCK" c:identifier="GST_GL_WINDOW_UNLOCK" introspectable="0">
      <parameters>
        <parameter name="w">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GLSL_STAGE" c:identifier="GST_IS_GLSL_STAGE" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GLSL_STAGE_CLASS" c:identifier="GST_IS_GLSL_STAGE_CLASS" introspectable="0">
      <parameters>
        <parameter name="k">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_BASE_FILTER" c:identifier="GST_IS_GL_BASE_FILTER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_BASE_FILTER_CLASS" c:identifier="GST_IS_GL_BASE_FILTER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_BASE_MEMORY_ALLOCATOR" c:identifier="GST_IS_GL_BASE_MEMORY_ALLOCATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_BASE_MEMORY_ALLOCATOR_CLASS" c:identifier="GST_IS_GL_BASE_MEMORY_ALLOCATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_BASE_SRC" c:identifier="GST_IS_GL_BASE_SRC" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_BASE_SRC_CLASS" c:identifier="GST_IS_GL_BASE_SRC_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_BUFFER_ALLOCATOR" c:identifier="GST_IS_GL_BUFFER_ALLOCATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_BUFFER_ALLOCATOR_CLASS" c:identifier="GST_IS_GL_BUFFER_ALLOCATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_BUFFER_POOL" c:identifier="GST_IS_GL_BUFFER_POOL" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_COLOR_CONVERT" c:identifier="GST_IS_GL_COLOR_CONVERT" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_COLOR_CONVERT_CLASS" c:identifier="GST_IS_GL_COLOR_CONVERT_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_CONTEXT" c:identifier="GST_IS_GL_CONTEXT" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_CONTEXT_CLASS" c:identifier="GST_IS_GL_CONTEXT_CLASS" introspectable="0">
      <parameters>
        <parameter name="k">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_DISPLAY" c:identifier="GST_IS_GL_DISPLAY" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_DISPLAY_CLASS" c:identifier="GST_IS_GL_DISPLAY_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_FILTER" c:identifier="GST_IS_GL_FILTER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_FILTER_CLASS" c:identifier="GST_IS_GL_FILTER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_FRAMEBUFFER" c:identifier="GST_IS_GL_FRAMEBUFFER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_FRAMEBUFFER_CLASS" c:identifier="GST_IS_GL_FRAMEBUFFER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_MEMORY_ALLOCATOR" c:identifier="GST_IS_GL_MEMORY_ALLOCATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_MEMORY_ALLOCATOR_CLASS" c:identifier="GST_IS_GL_MEMORY_ALLOCATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_MEMORY_PBO_ALLOCATOR" c:identifier="GST_IS_GL_MEMORY_PBO_ALLOCATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_MEMORY_PBO_ALLOCATOR_CLASS" c:identifier="GST_IS_GL_MEMORY_PBO_ALLOCATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_OVERLAY_COMPOSITOR" c:identifier="GST_IS_GL_OVERLAY_COMPOSITOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_OVERLAY_COMPOSITOR_CLASS" c:identifier="GST_IS_GL_OVERLAY_COMPOSITOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_RENDERBUFFER_ALLOCATOR" c:identifier="GST_IS_GL_RENDERBUFFER_ALLOCATOR" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_RENDERBUFFER_ALLOCATOR_CLASS" c:identifier="GST_IS_GL_RENDERBUFFER_ALLOCATOR_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_SHADER" c:identifier="GST_IS_GL_SHADER" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_SHADER_CLASS" c:identifier="GST_IS_GL_SHADER_CLASS" introspectable="0">
      <parameters>
        <parameter name="k">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_UPLOAD" c:identifier="GST_IS_GL_UPLOAD" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_UPLOAD_CLASS" c:identifier="GST_IS_GL_UPLOAD_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_VIEW_CONVERT" c:identifier="GST_IS_GL_VIEW_CONVERT" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_VIEW_CONVERT_CLASS" c:identifier="GST_IS_GL_VIEW_CONVERT_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_WINDOW" c:identifier="GST_IS_GL_WINDOW" introspectable="0">
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_WINDOW_CLASS" c:identifier="GST_IS_GL_WINDOW_CLASS" introspectable="0">
      <parameters>
        <parameter name="k">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="MAP_GL" value="131072" c:type="GST_MAP_GL">
      <doc xml:space="preserve">Flag indicating that we should map the GL object instead of to system memory.

Combining #GST_MAP_GL with #GST_MAP_WRITE has the same semantics as though
you are writing to OpenGL. Conversely, combining #GST_MAP_GL with
#GST_MAP_READ has the same semantics as though you are reading from OpenGL.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function name="buffer_add_gl_sync_meta" c:identifier="gst_buffer_add_gl_sync_meta" version="1.6">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstGLSyncMeta added to #GstBuffer</doc>
        <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_add_gl_sync_meta_full" c:identifier="gst_buffer_add_gl_sync_meta_full" version="1.8">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstGLSyncMeta added to #GstBuffer</doc>
        <type name="GLSyncMeta" c:type="GstGLSyncMeta*"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">sync data to hold</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="buffer_get_gl_sync_meta" c:identifier="gst_buffer_get_gl_sync_meta" introspectable="0">
      <parameters>
        <parameter name="b">
        </parameter>
      </parameters>
    </function-macro>
    <function name="buffer_pool_config_get_gl_allocation_params" c:identifier="gst_buffer_pool_config_get_gl_allocation_params">
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the currently set #GstGLAllocationParams or %NULL</doc>
        <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
      </return-value>
      <parameters>
        <parameter name="config" transfer-ownership="none">
          <doc xml:space="preserve">a buffer pool config</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_pool_config_set_gl_allocation_params" c:identifier="gst_buffer_pool_config_set_gl_allocation_params">
      <doc xml:space="preserve">Sets @params on @config</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="config" transfer-ownership="none">
          <doc xml:space="preserve">a buffer pool config</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
        <parameter name="params" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLAllocationParams</doc>
          <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
        </parameter>
      </parameters>
    </function>
    <function name="context_get_gl_display" c:identifier="gst_context_get_gl_display" version="1.4">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @display was in @context</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #GstContext</doc>
          <type name="Gst.Context" c:type="GstContext*"/>
        </parameter>
        <parameter name="display" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">resulting #GstGLDisplay</doc>
          <type name="GLDisplay" c:type="GstGLDisplay**"/>
        </parameter>
      </parameters>
    </function>
    <function name="context_set_gl_display" c:identifier="gst_context_set_gl_display" version="1.4">
      <doc xml:space="preserve">Sets @display on @context</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #GstContext</doc>
          <type name="Gst.Context" c:type="GstContext*"/>
        </parameter>
        <parameter name="display" transfer-ownership="none">
          <doc xml:space="preserve">resulting #GstGLDisplay</doc>
          <type name="GLDisplay" c:type="GstGLDisplay*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_api_from_string" c:identifier="gst_gl_api_from_string" moved-to="GLAPI.from_string">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The #GstGLAPI represented by @api_s</doc>
        <type name="GLAPI" c:type="GstGLAPI"/>
      </return-value>
      <parameters>
        <parameter name="api_s" transfer-ownership="none">
          <doc xml:space="preserve">a space separated string of OpenGL apis</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_api_to_string" c:identifier="gst_gl_api_to_string" moved-to="GLAPI.to_string">
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A space separated string of the OpenGL api's enabled in @api</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="api" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLAPI to stringify</doc>
          <type name="GLAPI" c:type="GstGLAPI"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_async_debug_new" c:identifier="gst_gl_async_debug_new" moved-to="GLAsyncDebug.new" version="1.8" introspectable="0">
      <doc xml:space="preserve">Free with gst_gl_async_debug_free()</doc>
      <return-value>
        <doc xml:space="preserve">a new #GstGLAsyncDebug</doc>
        <type name="GLAsyncDebug" c:type="GstGLAsyncDebug*"/>
      </return-value>
    </function>
    <function name="gl_base_memory_alloc" c:identifier="gst_gl_base_memory_alloc" moved-to="GLBaseMemory.alloc" version="1.8">
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GstGLBaseMemory from @allocator with the requested @params.</doc>
        <type name="GLBaseMemory" c:type="GstGLBaseMemory*"/>
      </return-value>
      <parameters>
        <parameter name="allocator" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLBaseMemoryAllocator</doc>
          <type name="GLBaseMemoryAllocator" c:type="GstGLBaseMemoryAllocator*"/>
        </parameter>
        <parameter name="params" transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLAllocationParams to allocate the memory with</doc>
          <type name="GLAllocationParams" c:type="GstGLAllocationParams*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_base_memory_error_quark" c:identifier="gst_gl_base_memory_error_quark" moved-to="GLBaseMemoryError.quark">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the quark used for #GstGLBaseMemory in #GError's</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="gl_base_memory_init_once" c:identifier="gst_gl_base_memory_init_once" moved-to="GLBaseMemory.init_once" version="1.8">
      <doc xml:space="preserve">Initializes the GL Base Memory allocator. It is safe to call this function
multiple times.  This must be called before any other GstGLBaseMemory operation.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="gl_buffer_init_once" c:identifier="gst_gl_buffer_init_once" moved-to="GLBuffer.init_once" version="1.8">
      <doc xml:space="preserve">Initializes the GL Buffer allocator. It is safe to call this function
multiple times.  This must be called before any other #GstGLBuffer operation.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="gl_check_extension" c:identifier="gst_gl_check_extension">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether @name is in the space separated list of @ext</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the extension to search for</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ext" transfer-ownership="none">
          <doc xml:space="preserve">the list of possible extensions</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_context_error_quark" c:identifier="gst_gl_context_error_quark" moved-to="GLContextError.quark">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the quark used for #GstGLContext in #GError's</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function-macro name="gl_display_lock" c:identifier="gst_gl_display_lock" introspectable="0">
      <parameters>
        <parameter name="display">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="gl_display_unlock" c:identifier="gst_gl_display_unlock" introspectable="0">
      <parameters>
        <parameter name="display">
        </parameter>
      </parameters>
    </function-macro>
    <function name="gl_element_propagate_display_context" c:identifier="gst_gl_element_propagate_display_context">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="element" transfer-ownership="none">
          <type name="Gst.Element" c:type="GstElement*"/>
        </parameter>
        <parameter name="display" transfer-ownership="none">
          <type name="GLDisplay" c:type="GstGLDisplay*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_ensure_element_data" c:identifier="gst_gl_ensure_element_data">
      <doc xml:space="preserve">Perform the steps necessary for retrieving a #GstGLDisplay and (optionally)
an application provided #GstGLContext from the surrounding elements or from
the application using the #GstContext mechanism.

If the contents of @display_ptr or @other_context_ptr are not %NULL, then no
#GstContext query is necessary for #GstGLDisplay or #GstGLContext retrieval
or is performed.

This performs #GstContext queries (if necessary) for a winsys display
connection with %GST_GL_DISPLAY_CONTEXT_TYPE, "gst.x11.display.handle", and
"GstWaylandDisplayHandleContextType" stopping after the first successful
retrieval.

This also performs a #GstContext query (if necessary) for an optional
application provided #GstGLContext using the name "gst.gl.app_context".
The returned #GstGLContext will be shared with a GStreamer created OpenGL context.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether a #GstGLDisplay exists in @display_ptr</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="element" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the #GstElement running the query</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="display_ptr" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the resulting #GstGLDisplay</doc>
          <type name="GLDisplay" c:type="GstGLDisplay**"/>
        </parameter>
        <parameter name="other_context_ptr" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the resulting #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext**"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_format_from_video_info" c:identifier="gst_gl_format_from_video_info" moved-to="GLFormat.from_video_info">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstGLFormat necessary for holding the data in @plane of @vinfo</doc>
        <type name="GLFormat" c:type="GstGLFormat"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </parameter>
        <parameter name="vinfo" transfer-ownership="none">
          <doc xml:space="preserve">a #GstVideoInfo</doc>
          <type name="GstVideo.VideoInfo" c:type="GstVideoInfo*"/>
        </parameter>
        <parameter name="plane" transfer-ownership="none">
          <doc xml:space="preserve">the plane number in @vinfo</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_format_is_supported" c:identifier="gst_gl_format_is_supported" moved-to="GLFormat.is_supported" version="1.16">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @format is supported by @context based on the OpenGL API,
         version, or available OpenGL extension/s.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLFormat to check is supported by @context</doc>
          <type name="GLFormat" c:type="GstGLFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_format_type_from_sized_gl_format" c:identifier="gst_gl_format_type_from_sized_gl_format" moved-to="GLFormat.type_from_sized_gl_format" version="1.16">
      <doc xml:space="preserve">Get the unsized format and type from @format for usage in glReadPixels,
glTex{Sub}Image*, glTexImage* and similar functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the sized internal #GstGLFormat</doc>
          <type name="GLFormat" c:type="GstGLFormat"/>
        </parameter>
        <parameter name="unsized_format" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">location for the resulting unsized #GstGLFormat</doc>
          <type name="GLFormat" c:type="GstGLFormat*"/>
        </parameter>
        <parameter name="gl_type" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">location for the resulting GL type</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_format_type_n_bytes" c:identifier="gst_gl_format_type_n_bytes" moved-to="GLFormat.type_n_bytes">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes the specified @format, @type combination takes
per pixel</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the OpenGL format, `GL_RGBA`, `GL_LUMINANCE`, etc</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the OpenGL type, `GL_UNSIGNED_BYTE`, `GL_FLOAT`, etc</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_get_plane_data_size" c:identifier="gst_gl_get_plane_data_size">
      <doc xml:space="preserve">Retrieve the size in bytes of a video plane of data with a certain alignment</doc>
      <return-value transfer-ownership="none">
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GstVideoInfo</doc>
          <type name="GstVideo.VideoInfo" c:type="GstVideoInfo*"/>
        </parameter>
        <parameter name="align" transfer-ownership="none">
          <doc xml:space="preserve">a #GstVideoAlignment or %NULL</doc>
          <type name="GstVideo.VideoAlignment" c:type="GstVideoAlignment*"/>
        </parameter>
        <parameter name="plane" transfer-ownership="none">
          <doc xml:space="preserve">plane number in @info to retrieve the data size of</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_get_plane_start" c:identifier="gst_gl_get_plane_start">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">difference between the supposed start of the plane from the @info
         and where the data from the previous plane ends.</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GstVideoInfo</doc>
          <type name="GstVideo.VideoInfo" c:type="GstVideoInfo*"/>
        </parameter>
        <parameter name="valign" transfer-ownership="none">
          <doc xml:space="preserve">a #GstVideoAlignment or %NULL</doc>
          <type name="GstVideo.VideoAlignment" c:type="GstVideoAlignment*"/>
        </parameter>
        <parameter name="plane" transfer-ownership="none">
          <doc xml:space="preserve">plane number in @info to retrieve the data size of</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_handle_context_query" c:identifier="gst_gl_handle_context_query">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether the @query was successfully responded to from the passed
         @display, @context, and @other_context.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="element" transfer-ownership="none">
          <doc xml:space="preserve">a #GstElement</doc>
          <type name="Gst.Element" c:type="GstElement*"/>
        </parameter>
        <parameter name="query" transfer-ownership="none">
          <doc xml:space="preserve">a #GstQuery of type %GST_QUERY_CONTEXT</doc>
          <type name="Gst.Query" c:type="GstQuery*"/>
        </parameter>
        <parameter name="display" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GstGLDisplay</doc>
          <type name="GLDisplay" c:type="GstGLDisplay*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </parameter>
        <parameter name="other_context" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">application provided #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_handle_set_context" c:identifier="gst_gl_handle_set_context">
      <doc xml:space="preserve">Helper function for implementing #GstElementClass.set_context() in
OpenGL capable elements.

Retrieve's the #GstGLDisplay or #GstGLContext in @context and places the
result in @display or @other_context respectively.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the @display or @other_context could be set successfully</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="element" transfer-ownership="none">
          <doc xml:space="preserve">a #GstElement</doc>
          <type name="Gst.Element" c:type="GstElement*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #GstContext</doc>
          <type name="Gst.Context" c:type="GstContext*"/>
        </parameter>
        <parameter name="display" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">location of a #GstGLDisplay</doc>
          <type name="GLDisplay" c:type="GstGLDisplay**"/>
        </parameter>
        <parameter name="other_context" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">location of a #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext**"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_insert_debug_marker" c:identifier="gst_gl_insert_debug_marker" version="1.8" introspectable="0">
      <doc xml:space="preserve">Inserts a marker into a GL debug stream.  Requires the 'gldebugmarker'
debug category to be at least %GST_LEVEL_FIXME.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a printf-style format string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">arguments form @format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_memory_init_once" c:identifier="gst_gl_memory_init_once" moved-to="GLMemory.init_once" version="1.4">
      <doc xml:space="preserve">Initializes the GL Base Texture allocator. It is safe to call this function
multiple times.  This must be called before any other GstGLMemory operation.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="gl_memory_pbo_init_once" c:identifier="gst_gl_memory_pbo_init_once" moved-to="GLMemoryPBO.init_once">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="gl_memory_setup_buffer" c:identifier="gst_gl_memory_setup_buffer" moved-to="GLMemory.setup_buffer" version="1.8" introspectable="0">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the buffer was correctly setup</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="allocator" transfer-ownership="none">
          <doc xml:space="preserve">the @GstGLMemoryAllocator to allocate from</doc>
          <type name="GLMemoryAllocator" c:type="GstGLMemoryAllocator*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a #GstBuffer to setup</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="params" transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLVideoAllocationParams to allocate with</doc>
          <type name="GLVideoAllocationParams" c:type="GstGLVideoAllocationParams*"/>
        </parameter>
        <parameter name="tex_formats" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">
    a list of #GstGLFormat's to allocate with.</doc>
          <array length="5" zero-terminated="0" c:type="GstGLFormat*">
            <type name="GLFormat" c:type="GstGLFormat"/>
          </array>
        </parameter>
        <parameter name="wrapped_data" transfer-ownership="none">
          <doc xml:space="preserve">
    a list of wrapped data pointers</doc>
          <array length="5" zero-terminated="0" c:type="gpointer*">
            <type name="gpointer"/>
          </array>
        </parameter>
        <parameter name="n_wrapped_pointers" transfer-ownership="none">
          <doc xml:space="preserve">the number of elements in @tex_formats and @wrapped_data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_platform_from_string" c:identifier="gst_gl_platform_from_string" moved-to="GLPlatform.from_string">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The #GstGLPlatform represented by @platform_s</doc>
        <type name="GLPlatform" c:type="GstGLPlatform"/>
      </return-value>
      <parameters>
        <parameter name="platform_s" transfer-ownership="none">
          <doc xml:space="preserve">a space separated string of OpenGL platformss</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_platform_to_string" c:identifier="gst_gl_platform_to_string" moved-to="GLPlatform.to_string">
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A space separated string of the OpenGL platforms enabled in @platform</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="platform" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLPlatform to stringify</doc>
          <type name="GLPlatform" c:type="GstGLPlatform"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="gl_query_counter_log_valist" c:identifier="gst_gl_query_counter_log_valist" introspectable="0">
      <parameters>
        <parameter name="query">
        </parameter>
        <parameter name="cat">
        </parameter>
        <parameter name="level">
        </parameter>
        <parameter name="object">
        </parameter>
        <parameter name="format">
        </parameter>
        <parameter name="varargs">
        </parameter>
      </parameters>
    </function-macro>
    <function name="gl_query_local_gl_context" c:identifier="gst_gl_query_local_gl_context" moved-to="GLQuery.local_gl_context">
      <doc xml:space="preserve">Performs a GST_QUERY_CONTEXT query of type "gst.gl.local_context" on all
#GstPads in @element of @direction for the local OpenGL context used by
GStreamer elements.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether @context_ptr contains a #GstGLContext</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="element" transfer-ownership="none">
          <doc xml:space="preserve">a #GstElement to query from</doc>
          <type name="Gst.Element" c:type="GstElement*"/>
        </parameter>
        <parameter name="direction" transfer-ownership="none">
          <doc xml:space="preserve">the #GstPadDirection to query</doc>
          <type name="Gst.PadDirection" c:type="GstPadDirection"/>
        </parameter>
        <parameter name="context_ptr" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">location containing the current and/or resulting
                     #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext**"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_query_new" c:identifier="gst_gl_query_new" moved-to="GLQuery.new" version="1.10" introspectable="0">
      <doc xml:space="preserve">Free with gst_gl_query_free()</doc>
      <return-value>
        <doc xml:space="preserve">a new #GstGLQuery</doc>
        <type name="GLQuery" c:type="GstGLQuery*"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </parameter>
        <parameter name="query_type" transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLQueryType to create</doc>
          <type name="GLQueryType" c:type="GstGLQueryType"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="gl_query_start_log_valist" c:identifier="gst_gl_query_start_log_valist" introspectable="0">
      <parameters>
        <parameter name="query">
        </parameter>
        <parameter name="cat">
        </parameter>
        <parameter name="level">
        </parameter>
        <parameter name="object">
        </parameter>
        <parameter name="format">
        </parameter>
        <parameter name="varargs">
        </parameter>
      </parameters>
    </function-macro>
    <function name="gl_renderbuffer_init_once" c:identifier="gst_gl_renderbuffer_init_once" moved-to="GLRenderbuffer.init_once" version="1.10">
      <doc xml:space="preserve">Initializes the GL Base Texture allocator. It is safe to call this function
multiple times.  This must be called before any other GstGLRenderbuffer operation.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="gl_sized_gl_format_from_gl_format_type" c:identifier="gst_gl_sized_gl_format_from_gl_format_type">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the sized internal format specified by @format and @type that can
         be used in @context</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLContext</doc>
          <type name="GLContext" c:type="GstGLContext*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">an OpenGL format, `GL_RGBA`, `GL_LUMINANCE`, etc</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">an OpenGL type, `GL_UNSIGNED_BYTE`, `GL_FLOAT`, etc</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_stereo_downmix_mode_get_type" c:identifier="gst_gl_stereo_downmix_mode_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="gl_sync_meta_api_get_type" c:identifier="gst_gl_sync_meta_api_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="gl_sync_meta_get_info" c:identifier="gst_gl_sync_meta_get_info" moved-to="GLSyncMeta.get_info">
      <return-value transfer-ownership="none">
        <type name="Gst.MetaInfo" c:type="const GstMetaInfo*"/>
      </return-value>
    </function>
    <function name="gl_texture_target_from_gl" c:identifier="gst_gl_texture_target_from_gl" moved-to="GLTextureTarget.from_gl">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstGLTextureTarget that's equiavalant to @target or
         %GST_GL_TEXTURE_TARGET_NONE</doc>
        <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve">an OpenGL texture binding target</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_texture_target_from_string" c:identifier="gst_gl_texture_target_from_string" moved-to="GLTextureTarget.from_string">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstGLTextureTarget represented by @str or
         %GST_GL_TEXTURE_TARGET_NONE</doc>
        <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string equivalent to one of the GST_GL_TEXTURE_TARGET_*_STR values</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_texture_target_to_buffer_pool_option" c:identifier="gst_gl_texture_target_to_buffer_pool_option" moved-to="GLTextureTarget.to_buffer_pool_option">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a string representing the @GstBufferPoolOption specified by @target</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLTextureTarget</doc>
          <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_texture_target_to_gl" c:identifier="gst_gl_texture_target_to_gl" moved-to="GLTextureTarget.to_gl">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the OpenGL value for binding the @target with glBindTexture() and
         similar functions or 0</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLTextureTarget</doc>
          <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_texture_target_to_string" c:identifier="gst_gl_texture_target_to_string" moved-to="GLTextureTarget.to_string">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the stringified version of @target or %NULL</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLTextureTarget</doc>
          <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_value_get_texture_target_mask" c:identifier="gst_gl_value_get_texture_target_mask">
      <doc xml:space="preserve">See gst_gl_value_set_texture_target_from_mask() for what entails a mask</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the mask of #GstGLTextureTarget's in @value</doc>
        <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">an initialized #GValue of type G_TYPE_STRING</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_value_set_texture_target" c:identifier="gst_gl_value_set_texture_target">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the @target could be set on @value</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">an initialized #GValue of type G_TYPE_STRING</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLTextureTarget's</doc>
          <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_value_set_texture_target_from_mask" c:identifier="gst_gl_value_set_texture_target_from_mask">
      <doc xml:space="preserve">A mask is a bitwise OR of (1 &lt;&lt; target) where target is a valid
#GstGLTextureTarget</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the @target_mask could be set on @value</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">an uninitialized #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="target_mask" transfer-ownership="none">
          <doc xml:space="preserve">a bitwise mask of #GstGLTextureTarget's</doc>
          <type name="GLTextureTarget" c:type="GstGLTextureTarget"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_version_to_glsl_version" c:identifier="gst_gl_version_to_glsl_version">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The minimum supported #GstGLSLVersion available for @gl_api, @maj and @min</doc>
        <type name="GLSLVersion" c:type="GstGLSLVersion"/>
      </return-value>
      <parameters>
        <parameter name="gl_api" transfer-ownership="none">
          <doc xml:space="preserve">the #GstGLAPI</doc>
          <type name="GLAPI" c:type="GstGLAPI"/>
        </parameter>
        <parameter name="maj" transfer-ownership="none">
          <doc xml:space="preserve">the major GL version</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="min" transfer-ownership="none">
          <doc xml:space="preserve">the minor GL version</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="gl_window_error_quark" c:identifier="gst_gl_window_error_quark" moved-to="GLWindowError.quark">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the quark used for #GstGLWindow in #GError's</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="glsl_error_quark" c:identifier="gst_glsl_error_quark" moved-to="GLSLError.quark">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the quark used for GstGLSL in #GError's</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="glsl_profile_from_string" c:identifier="gst_glsl_profile_from_string" moved-to="GLSLProfile.from_string">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstGLSLProfile of @string or %GST_GLSL_PROFILE_NONE on error</doc>
        <type name="GLSLProfile" c:type="GstGLSLProfile"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a GLSL version string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="glsl_profile_to_string" c:identifier="gst_glsl_profile_to_string" moved-to="GLSLProfile.to_string">
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the name for @profile or %NULL on error</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="profile" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLSLProfile</doc>
          <type name="GLSLProfile" c:type="GstGLSLProfile"/>
        </parameter>
      </parameters>
    </function>
    <function name="glsl_string_get_version_profile" c:identifier="gst_glsl_string_get_version_profile">
      <doc xml:space="preserve">Note: this function first searches the first 1 kilobytes for a `#version`
preprocessor directive and then executes gst_glsl_version_profile_from_string().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">TRUE if a valid `#version` string was found, FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="s" transfer-ownership="none">
          <doc xml:space="preserve">string to search for a valid `#version` string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="version" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">resulting #GstGLSLVersion</doc>
          <type name="GLSLVersion" c:type="GstGLSLVersion*"/>
        </parameter>
        <parameter name="profile" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">resulting #GstGLSLProfile</doc>
          <type name="GLSLProfile" c:type="GstGLSLProfile*"/>
        </parameter>
      </parameters>
    </function>
    <function name="glsl_version_from_string" c:identifier="gst_glsl_version_from_string" moved-to="GLSLVersion.from_string">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstGLSLVersion of @string or %GST_GLSL_VERSION_NONE on error</doc>
        <type name="GLSLVersion" c:type="GstGLSLVersion"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a GLSL version string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="glsl_version_profile_from_string" c:identifier="gst_glsl_version_profile_from_string" moved-to="GLSLVersion.profile_from_string">
      <doc xml:space="preserve">Note: this function expects either a `#version` GLSL preprocesser directive
or a valid GLSL version and/or profile.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">TRUE if a valid `#version` string was found, FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a valid GLSL `#version` string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="version_ret" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">resulting #GstGLSLVersion</doc>
          <type name="GLSLVersion" c:type="GstGLSLVersion*"/>
        </parameter>
        <parameter name="profile_ret" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">resulting #GstGLSLVersion</doc>
          <type name="GLSLProfile" c:type="GstGLSLProfile*"/>
        </parameter>
      </parameters>
    </function>
    <function name="glsl_version_profile_to_string" c:identifier="gst_glsl_version_profile_to_string" moved-to="GLSLVersion.profile_to_string">
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the combined GLSL `#version` string for @version and @profile</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="version" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLSLVersion</doc>
          <type name="GLSLVersion" c:type="GstGLSLVersion"/>
        </parameter>
        <parameter name="profile" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLSLVersion</doc>
          <type name="GLSLProfile" c:type="GstGLSLProfile"/>
        </parameter>
      </parameters>
    </function>
    <function name="glsl_version_to_string" c:identifier="gst_glsl_version_to_string" moved-to="GLSLVersion.to_string">
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the name of @version or %NULL on error</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="version" transfer-ownership="none">
          <doc xml:space="preserve">a #GstGLSLVersion</doc>
          <type name="GLSLVersion" c:type="GstGLSLVersion"/>
        </parameter>
      </parameters>
    </function>
    <docsection name="gstglapi">
      <doc xml:space="preserve">Provides some helper API for dealing with OpenGL API's and platforms</doc>
    </docsection>
    <docsection name="gstglformat">
      <doc xml:space="preserve">Some useful utilities for converting between various formats and OpenGL
formats.</doc>
    </docsection>
    <function name="is_gl_base_memory" c:identifier="gst_is_gl_base_memory" version="1.8">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the memory at @mem is a #GstGLBaseMemory</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:space="preserve">a #GstMemory</doc>
          <type name="Gst.Memory" c:type="GstMemory*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_gl_buffer" c:identifier="gst_is_gl_buffer" version="1.8">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the memory at @mem is a #GstGLBuffer</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:space="preserve">a #GstMemory</doc>
          <type name="Gst.Memory" c:type="GstMemory*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_gl_memory" c:identifier="gst_is_gl_memory" version="1.4">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the memory at @mem is a #GstGLMemory</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:space="preserve">a #GstMemory</doc>
          <type name="Gst.Memory" c:type="GstMemory*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_gl_memory_pbo" c:identifier="gst_is_gl_memory_pbo" version="1.8">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the memory at @mem is a #GstGLMemoryPBO</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:space="preserve">a #GstMemory</doc>
          <type name="Gst.Memory" c:type="GstMemory*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_gl_renderbuffer" c:identifier="gst_is_gl_renderbuffer" version="1.10">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the memory at @mem is a #GstGLRenderbuffer</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:space="preserve">a #GstMemory</doc>
          <type name="Gst.Memory" c:type="GstMemory*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
