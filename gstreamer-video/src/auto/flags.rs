// This file was generated by gir (https://github.com/gtk-rs/gir @ d1e0127)
// from gir-files (https://github.com/gtk-rs/gir-files @ ???)
// DO NOT EDIT

use ffi;
use glib::StaticType;
use glib::Type;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use gobject_ffi;

bitflags! {
    pub struct VideoChromaSite: u32 {
        const UNKNOWN = 0;
        const NONE = 1;
        const H_COSITED = 2;
        const V_COSITED = 4;
        const ALT_LINE = 8;
        const COSITED = 6;
        const JPEG = 1;
        const MPEG2 = 2;
        const DV = 14;
    }
}

#[doc(hidden)]
impl ToGlib for VideoChromaSite {
    type GlibType = ffi::GstVideoChromaSite;

    fn to_glib(&self) -> ffi::GstVideoChromaSite {
        ffi::GstVideoChromaSite::from_bits_truncate(self.bits())
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstVideoChromaSite> for VideoChromaSite {
    fn from_glib(value: ffi::GstVideoChromaSite) -> VideoChromaSite {
        skip_assert_initialized!();
        VideoChromaSite::from_bits_truncate(value.bits())
    }
}

impl StaticType for VideoChromaSite {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_video_chroma_site_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VideoChromaSite {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VideoChromaSite {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(ffi::GstVideoChromaSite::from_bits_truncate(gobject_ffi::g_value_get_flags(value.to_glib_none().0)))
    }
}

impl SetValue for VideoChromaSite {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib().bits())
    }
}

bitflags! {
    pub struct VideoFlags: u32 {
        const NONE = 0;
        const VARIABLE_FPS = 1;
        const PREMULTIPLIED_ALPHA = 2;
    }
}

#[doc(hidden)]
impl ToGlib for VideoFlags {
    type GlibType = ffi::GstVideoFlags;

    fn to_glib(&self) -> ffi::GstVideoFlags {
        ffi::GstVideoFlags::from_bits_truncate(self.bits())
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstVideoFlags> for VideoFlags {
    fn from_glib(value: ffi::GstVideoFlags) -> VideoFlags {
        skip_assert_initialized!();
        VideoFlags::from_bits_truncate(value.bits())
    }
}

impl StaticType for VideoFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_video_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VideoFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VideoFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(ffi::GstVideoFlags::from_bits_truncate(gobject_ffi::g_value_get_flags(value.to_glib_none().0)))
    }
}

impl SetValue for VideoFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib().bits())
    }
}

bitflags! {
    pub struct VideoFormatFlags: u32 {
        const YUV = 1;
        const RGB = 2;
        const GRAY = 4;
        const ALPHA = 8;
        const LE = 16;
        const PALETTE = 32;
        const COMPLEX = 64;
        const UNPACK = 128;
        const TILED = 256;
    }
}

#[doc(hidden)]
impl ToGlib for VideoFormatFlags {
    type GlibType = ffi::GstVideoFormatFlags;

    fn to_glib(&self) -> ffi::GstVideoFormatFlags {
        ffi::GstVideoFormatFlags::from_bits_truncate(self.bits())
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstVideoFormatFlags> for VideoFormatFlags {
    fn from_glib(value: ffi::GstVideoFormatFlags) -> VideoFormatFlags {
        skip_assert_initialized!();
        VideoFormatFlags::from_bits_truncate(value.bits())
    }
}

impl StaticType for VideoFormatFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_video_format_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VideoFormatFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VideoFormatFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(ffi::GstVideoFormatFlags::from_bits_truncate(gobject_ffi::g_value_get_flags(value.to_glib_none().0)))
    }
}

impl SetValue for VideoFormatFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib().bits())
    }
}

bitflags! {
    pub struct VideoFrameFlags: u32 {
        const NONE = 0;
        const INTERLACED = 1;
        const TFF = 2;
        const RFF = 4;
        const ONEFIELD = 8;
        const MULTIPLE_VIEW = 16;
        const FIRST_IN_BUNDLE = 32;
    }
}

#[doc(hidden)]
impl ToGlib for VideoFrameFlags {
    type GlibType = ffi::GstVideoFrameFlags;

    fn to_glib(&self) -> ffi::GstVideoFrameFlags {
        ffi::GstVideoFrameFlags::from_bits_truncate(self.bits())
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstVideoFrameFlags> for VideoFrameFlags {
    fn from_glib(value: ffi::GstVideoFrameFlags) -> VideoFrameFlags {
        skip_assert_initialized!();
        VideoFrameFlags::from_bits_truncate(value.bits())
    }
}

impl StaticType for VideoFrameFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_video_frame_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VideoFrameFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VideoFrameFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(ffi::GstVideoFrameFlags::from_bits_truncate(gobject_ffi::g_value_get_flags(value.to_glib_none().0)))
    }
}

impl SetValue for VideoFrameFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib().bits())
    }
}

bitflags! {
    pub struct VideoMultiviewFlags: u32 {
        const NONE = 0;
        const RIGHT_VIEW_FIRST = 1;
        const LEFT_FLIPPED = 2;
        const LEFT_FLOPPED = 4;
        const RIGHT_FLIPPED = 8;
        const RIGHT_FLOPPED = 16;
        const HALF_ASPECT = 16384;
        const MIXED_MONO = 32768;
    }
}

#[doc(hidden)]
impl ToGlib for VideoMultiviewFlags {
    type GlibType = ffi::GstVideoMultiviewFlags;

    fn to_glib(&self) -> ffi::GstVideoMultiviewFlags {
        ffi::GstVideoMultiviewFlags::from_bits_truncate(self.bits())
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstVideoMultiviewFlags> for VideoMultiviewFlags {
    fn from_glib(value: ffi::GstVideoMultiviewFlags) -> VideoMultiviewFlags {
        skip_assert_initialized!();
        VideoMultiviewFlags::from_bits_truncate(value.bits())
    }
}

impl StaticType for VideoMultiviewFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_video_multiview_flags_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for VideoMultiviewFlags {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for VideoMultiviewFlags {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(ffi::GstVideoMultiviewFlags::from_bits_truncate(gobject_ffi::g_value_get_flags(value.to_glib_none().0)))
    }
}

impl SetValue for VideoMultiviewFlags {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib().bits())
    }
}

