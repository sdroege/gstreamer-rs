// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// from gst-gir-files (https://gitlab.freedesktop.org/gstreamer/gir-files-rs.git)
// DO NOT EDIT

use bitflags::bitflags;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::StaticType;
use glib::Type;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use std::ffi::CStr;
#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
use std::fmt;

bitflags! {
    #[doc(alias = "GstBinFlags")]
    pub struct BinFlags: u32 {
        #[doc(alias = "GST_BIN_FLAG_NO_RESYNC")]
        const NO_RESYNC = ffi::GST_BIN_FLAG_NO_RESYNC as u32;
        #[cfg(any(feature = "v1_10", feature = "dox"))]
        #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
        #[doc(alias = "GST_BIN_FLAG_STREAMS_AWARE")]
        const STREAMS_AWARE = ffi::GST_BIN_FLAG_STREAMS_AWARE as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for BinFlags {
    type GlibType = ffi::GstBinFlags;

    fn into_glib(self) -> ffi::GstBinFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstBinFlags> for BinFlags {
    unsafe fn from_glib(value: ffi::GstBinFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BinFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_bin_flags_get_type()) }
    }
}

impl glib::value::ValueType for BinFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for BinFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BinFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstBufferCopyFlags")]
    pub struct BufferCopyFlags: u32 {
        #[doc(alias = "GST_BUFFER_COPY_FLAGS")]
        const FLAGS = ffi::GST_BUFFER_COPY_FLAGS as u32;
        #[doc(alias = "GST_BUFFER_COPY_TIMESTAMPS")]
        const TIMESTAMPS = ffi::GST_BUFFER_COPY_TIMESTAMPS as u32;
        #[doc(alias = "GST_BUFFER_COPY_META")]
        const META = ffi::GST_BUFFER_COPY_META as u32;
        #[doc(alias = "GST_BUFFER_COPY_MEMORY")]
        const MEMORY = ffi::GST_BUFFER_COPY_MEMORY as u32;
        #[doc(alias = "GST_BUFFER_COPY_MERGE")]
        const MERGE = ffi::GST_BUFFER_COPY_MERGE as u32;
        #[doc(alias = "GST_BUFFER_COPY_DEEP")]
        const DEEP = ffi::GST_BUFFER_COPY_DEEP as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for BufferCopyFlags {
    type GlibType = ffi::GstBufferCopyFlags;

    fn into_glib(self) -> ffi::GstBufferCopyFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstBufferCopyFlags> for BufferCopyFlags {
    unsafe fn from_glib(value: ffi::GstBufferCopyFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BufferCopyFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_buffer_copy_flags_get_type()) }
    }
}

impl glib::value::ValueType for BufferCopyFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for BufferCopyFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BufferCopyFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[cfg_attr(feature = "ser_de", derive(serde::Serialize, serde::Deserialize))]
    #[doc(alias = "GstBufferFlags")]
    pub struct BufferFlags: u32 {
        #[doc(alias = "GST_BUFFER_FLAG_LIVE")]
        const LIVE = ffi::GST_BUFFER_FLAG_LIVE as u32;
        #[doc(alias = "GST_BUFFER_FLAG_DECODE_ONLY")]
        const DECODE_ONLY = ffi::GST_BUFFER_FLAG_DECODE_ONLY as u32;
        #[doc(alias = "GST_BUFFER_FLAG_DISCONT")]
        const DISCONT = ffi::GST_BUFFER_FLAG_DISCONT as u32;
        #[doc(alias = "GST_BUFFER_FLAG_RESYNC")]
        const RESYNC = ffi::GST_BUFFER_FLAG_RESYNC as u32;
        #[doc(alias = "GST_BUFFER_FLAG_CORRUPTED")]
        const CORRUPTED = ffi::GST_BUFFER_FLAG_CORRUPTED as u32;
        #[doc(alias = "GST_BUFFER_FLAG_MARKER")]
        const MARKER = ffi::GST_BUFFER_FLAG_MARKER as u32;
        #[doc(alias = "GST_BUFFER_FLAG_HEADER")]
        const HEADER = ffi::GST_BUFFER_FLAG_HEADER as u32;
        #[doc(alias = "GST_BUFFER_FLAG_GAP")]
        const GAP = ffi::GST_BUFFER_FLAG_GAP as u32;
        #[doc(alias = "GST_BUFFER_FLAG_DROPPABLE")]
        const DROPPABLE = ffi::GST_BUFFER_FLAG_DROPPABLE as u32;
        #[doc(alias = "GST_BUFFER_FLAG_DELTA_UNIT")]
        const DELTA_UNIT = ffi::GST_BUFFER_FLAG_DELTA_UNIT as u32;
        #[doc(alias = "GST_BUFFER_FLAG_TAG_MEMORY")]
        const TAG_MEMORY = ffi::GST_BUFFER_FLAG_TAG_MEMORY as u32;
        #[doc(alias = "GST_BUFFER_FLAG_SYNC_AFTER")]
        const SYNC_AFTER = ffi::GST_BUFFER_FLAG_SYNC_AFTER as u32;
        #[cfg(any(feature = "v1_14", feature = "dox"))]
        #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_14")))]
        #[doc(alias = "GST_BUFFER_FLAG_NON_DROPPABLE")]
        const NON_DROPPABLE = ffi::GST_BUFFER_FLAG_NON_DROPPABLE as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for BufferFlags {
    type GlibType = ffi::GstBufferFlags;

    fn into_glib(self) -> ffi::GstBufferFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstBufferFlags> for BufferFlags {
    unsafe fn from_glib(value: ffi::GstBufferFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BufferFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_buffer_flags_get_type()) }
    }
}

impl glib::value::ValueType for BufferFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for BufferFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BufferFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstBufferPoolAcquireFlags")]
    pub struct BufferPoolAcquireFlags: u32 {
        #[doc(alias = "GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT")]
        const KEY_UNIT = ffi::GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT as u32;
        #[doc(alias = "GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT")]
        const DONTWAIT = ffi::GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT as u32;
        #[doc(alias = "GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT")]
        const DISCONT = ffi::GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for BufferPoolAcquireFlags {
    type GlibType = ffi::GstBufferPoolAcquireFlags;

    fn into_glib(self) -> ffi::GstBufferPoolAcquireFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstBufferPoolAcquireFlags> for BufferPoolAcquireFlags {
    unsafe fn from_glib(value: ffi::GstBufferPoolAcquireFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BufferPoolAcquireFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_buffer_pool_acquire_flags_get_type()) }
    }
}

impl glib::value::ValueType for BufferPoolAcquireFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for BufferPoolAcquireFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BufferPoolAcquireFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstClockFlags")]
    pub struct ClockFlags: u32 {
        #[doc(alias = "GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC")]
        const CAN_DO_SINGLE_SYNC = ffi::GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC as u32;
        #[doc(alias = "GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC")]
        const CAN_DO_SINGLE_ASYNC = ffi::GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC as u32;
        #[doc(alias = "GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC")]
        const CAN_DO_PERIODIC_SYNC = ffi::GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC as u32;
        #[doc(alias = "GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC")]
        const CAN_DO_PERIODIC_ASYNC = ffi::GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC as u32;
        #[doc(alias = "GST_CLOCK_FLAG_CAN_SET_RESOLUTION")]
        const CAN_SET_RESOLUTION = ffi::GST_CLOCK_FLAG_CAN_SET_RESOLUTION as u32;
        #[doc(alias = "GST_CLOCK_FLAG_CAN_SET_MASTER")]
        const CAN_SET_MASTER = ffi::GST_CLOCK_FLAG_CAN_SET_MASTER as u32;
        #[doc(alias = "GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC")]
        const NEEDS_STARTUP_SYNC = ffi::GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for ClockFlags {
    type GlibType = ffi::GstClockFlags;

    fn into_glib(self) -> ffi::GstClockFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstClockFlags> for ClockFlags {
    unsafe fn from_glib(value: ffi::GstClockFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ClockFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_clock_flags_get_type()) }
    }
}

impl glib::value::ValueType for ClockFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ClockFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ClockFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstDebugColorFlags")]
    pub struct DebugColorFlags: u32 {
        #[doc(alias = "GST_DEBUG_FG_BLACK")]
        const FG_BLACK = ffi::GST_DEBUG_FG_BLACK as u32;
        #[doc(alias = "GST_DEBUG_FG_RED")]
        const FG_RED = ffi::GST_DEBUG_FG_RED as u32;
        #[doc(alias = "GST_DEBUG_FG_GREEN")]
        const FG_GREEN = ffi::GST_DEBUG_FG_GREEN as u32;
        #[doc(alias = "GST_DEBUG_FG_YELLOW")]
        const FG_YELLOW = ffi::GST_DEBUG_FG_YELLOW as u32;
        #[doc(alias = "GST_DEBUG_FG_BLUE")]
        const FG_BLUE = ffi::GST_DEBUG_FG_BLUE as u32;
        #[doc(alias = "GST_DEBUG_FG_MAGENTA")]
        const FG_MAGENTA = ffi::GST_DEBUG_FG_MAGENTA as u32;
        #[doc(alias = "GST_DEBUG_FG_CYAN")]
        const FG_CYAN = ffi::GST_DEBUG_FG_CYAN as u32;
        #[doc(alias = "GST_DEBUG_FG_WHITE")]
        const FG_WHITE = ffi::GST_DEBUG_FG_WHITE as u32;
        #[doc(alias = "GST_DEBUG_BG_BLACK")]
        const BG_BLACK = ffi::GST_DEBUG_BG_BLACK as u32;
        #[doc(alias = "GST_DEBUG_BG_RED")]
        const BG_RED = ffi::GST_DEBUG_BG_RED as u32;
        #[doc(alias = "GST_DEBUG_BG_GREEN")]
        const BG_GREEN = ffi::GST_DEBUG_BG_GREEN as u32;
        #[doc(alias = "GST_DEBUG_BG_YELLOW")]
        const BG_YELLOW = ffi::GST_DEBUG_BG_YELLOW as u32;
        #[doc(alias = "GST_DEBUG_BG_BLUE")]
        const BG_BLUE = ffi::GST_DEBUG_BG_BLUE as u32;
        #[doc(alias = "GST_DEBUG_BG_MAGENTA")]
        const BG_MAGENTA = ffi::GST_DEBUG_BG_MAGENTA as u32;
        #[doc(alias = "GST_DEBUG_BG_CYAN")]
        const BG_CYAN = ffi::GST_DEBUG_BG_CYAN as u32;
        #[doc(alias = "GST_DEBUG_BG_WHITE")]
        const BG_WHITE = ffi::GST_DEBUG_BG_WHITE as u32;
        #[doc(alias = "GST_DEBUG_BOLD")]
        const BOLD = ffi::GST_DEBUG_BOLD as u32;
        #[doc(alias = "GST_DEBUG_UNDERLINE")]
        const UNDERLINE = ffi::GST_DEBUG_UNDERLINE as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for DebugColorFlags {
    type GlibType = ffi::GstDebugColorFlags;

    fn into_glib(self) -> ffi::GstDebugColorFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstDebugColorFlags> for DebugColorFlags {
    unsafe fn from_glib(value: ffi::GstDebugColorFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DebugColorFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_debug_color_flags_get_type()) }
    }
}

impl glib::value::ValueType for DebugColorFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DebugColorFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DebugColorFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstDebugGraphDetails")]
    pub struct DebugGraphDetails: u32 {
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE")]
        const MEDIA_TYPE = ffi::GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE as u32;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS")]
        const CAPS_DETAILS = ffi::GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS as u32;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS")]
        const NON_DEFAULT_PARAMS = ffi::GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS as u32;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_STATES")]
        const STATES = ffi::GST_DEBUG_GRAPH_SHOW_STATES as u32;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_FULL_PARAMS")]
        const FULL_PARAMS = ffi::GST_DEBUG_GRAPH_SHOW_FULL_PARAMS as u32;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_ALL")]
        const ALL = ffi::GST_DEBUG_GRAPH_SHOW_ALL as u32;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_VERBOSE")]
        const VERBOSE = ffi::GST_DEBUG_GRAPH_SHOW_VERBOSE as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for DebugGraphDetails {
    type GlibType = ffi::GstDebugGraphDetails;

    fn into_glib(self) -> ffi::GstDebugGraphDetails {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstDebugGraphDetails> for DebugGraphDetails {
    unsafe fn from_glib(value: ffi::GstDebugGraphDetails) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DebugGraphDetails {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_debug_graph_details_get_type()) }
    }
}

impl glib::value::ValueType for DebugGraphDetails {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DebugGraphDetails {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DebugGraphDetails {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstElementFlags")]
    pub struct ElementFlags: u32 {
        #[doc(alias = "GST_ELEMENT_FLAG_LOCKED_STATE")]
        const LOCKED_STATE = ffi::GST_ELEMENT_FLAG_LOCKED_STATE as u32;
        #[doc(alias = "GST_ELEMENT_FLAG_SINK")]
        const SINK = ffi::GST_ELEMENT_FLAG_SINK as u32;
        #[doc(alias = "GST_ELEMENT_FLAG_SOURCE")]
        const SOURCE = ffi::GST_ELEMENT_FLAG_SOURCE as u32;
        #[doc(alias = "GST_ELEMENT_FLAG_PROVIDE_CLOCK")]
        const PROVIDE_CLOCK = ffi::GST_ELEMENT_FLAG_PROVIDE_CLOCK as u32;
        #[doc(alias = "GST_ELEMENT_FLAG_REQUIRE_CLOCK")]
        const REQUIRE_CLOCK = ffi::GST_ELEMENT_FLAG_REQUIRE_CLOCK as u32;
        #[doc(alias = "GST_ELEMENT_FLAG_INDEXABLE")]
        const INDEXABLE = ffi::GST_ELEMENT_FLAG_INDEXABLE as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for ElementFlags {
    type GlibType = ffi::GstElementFlags;

    fn into_glib(self) -> ffi::GstElementFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstElementFlags> for ElementFlags {
    unsafe fn from_glib(value: ffi::GstElementFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ElementFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_element_flags_get_type()) }
    }
}

impl glib::value::ValueType for ElementFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ElementFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ElementFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstEventTypeFlags")]
    pub struct EventTypeFlags: u32 {
        #[doc(alias = "GST_EVENT_TYPE_UPSTREAM")]
        const UPSTREAM = ffi::GST_EVENT_TYPE_UPSTREAM as u32;
        #[doc(alias = "GST_EVENT_TYPE_DOWNSTREAM")]
        const DOWNSTREAM = ffi::GST_EVENT_TYPE_DOWNSTREAM as u32;
        #[doc(alias = "GST_EVENT_TYPE_SERIALIZED")]
        const SERIALIZED = ffi::GST_EVENT_TYPE_SERIALIZED as u32;
        #[doc(alias = "GST_EVENT_TYPE_STICKY")]
        const STICKY = ffi::GST_EVENT_TYPE_STICKY as u32;
        #[doc(alias = "GST_EVENT_TYPE_STICKY_MULTI")]
        const STICKY_MULTI = ffi::GST_EVENT_TYPE_STICKY_MULTI as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for EventTypeFlags {
    type GlibType = ffi::GstEventTypeFlags;

    fn into_glib(self) -> ffi::GstEventTypeFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstEventTypeFlags> for EventTypeFlags {
    unsafe fn from_glib(value: ffi::GstEventTypeFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for EventTypeFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_event_type_flags_get_type()) }
    }
}

impl glib::value::ValueType for EventTypeFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for EventTypeFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for EventTypeFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    #[doc(alias = "GstGapFlags")]
    pub struct GapFlags: u32 {
        #[doc(alias = "GST_GAP_FLAG_MISSING_DATA")]
        const DATA = ffi::GST_GAP_FLAG_MISSING_DATA as u32;
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl IntoGlib for GapFlags {
    type GlibType = ffi::GstGapFlags;

    fn into_glib(self) -> ffi::GstGapFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl FromGlib<ffi::GstGapFlags> for GapFlags {
    unsafe fn from_glib(value: ffi::GstGapFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
impl StaticType for GapFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_gap_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
impl glib::value::ValueType for GapFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
unsafe impl<'a> FromValue<'a> for GapFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
impl ToValue for GapFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstMemoryFlags")]
    pub struct MemoryFlags: u32 {
        #[doc(alias = "GST_MEMORY_FLAG_READONLY")]
        const READONLY = ffi::GST_MEMORY_FLAG_READONLY as u32;
        #[doc(alias = "GST_MEMORY_FLAG_NO_SHARE")]
        const NO_SHARE = ffi::GST_MEMORY_FLAG_NO_SHARE as u32;
        #[doc(alias = "GST_MEMORY_FLAG_ZERO_PREFIXED")]
        const ZERO_PREFIXED = ffi::GST_MEMORY_FLAG_ZERO_PREFIXED as u32;
        #[doc(alias = "GST_MEMORY_FLAG_ZERO_PADDED")]
        const ZERO_PADDED = ffi::GST_MEMORY_FLAG_ZERO_PADDED as u32;
        #[doc(alias = "GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS")]
        const PHYSICALLY_CONTIGUOUS = ffi::GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS as u32;
        #[doc(alias = "GST_MEMORY_FLAG_NOT_MAPPABLE")]
        const NOT_MAPPABLE = ffi::GST_MEMORY_FLAG_NOT_MAPPABLE as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for MemoryFlags {
    type GlibType = ffi::GstMemoryFlags;

    fn into_glib(self) -> ffi::GstMemoryFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstMemoryFlags> for MemoryFlags {
    unsafe fn from_glib(value: ffi::GstMemoryFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for MemoryFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_memory_flags_get_type()) }
    }
}

impl glib::value::ValueType for MemoryFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for MemoryFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for MemoryFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstObjectFlags")]
    pub struct ObjectFlags: u32 {
        #[cfg(any(feature = "v1_10", feature = "dox"))]
        #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
        #[doc(alias = "GST_OBJECT_FLAG_MAY_BE_LEAKED")]
        const MAY_BE_LEAKED = ffi::GST_OBJECT_FLAG_MAY_BE_LEAKED as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for ObjectFlags {
    type GlibType = ffi::GstObjectFlags;

    fn into_glib(self) -> ffi::GstObjectFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstObjectFlags> for ObjectFlags {
    unsafe fn from_glib(value: ffi::GstObjectFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ObjectFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_object_flags_get_type()) }
    }
}

impl glib::value::ValueType for ObjectFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ObjectFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ObjectFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstPadFlags")]
    pub struct PadFlags: u32 {
        #[doc(alias = "GST_PAD_FLAG_BLOCKED")]
        const BLOCKED = ffi::GST_PAD_FLAG_BLOCKED as u32;
        #[doc(alias = "GST_PAD_FLAG_FLUSHING")]
        const FLUSHING = ffi::GST_PAD_FLAG_FLUSHING as u32;
        #[doc(alias = "GST_PAD_FLAG_EOS")]
        const EOS = ffi::GST_PAD_FLAG_EOS as u32;
        #[doc(alias = "GST_PAD_FLAG_BLOCKING")]
        const BLOCKING = ffi::GST_PAD_FLAG_BLOCKING as u32;
        #[doc(alias = "GST_PAD_FLAG_NEED_PARENT")]
        const NEED_PARENT = ffi::GST_PAD_FLAG_NEED_PARENT as u32;
        #[doc(alias = "GST_PAD_FLAG_NEED_RECONFIGURE")]
        const NEED_RECONFIGURE = ffi::GST_PAD_FLAG_NEED_RECONFIGURE as u32;
        #[doc(alias = "GST_PAD_FLAG_PENDING_EVENTS")]
        const PENDING_EVENTS = ffi::GST_PAD_FLAG_PENDING_EVENTS as u32;
        #[doc(alias = "GST_PAD_FLAG_FIXED_CAPS")]
        const FIXED_CAPS = ffi::GST_PAD_FLAG_FIXED_CAPS as u32;
        #[doc(alias = "GST_PAD_FLAG_PROXY_CAPS")]
        const PROXY_CAPS = ffi::GST_PAD_FLAG_PROXY_CAPS as u32;
        #[doc(alias = "GST_PAD_FLAG_PROXY_ALLOCATION")]
        const PROXY_ALLOCATION = ffi::GST_PAD_FLAG_PROXY_ALLOCATION as u32;
        #[doc(alias = "GST_PAD_FLAG_PROXY_SCHEDULING")]
        const PROXY_SCHEDULING = ffi::GST_PAD_FLAG_PROXY_SCHEDULING as u32;
        #[doc(alias = "GST_PAD_FLAG_ACCEPT_INTERSECT")]
        const ACCEPT_INTERSECT = ffi::GST_PAD_FLAG_ACCEPT_INTERSECT as u32;
        #[doc(alias = "GST_PAD_FLAG_ACCEPT_TEMPLATE")]
        const ACCEPT_TEMPLATE = ffi::GST_PAD_FLAG_ACCEPT_TEMPLATE as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for PadFlags {
    type GlibType = ffi::GstPadFlags;

    fn into_glib(self) -> ffi::GstPadFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPadFlags> for PadFlags {
    unsafe fn from_glib(value: ffi::GstPadFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PadFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_pad_flags_get_type()) }
    }
}

impl glib::value::ValueType for PadFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PadFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PadFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstPadLinkCheck")]
    pub struct PadLinkCheck: u32 {
        #[doc(alias = "GST_PAD_LINK_CHECK_HIERARCHY")]
        const HIERARCHY = ffi::GST_PAD_LINK_CHECK_HIERARCHY as u32;
        #[doc(alias = "GST_PAD_LINK_CHECK_TEMPLATE_CAPS")]
        const TEMPLATE_CAPS = ffi::GST_PAD_LINK_CHECK_TEMPLATE_CAPS as u32;
        #[doc(alias = "GST_PAD_LINK_CHECK_CAPS")]
        const CAPS = ffi::GST_PAD_LINK_CHECK_CAPS as u32;
        #[doc(alias = "GST_PAD_LINK_CHECK_NO_RECONFIGURE")]
        const NO_RECONFIGURE = ffi::GST_PAD_LINK_CHECK_NO_RECONFIGURE as u32;
        #[doc(alias = "GST_PAD_LINK_CHECK_DEFAULT")]
        const DEFAULT = ffi::GST_PAD_LINK_CHECK_DEFAULT as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for PadLinkCheck {
    type GlibType = ffi::GstPadLinkCheck;

    fn into_glib(self) -> ffi::GstPadLinkCheck {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPadLinkCheck> for PadLinkCheck {
    unsafe fn from_glib(value: ffi::GstPadLinkCheck) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PadLinkCheck {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_pad_link_check_get_type()) }
    }
}

impl glib::value::ValueType for PadLinkCheck {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PadLinkCheck {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PadLinkCheck {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstPadProbeType")]
    pub struct PadProbeType: u32 {
        #[doc(alias = "GST_PAD_PROBE_TYPE_IDLE")]
        const IDLE = ffi::GST_PAD_PROBE_TYPE_IDLE as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BLOCK")]
        const BLOCK = ffi::GST_PAD_PROBE_TYPE_BLOCK as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BUFFER")]
        const BUFFER = ffi::GST_PAD_PROBE_TYPE_BUFFER as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BUFFER_LIST")]
        const BUFFER_LIST = ffi::GST_PAD_PROBE_TYPE_BUFFER_LIST as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM")]
        const EVENT_DOWNSTREAM = ffi::GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_EVENT_UPSTREAM")]
        const EVENT_UPSTREAM = ffi::GST_PAD_PROBE_TYPE_EVENT_UPSTREAM as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_EVENT_FLUSH")]
        const EVENT_FLUSH = ffi::GST_PAD_PROBE_TYPE_EVENT_FLUSH as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM")]
        const QUERY_DOWNSTREAM = ffi::GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_QUERY_UPSTREAM")]
        const QUERY_UPSTREAM = ffi::GST_PAD_PROBE_TYPE_QUERY_UPSTREAM as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_PUSH")]
        const PUSH = ffi::GST_PAD_PROBE_TYPE_PUSH as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_PULL")]
        const PULL = ffi::GST_PAD_PROBE_TYPE_PULL as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BLOCKING")]
        const BLOCKING = ffi::GST_PAD_PROBE_TYPE_BLOCKING as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM")]
        const DATA_DOWNSTREAM = ffi::GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_DATA_UPSTREAM")]
        const DATA_UPSTREAM = ffi::GST_PAD_PROBE_TYPE_DATA_UPSTREAM as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_DATA_BOTH")]
        const DATA_BOTH = ffi::GST_PAD_PROBE_TYPE_DATA_BOTH as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM")]
        const BLOCK_DOWNSTREAM = ffi::GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM")]
        const BLOCK_UPSTREAM = ffi::GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_EVENT_BOTH")]
        const EVENT_BOTH = ffi::GST_PAD_PROBE_TYPE_EVENT_BOTH as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_QUERY_BOTH")]
        const QUERY_BOTH = ffi::GST_PAD_PROBE_TYPE_QUERY_BOTH as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_ALL_BOTH")]
        const ALL_BOTH = ffi::GST_PAD_PROBE_TYPE_ALL_BOTH as u32;
        #[doc(alias = "GST_PAD_PROBE_TYPE_SCHEDULING")]
        const SCHEDULING = ffi::GST_PAD_PROBE_TYPE_SCHEDULING as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for PadProbeType {
    type GlibType = ffi::GstPadProbeType;

    fn into_glib(self) -> ffi::GstPadProbeType {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPadProbeType> for PadProbeType {
    unsafe fn from_glib(value: ffi::GstPadProbeType) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PadProbeType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_pad_probe_type_get_type()) }
    }
}

impl glib::value::ValueType for PadProbeType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PadProbeType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PadProbeType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstParseFlags")]
    pub struct ParseFlags: u32 {
        #[doc(alias = "GST_PARSE_FLAG_FATAL_ERRORS")]
        const FATAL_ERRORS = ffi::GST_PARSE_FLAG_FATAL_ERRORS as u32;
        #[doc(alias = "GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS")]
        const NO_SINGLE_ELEMENT_BINS = ffi::GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS as u32;
        #[cfg(any(feature = "v1_10", feature = "dox"))]
        #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
        #[doc(alias = "GST_PARSE_FLAG_PLACE_IN_BIN")]
        const PLACE_IN_BIN = ffi::GST_PARSE_FLAG_PLACE_IN_BIN as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for ParseFlags {
    type GlibType = ffi::GstParseFlags;

    fn into_glib(self) -> ffi::GstParseFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstParseFlags> for ParseFlags {
    unsafe fn from_glib(value: ffi::GstParseFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ParseFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_parse_flags_get_type()) }
    }
}

impl glib::value::ValueType for ParseFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ParseFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ParseFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstPipelineFlags")]
    pub struct PipelineFlags: u32 {
        #[doc(alias = "GST_PIPELINE_FLAG_FIXED_CLOCK")]
        const FIXED_CLOCK = ffi::GST_PIPELINE_FLAG_FIXED_CLOCK as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for PipelineFlags {
    type GlibType = ffi::GstPipelineFlags;

    fn into_glib(self) -> ffi::GstPipelineFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPipelineFlags> for PipelineFlags {
    unsafe fn from_glib(value: ffi::GstPipelineFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PipelineFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_pipeline_flags_get_type()) }
    }
}

impl glib::value::ValueType for PipelineFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PipelineFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PipelineFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    #[doc(alias = "GstPluginAPIFlags")]
    pub struct PluginAPIFlags: u32 {
        #[doc(alias = "GST_PLUGIN_API_FLAG_IGNORE_ENUM_MEMBERS")]
        const MEMBERS = ffi::GST_PLUGIN_API_FLAG_IGNORE_ENUM_MEMBERS as u32;
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
#[doc(hidden)]
impl IntoGlib for PluginAPIFlags {
    type GlibType = ffi::GstPluginAPIFlags;

    fn into_glib(self) -> ffi::GstPluginAPIFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
#[doc(hidden)]
impl FromGlib<ffi::GstPluginAPIFlags> for PluginAPIFlags {
    unsafe fn from_glib(value: ffi::GstPluginAPIFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
impl StaticType for PluginAPIFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_plugin_api_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
impl glib::value::ValueType for PluginAPIFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
unsafe impl<'a> FromValue<'a> for PluginAPIFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
impl ToValue for PluginAPIFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstPluginDependencyFlags")]
    pub struct PluginDependencyFlags: u32 {
        #[doc(alias = "GST_PLUGIN_DEPENDENCY_FLAG_RECURSE")]
        const RECURSE = ffi::GST_PLUGIN_DEPENDENCY_FLAG_RECURSE as u32;
        #[doc(alias = "GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY")]
        const PATHS_ARE_DEFAULT_ONLY = ffi::GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY as u32;
        #[doc(alias = "GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX")]
        const FILE_NAME_IS_SUFFIX = ffi::GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX as u32;
        #[doc(alias = "GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX")]
        const FILE_NAME_IS_PREFIX = ffi::GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX as u32;
        #[doc(alias = "GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_RELATIVE_TO_EXE")]
        const PATHS_ARE_RELATIVE_TO_EXE = ffi::GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_RELATIVE_TO_EXE as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for PluginDependencyFlags {
    type GlibType = ffi::GstPluginDependencyFlags;

    fn into_glib(self) -> ffi::GstPluginDependencyFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPluginDependencyFlags> for PluginDependencyFlags {
    unsafe fn from_glib(value: ffi::GstPluginDependencyFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PluginDependencyFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_plugin_dependency_flags_get_type()) }
    }
}

impl glib::value::ValueType for PluginDependencyFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PluginDependencyFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PluginDependencyFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstPluginFlags")]
    pub struct PluginFlags: u32 {
        #[doc(alias = "GST_PLUGIN_FLAG_CACHED")]
        const CACHED = ffi::GST_PLUGIN_FLAG_CACHED as u32;
        #[doc(alias = "GST_PLUGIN_FLAG_BLACKLISTED")]
        const BLACKLISTED = ffi::GST_PLUGIN_FLAG_BLACKLISTED as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for PluginFlags {
    type GlibType = ffi::GstPluginFlags;

    fn into_glib(self) -> ffi::GstPluginFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPluginFlags> for PluginFlags {
    unsafe fn from_glib(value: ffi::GstPluginFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PluginFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_plugin_flags_get_type()) }
    }
}

impl glib::value::ValueType for PluginFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PluginFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PluginFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstSchedulingFlags")]
    pub struct SchedulingFlags: u32 {
        #[doc(alias = "GST_SCHEDULING_FLAG_SEEKABLE")]
        const SEEKABLE = ffi::GST_SCHEDULING_FLAG_SEEKABLE as u32;
        #[doc(alias = "GST_SCHEDULING_FLAG_SEQUENTIAL")]
        const SEQUENTIAL = ffi::GST_SCHEDULING_FLAG_SEQUENTIAL as u32;
        #[doc(alias = "GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED")]
        const BANDWIDTH_LIMITED = ffi::GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for SchedulingFlags {
    type GlibType = ffi::GstSchedulingFlags;

    fn into_glib(self) -> ffi::GstSchedulingFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstSchedulingFlags> for SchedulingFlags {
    unsafe fn from_glib(value: ffi::GstSchedulingFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SchedulingFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_scheduling_flags_get_type()) }
    }
}

impl glib::value::ValueType for SchedulingFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SchedulingFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SchedulingFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstSeekFlags")]
    pub struct SeekFlags: u32 {
        #[doc(alias = "GST_SEEK_FLAG_FLUSH")]
        const FLUSH = ffi::GST_SEEK_FLAG_FLUSH as u32;
        #[doc(alias = "GST_SEEK_FLAG_ACCURATE")]
        const ACCURATE = ffi::GST_SEEK_FLAG_ACCURATE as u32;
        #[doc(alias = "GST_SEEK_FLAG_KEY_UNIT")]
        const KEY_UNIT = ffi::GST_SEEK_FLAG_KEY_UNIT as u32;
        #[doc(alias = "GST_SEEK_FLAG_SEGMENT")]
        const SEGMENT = ffi::GST_SEEK_FLAG_SEGMENT as u32;
        #[doc(alias = "GST_SEEK_FLAG_TRICKMODE")]
        const TRICKMODE = ffi::GST_SEEK_FLAG_TRICKMODE as u32;
        #[doc(alias = "GST_SEEK_FLAG_SKIP")]
        const SKIP = ffi::GST_SEEK_FLAG_SKIP as u32;
        #[doc(alias = "GST_SEEK_FLAG_SNAP_BEFORE")]
        const SNAP_BEFORE = ffi::GST_SEEK_FLAG_SNAP_BEFORE as u32;
        #[doc(alias = "GST_SEEK_FLAG_SNAP_AFTER")]
        const SNAP_AFTER = ffi::GST_SEEK_FLAG_SNAP_AFTER as u32;
        #[doc(alias = "GST_SEEK_FLAG_SNAP_NEAREST")]
        const SNAP_NEAREST = ffi::GST_SEEK_FLAG_SNAP_NEAREST as u32;
        #[doc(alias = "GST_SEEK_FLAG_TRICKMODE_KEY_UNITS")]
        const TRICKMODE_KEY_UNITS = ffi::GST_SEEK_FLAG_TRICKMODE_KEY_UNITS as u32;
        #[doc(alias = "GST_SEEK_FLAG_TRICKMODE_NO_AUDIO")]
        const TRICKMODE_NO_AUDIO = ffi::GST_SEEK_FLAG_TRICKMODE_NO_AUDIO as u32;
        #[cfg(any(feature = "v1_18", feature = "dox"))]
        #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
        #[doc(alias = "GST_SEEK_FLAG_TRICKMODE_FORWARD_PREDICTED")]
        const TRICKMODE_FORWARD_PREDICTED = ffi::GST_SEEK_FLAG_TRICKMODE_FORWARD_PREDICTED as u32;
        #[cfg(any(feature = "v1_18", feature = "dox"))]
        #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
        #[doc(alias = "GST_SEEK_FLAG_INSTANT_RATE_CHANGE")]
        const INSTANT_RATE_CHANGE = ffi::GST_SEEK_FLAG_INSTANT_RATE_CHANGE as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for SeekFlags {
    type GlibType = ffi::GstSeekFlags;

    fn into_glib(self) -> ffi::GstSeekFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstSeekFlags> for SeekFlags {
    unsafe fn from_glib(value: ffi::GstSeekFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SeekFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_seek_flags_get_type()) }
    }
}

impl glib::value::ValueType for SeekFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SeekFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SeekFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[cfg_attr(feature = "ser_de", derive(serde::Serialize, serde::Deserialize))]
    #[doc(alias = "GstSegmentFlags")]
    pub struct SegmentFlags: u32 {
        #[doc(alias = "GST_SEGMENT_FLAG_RESET")]
        const RESET = ffi::GST_SEGMENT_FLAG_RESET as u32;
        #[doc(alias = "GST_SEGMENT_FLAG_TRICKMODE")]
        const TRICKMODE = ffi::GST_SEGMENT_FLAG_TRICKMODE as u32;
        #[doc(alias = "GST_SEGMENT_FLAG_SKIP")]
        const SKIP = ffi::GST_SEGMENT_FLAG_SKIP as u32;
        #[doc(alias = "GST_SEGMENT_FLAG_SEGMENT")]
        const SEGMENT = ffi::GST_SEGMENT_FLAG_SEGMENT as u32;
        #[doc(alias = "GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS")]
        const TRICKMODE_KEY_UNITS = ffi::GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS as u32;
        #[cfg(any(feature = "v1_18", feature = "dox"))]
        #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
        #[doc(alias = "GST_SEGMENT_FLAG_TRICKMODE_FORWARD_PREDICTED")]
        const TRICKMODE_FORWARD_PREDICTED = ffi::GST_SEGMENT_FLAG_TRICKMODE_FORWARD_PREDICTED as u32;
        #[doc(alias = "GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO")]
        const TRICKMODE_NO_AUDIO = ffi::GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for SegmentFlags {
    type GlibType = ffi::GstSegmentFlags;

    fn into_glib(self) -> ffi::GstSegmentFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstSegmentFlags> for SegmentFlags {
    unsafe fn from_glib(value: ffi::GstSegmentFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SegmentFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_segment_flags_get_type()) }
    }
}

impl glib::value::ValueType for SegmentFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SegmentFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SegmentFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    #[doc(alias = "GstSerializeFlags")]
    pub struct SerializeFlags: u32 {
        #[doc(alias = "GST_SERIALIZE_FLAG_NONE")]
        const NONE = ffi::GST_SERIALIZE_FLAG_NONE as u32;
        #[doc(alias = "GST_SERIALIZE_FLAG_BACKWARD_COMPAT")]
        const BACKWARD_COMPAT = ffi::GST_SERIALIZE_FLAG_BACKWARD_COMPAT as u32;
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl IntoGlib for SerializeFlags {
    type GlibType = ffi::GstSerializeFlags;

    fn into_glib(self) -> ffi::GstSerializeFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl FromGlib<ffi::GstSerializeFlags> for SerializeFlags {
    unsafe fn from_glib(value: ffi::GstSerializeFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
impl StaticType for SerializeFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_serialize_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
impl glib::value::ValueType for SerializeFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
unsafe impl<'a> FromValue<'a> for SerializeFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
impl ToValue for SerializeFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
    #[doc(alias = "GstStackTraceFlags")]
    pub struct StackTraceFlags: u32 {
        #[doc(alias = "GST_STACK_TRACE_SHOW_FULL")]
        const FULL = ffi::GST_STACK_TRACE_SHOW_FULL as u32;
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl IntoGlib for StackTraceFlags {
    type GlibType = ffi::GstStackTraceFlags;

    fn into_glib(self) -> ffi::GstStackTraceFlags {
        self.bits()
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
#[doc(hidden)]
impl FromGlib<ffi::GstStackTraceFlags> for StackTraceFlags {
    unsafe fn from_glib(value: ffi::GstStackTraceFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl StaticType for StackTraceFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_stack_trace_flags_get_type()) }
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl glib::value::ValueType for StackTraceFlags {
    type Type = Self;
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
unsafe impl<'a> FromValue<'a> for StackTraceFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_12")))]
impl ToValue for StackTraceFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GstStreamFlags")]
    pub struct StreamFlags: u32 {
        #[doc(alias = "GST_STREAM_FLAG_SPARSE")]
        const SPARSE = ffi::GST_STREAM_FLAG_SPARSE as u32;
        #[doc(alias = "GST_STREAM_FLAG_SELECT")]
        const SELECT = ffi::GST_STREAM_FLAG_SELECT as u32;
        #[doc(alias = "GST_STREAM_FLAG_UNSELECT")]
        const UNSELECT = ffi::GST_STREAM_FLAG_UNSELECT as u32;
    }
}

#[doc(hidden)]
impl IntoGlib for StreamFlags {
    type GlibType = ffi::GstStreamFlags;

    fn into_glib(self) -> ffi::GstStreamFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstStreamFlags> for StreamFlags {
    unsafe fn from_glib(value: ffi::GstStreamFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for StreamFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_stream_flags_get_type()) }
    }
}

impl glib::value::ValueType for StreamFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for StreamFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for StreamFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    #[doc(alias = "GstStreamType")]
    pub struct StreamType: u32 {
        #[doc(alias = "GST_STREAM_TYPE_UNKNOWN")]
        const UNKNOWN = ffi::GST_STREAM_TYPE_UNKNOWN as u32;
        #[doc(alias = "GST_STREAM_TYPE_AUDIO")]
        const AUDIO = ffi::GST_STREAM_TYPE_AUDIO as u32;
        #[doc(alias = "GST_STREAM_TYPE_VIDEO")]
        const VIDEO = ffi::GST_STREAM_TYPE_VIDEO as u32;
        #[doc(alias = "GST_STREAM_TYPE_CONTAINER")]
        const CONTAINER = ffi::GST_STREAM_TYPE_CONTAINER as u32;
        #[doc(alias = "GST_STREAM_TYPE_TEXT")]
        const TEXT = ffi::GST_STREAM_TYPE_TEXT as u32;
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl StreamType {
    pub fn name<'a>(self) -> &'a str {
        unsafe {
            CStr::from_ptr(
                ffi::gst_stream_type_get_name(self.into_glib())
                    .as_ref()
                    .expect("gst_stream_type_get_name returned NULL"),
            )
            .to_str()
            .expect("gst_stream_type_get_name returned an invalid string")
        }
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl fmt::Display for StreamType {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str(&self.name())
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl IntoGlib for StreamType {
    type GlibType = ffi::GstStreamType;

    fn into_glib(self) -> ffi::GstStreamType {
        self.bits()
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
#[doc(hidden)]
impl FromGlib<ffi::GstStreamType> for StreamType {
    unsafe fn from_glib(value: ffi::GstStreamType) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl StaticType for StreamType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_stream_type_get_type()) }
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl glib::value::ValueType for StreamType {
    type Type = Self;
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
unsafe impl<'a> FromValue<'a> for StreamType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
impl ToValue for StreamType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
