// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// from gst-gir-files (https://gitlab.freedesktop.org/gstreamer/gir-files-rs.git)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal,
    clippy::upper_case_acronyms
)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]

#[allow(unused_imports)]
use libc::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
    intptr_t, size_t, ssize_t, uintptr_t, FILE,
};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Aliases
pub type GstBufferMapInfo = GstMapInfo;
pub type GstClockID = gpointer;
pub type GstClockTime = u64;
pub type GstClockTimeDiff = i64;
pub type GstElementFactoryListType = u64;
pub type GstMemoryMapInfo = GstMapInfo;

// Enums
pub type GstBufferingMode = c_int;
pub const GST_BUFFERING_STREAM: GstBufferingMode = 0;
pub const GST_BUFFERING_DOWNLOAD: GstBufferingMode = 1;
pub const GST_BUFFERING_TIMESHIFT: GstBufferingMode = 2;
pub const GST_BUFFERING_LIVE: GstBufferingMode = 3;

pub type GstBusSyncReply = c_int;
pub const GST_BUS_DROP: GstBusSyncReply = 0;
pub const GST_BUS_PASS: GstBusSyncReply = 1;
pub const GST_BUS_ASYNC: GstBusSyncReply = 2;

pub type GstCapsIntersectMode = c_int;
pub const GST_CAPS_INTERSECT_ZIG_ZAG: GstCapsIntersectMode = 0;
pub const GST_CAPS_INTERSECT_FIRST: GstCapsIntersectMode = 1;

pub type GstClockEntryType = c_int;
pub const GST_CLOCK_ENTRY_SINGLE: GstClockEntryType = 0;
pub const GST_CLOCK_ENTRY_PERIODIC: GstClockEntryType = 1;

pub type GstClockReturn = c_int;
pub const GST_CLOCK_OK: GstClockReturn = 0;
pub const GST_CLOCK_EARLY: GstClockReturn = 1;
pub const GST_CLOCK_UNSCHEDULED: GstClockReturn = 2;
pub const GST_CLOCK_BUSY: GstClockReturn = 3;
pub const GST_CLOCK_BADTIME: GstClockReturn = 4;
pub const GST_CLOCK_ERROR: GstClockReturn = 5;
pub const GST_CLOCK_UNSUPPORTED: GstClockReturn = 6;
pub const GST_CLOCK_DONE: GstClockReturn = 7;

pub type GstClockType = c_int;
pub const GST_CLOCK_TYPE_REALTIME: GstClockType = 0;
pub const GST_CLOCK_TYPE_MONOTONIC: GstClockType = 1;
pub const GST_CLOCK_TYPE_OTHER: GstClockType = 2;
pub const GST_CLOCK_TYPE_TAI: GstClockType = 3;

pub type GstCoreError = c_int;
pub const GST_CORE_ERROR_FAILED: GstCoreError = 1;
pub const GST_CORE_ERROR_TOO_LAZY: GstCoreError = 2;
pub const GST_CORE_ERROR_NOT_IMPLEMENTED: GstCoreError = 3;
pub const GST_CORE_ERROR_STATE_CHANGE: GstCoreError = 4;
pub const GST_CORE_ERROR_PAD: GstCoreError = 5;
pub const GST_CORE_ERROR_THREAD: GstCoreError = 6;
pub const GST_CORE_ERROR_NEGOTIATION: GstCoreError = 7;
pub const GST_CORE_ERROR_EVENT: GstCoreError = 8;
pub const GST_CORE_ERROR_SEEK: GstCoreError = 9;
pub const GST_CORE_ERROR_CAPS: GstCoreError = 10;
pub const GST_CORE_ERROR_TAG: GstCoreError = 11;
pub const GST_CORE_ERROR_MISSING_PLUGIN: GstCoreError = 12;
pub const GST_CORE_ERROR_CLOCK: GstCoreError = 13;
pub const GST_CORE_ERROR_DISABLED: GstCoreError = 14;
pub const GST_CORE_ERROR_NUM_ERRORS: GstCoreError = 15;

pub type GstDebugColorMode = c_int;
pub const GST_DEBUG_COLOR_MODE_OFF: GstDebugColorMode = 0;
pub const GST_DEBUG_COLOR_MODE_ON: GstDebugColorMode = 1;
pub const GST_DEBUG_COLOR_MODE_UNIX: GstDebugColorMode = 2;

pub type GstDebugLevel = c_int;
pub const GST_LEVEL_NONE: GstDebugLevel = 0;
pub const GST_LEVEL_ERROR: GstDebugLevel = 1;
pub const GST_LEVEL_WARNING: GstDebugLevel = 2;
pub const GST_LEVEL_FIXME: GstDebugLevel = 3;
pub const GST_LEVEL_INFO: GstDebugLevel = 4;
pub const GST_LEVEL_DEBUG: GstDebugLevel = 5;
pub const GST_LEVEL_LOG: GstDebugLevel = 6;
pub const GST_LEVEL_TRACE: GstDebugLevel = 7;
pub const GST_LEVEL_MEMDUMP: GstDebugLevel = 9;
pub const GST_LEVEL_COUNT: GstDebugLevel = 10;

pub type GstEventType = c_int;
pub const GST_EVENT_UNKNOWN: GstEventType = 0;
pub const GST_EVENT_FLUSH_START: GstEventType = 2563;
pub const GST_EVENT_FLUSH_STOP: GstEventType = 5127;
pub const GST_EVENT_STREAM_START: GstEventType = 10254;
pub const GST_EVENT_CAPS: GstEventType = 12814;
pub const GST_EVENT_SEGMENT: GstEventType = 17934;
pub const GST_EVENT_STREAM_COLLECTION: GstEventType = 19230;
pub const GST_EVENT_TAG: GstEventType = 20510;
pub const GST_EVENT_BUFFERSIZE: GstEventType = 23054;
pub const GST_EVENT_SINK_MESSAGE: GstEventType = 25630;
pub const GST_EVENT_STREAM_GROUP_DONE: GstEventType = 26894;
pub const GST_EVENT_EOS: GstEventType = 28174;
pub const GST_EVENT_TOC: GstEventType = 30750;
pub const GST_EVENT_PROTECTION: GstEventType = 33310;
pub const GST_EVENT_SEGMENT_DONE: GstEventType = 38406;
pub const GST_EVENT_GAP: GstEventType = 40966;
pub const GST_EVENT_INSTANT_RATE_CHANGE: GstEventType = 46090;
pub const GST_EVENT_QOS: GstEventType = 48641;
pub const GST_EVENT_SEEK: GstEventType = 51201;
pub const GST_EVENT_NAVIGATION: GstEventType = 53761;
pub const GST_EVENT_LATENCY: GstEventType = 56321;
pub const GST_EVENT_STEP: GstEventType = 58881;
pub const GST_EVENT_RECONFIGURE: GstEventType = 61441;
pub const GST_EVENT_TOC_SELECT: GstEventType = 64001;
pub const GST_EVENT_SELECT_STREAMS: GstEventType = 66561;
pub const GST_EVENT_INSTANT_RATE_SYNC_TIME: GstEventType = 66817;
pub const GST_EVENT_CUSTOM_UPSTREAM: GstEventType = 69121;
pub const GST_EVENT_CUSTOM_DOWNSTREAM: GstEventType = 71686;
pub const GST_EVENT_CUSTOM_DOWNSTREAM_OOB: GstEventType = 74242;
pub const GST_EVENT_CUSTOM_DOWNSTREAM_STICKY: GstEventType = 76830;
pub const GST_EVENT_CUSTOM_BOTH: GstEventType = 79367;
pub const GST_EVENT_CUSTOM_BOTH_OOB: GstEventType = 81923;

pub type GstFlowReturn = c_int;
pub const GST_FLOW_CUSTOM_SUCCESS_2: GstFlowReturn = 102;
pub const GST_FLOW_CUSTOM_SUCCESS_1: GstFlowReturn = 101;
pub const GST_FLOW_CUSTOM_SUCCESS: GstFlowReturn = 100;
pub const GST_FLOW_OK: GstFlowReturn = 0;
pub const GST_FLOW_NOT_LINKED: GstFlowReturn = -1;
pub const GST_FLOW_FLUSHING: GstFlowReturn = -2;
pub const GST_FLOW_EOS: GstFlowReturn = -3;
pub const GST_FLOW_NOT_NEGOTIATED: GstFlowReturn = -4;
pub const GST_FLOW_ERROR: GstFlowReturn = -5;
pub const GST_FLOW_NOT_SUPPORTED: GstFlowReturn = -6;
pub const GST_FLOW_CUSTOM_ERROR: GstFlowReturn = -100;
pub const GST_FLOW_CUSTOM_ERROR_1: GstFlowReturn = -101;
pub const GST_FLOW_CUSTOM_ERROR_2: GstFlowReturn = -102;

pub type GstFormat = c_int;
pub const GST_FORMAT_UNDEFINED: GstFormat = 0;
pub const GST_FORMAT_DEFAULT: GstFormat = 1;
pub const GST_FORMAT_BYTES: GstFormat = 2;
pub const GST_FORMAT_TIME: GstFormat = 3;
pub const GST_FORMAT_BUFFERS: GstFormat = 4;
pub const GST_FORMAT_PERCENT: GstFormat = 5;

pub type GstIteratorItem = c_int;
pub const GST_ITERATOR_ITEM_SKIP: GstIteratorItem = 0;
pub const GST_ITERATOR_ITEM_PASS: GstIteratorItem = 1;
pub const GST_ITERATOR_ITEM_END: GstIteratorItem = 2;

pub type GstIteratorResult = c_int;
pub const GST_ITERATOR_DONE: GstIteratorResult = 0;
pub const GST_ITERATOR_OK: GstIteratorResult = 1;
pub const GST_ITERATOR_RESYNC: GstIteratorResult = 2;
pub const GST_ITERATOR_ERROR: GstIteratorResult = 3;

pub type GstLibraryError = c_int;
pub const GST_LIBRARY_ERROR_FAILED: GstLibraryError = 1;
pub const GST_LIBRARY_ERROR_TOO_LAZY: GstLibraryError = 2;
pub const GST_LIBRARY_ERROR_INIT: GstLibraryError = 3;
pub const GST_LIBRARY_ERROR_SHUTDOWN: GstLibraryError = 4;
pub const GST_LIBRARY_ERROR_SETTINGS: GstLibraryError = 5;
pub const GST_LIBRARY_ERROR_ENCODE: GstLibraryError = 6;
pub const GST_LIBRARY_ERROR_NUM_ERRORS: GstLibraryError = 7;

pub type GstPadDirection = c_int;
pub const GST_PAD_UNKNOWN: GstPadDirection = 0;
pub const GST_PAD_SRC: GstPadDirection = 1;
pub const GST_PAD_SINK: GstPadDirection = 2;

pub type GstPadLinkReturn = c_int;
pub const GST_PAD_LINK_OK: GstPadLinkReturn = 0;
pub const GST_PAD_LINK_WRONG_HIERARCHY: GstPadLinkReturn = -1;
pub const GST_PAD_LINK_WAS_LINKED: GstPadLinkReturn = -2;
pub const GST_PAD_LINK_WRONG_DIRECTION: GstPadLinkReturn = -3;
pub const GST_PAD_LINK_NOFORMAT: GstPadLinkReturn = -4;
pub const GST_PAD_LINK_NOSCHED: GstPadLinkReturn = -5;
pub const GST_PAD_LINK_REFUSED: GstPadLinkReturn = -6;

pub type GstPadMode = c_int;
pub const GST_PAD_MODE_NONE: GstPadMode = 0;
pub const GST_PAD_MODE_PUSH: GstPadMode = 1;
pub const GST_PAD_MODE_PULL: GstPadMode = 2;

pub type GstPadPresence = c_int;
pub const GST_PAD_ALWAYS: GstPadPresence = 0;
pub const GST_PAD_SOMETIMES: GstPadPresence = 1;
pub const GST_PAD_REQUEST: GstPadPresence = 2;

pub type GstPadProbeReturn = c_int;
pub const GST_PAD_PROBE_DROP: GstPadProbeReturn = 0;
pub const GST_PAD_PROBE_OK: GstPadProbeReturn = 1;
pub const GST_PAD_PROBE_REMOVE: GstPadProbeReturn = 2;
pub const GST_PAD_PROBE_PASS: GstPadProbeReturn = 3;
pub const GST_PAD_PROBE_HANDLED: GstPadProbeReturn = 4;

pub type GstParseError = c_int;
pub const GST_PARSE_ERROR_SYNTAX: GstParseError = 0;
pub const GST_PARSE_ERROR_NO_SUCH_ELEMENT: GstParseError = 1;
pub const GST_PARSE_ERROR_NO_SUCH_PROPERTY: GstParseError = 2;
pub const GST_PARSE_ERROR_LINK: GstParseError = 3;
pub const GST_PARSE_ERROR_COULD_NOT_SET_PROPERTY: GstParseError = 4;
pub const GST_PARSE_ERROR_EMPTY_BIN: GstParseError = 5;
pub const GST_PARSE_ERROR_EMPTY: GstParseError = 6;
pub const GST_PARSE_ERROR_DELAYED_LINK: GstParseError = 7;

pub type GstPluginError = c_int;
pub const GST_PLUGIN_ERROR_MODULE: GstPluginError = 0;
pub const GST_PLUGIN_ERROR_DEPENDENCIES: GstPluginError = 1;
pub const GST_PLUGIN_ERROR_NAME_MISMATCH: GstPluginError = 2;

pub type GstProgressType = c_int;
pub const GST_PROGRESS_TYPE_START: GstProgressType = 0;
pub const GST_PROGRESS_TYPE_CONTINUE: GstProgressType = 1;
pub const GST_PROGRESS_TYPE_COMPLETE: GstProgressType = 2;
pub const GST_PROGRESS_TYPE_CANCELED: GstProgressType = 3;
pub const GST_PROGRESS_TYPE_ERROR: GstProgressType = 4;

pub type GstPromiseResult = c_int;
pub const GST_PROMISE_RESULT_PENDING: GstPromiseResult = 0;
pub const GST_PROMISE_RESULT_INTERRUPTED: GstPromiseResult = 1;
pub const GST_PROMISE_RESULT_REPLIED: GstPromiseResult = 2;
pub const GST_PROMISE_RESULT_EXPIRED: GstPromiseResult = 3;

pub type GstQOSType = c_int;
pub const GST_QOS_TYPE_OVERFLOW: GstQOSType = 0;
pub const GST_QOS_TYPE_UNDERFLOW: GstQOSType = 1;
pub const GST_QOS_TYPE_THROTTLE: GstQOSType = 2;

pub type GstQueryType = c_int;
pub const GST_QUERY_UNKNOWN: GstQueryType = 0;
pub const GST_QUERY_POSITION: GstQueryType = 2563;
pub const GST_QUERY_DURATION: GstQueryType = 5123;
pub const GST_QUERY_LATENCY: GstQueryType = 7683;
pub const GST_QUERY_JITTER: GstQueryType = 10243;
pub const GST_QUERY_RATE: GstQueryType = 12803;
pub const GST_QUERY_SEEKING: GstQueryType = 15363;
pub const GST_QUERY_SEGMENT: GstQueryType = 17923;
pub const GST_QUERY_CONVERT: GstQueryType = 20483;
pub const GST_QUERY_FORMATS: GstQueryType = 23043;
pub const GST_QUERY_BUFFERING: GstQueryType = 28163;
pub const GST_QUERY_CUSTOM: GstQueryType = 30723;
pub const GST_QUERY_URI: GstQueryType = 33283;
pub const GST_QUERY_ALLOCATION: GstQueryType = 35846;
pub const GST_QUERY_SCHEDULING: GstQueryType = 38401;
pub const GST_QUERY_ACCEPT_CAPS: GstQueryType = 40963;
pub const GST_QUERY_CAPS: GstQueryType = 43523;
pub const GST_QUERY_DRAIN: GstQueryType = 46086;
pub const GST_QUERY_CONTEXT: GstQueryType = 48643;
pub const GST_QUERY_BITRATE: GstQueryType = 51202;
#[cfg(any(feature = "v1_22", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
pub const GST_QUERY_SELECTABLE: GstQueryType = 53763;

pub type GstRank = c_int;
pub const GST_RANK_NONE: GstRank = 0;
pub const GST_RANK_MARGINAL: GstRank = 64;
pub const GST_RANK_SECONDARY: GstRank = 128;
pub const GST_RANK_PRIMARY: GstRank = 256;

pub type GstResourceError = c_int;
pub const GST_RESOURCE_ERROR_FAILED: GstResourceError = 1;
pub const GST_RESOURCE_ERROR_TOO_LAZY: GstResourceError = 2;
pub const GST_RESOURCE_ERROR_NOT_FOUND: GstResourceError = 3;
pub const GST_RESOURCE_ERROR_BUSY: GstResourceError = 4;
pub const GST_RESOURCE_ERROR_OPEN_READ: GstResourceError = 5;
pub const GST_RESOURCE_ERROR_OPEN_WRITE: GstResourceError = 6;
pub const GST_RESOURCE_ERROR_OPEN_READ_WRITE: GstResourceError = 7;
pub const GST_RESOURCE_ERROR_CLOSE: GstResourceError = 8;
pub const GST_RESOURCE_ERROR_READ: GstResourceError = 9;
pub const GST_RESOURCE_ERROR_WRITE: GstResourceError = 10;
pub const GST_RESOURCE_ERROR_SEEK: GstResourceError = 11;
pub const GST_RESOURCE_ERROR_SYNC: GstResourceError = 12;
pub const GST_RESOURCE_ERROR_SETTINGS: GstResourceError = 13;
pub const GST_RESOURCE_ERROR_NO_SPACE_LEFT: GstResourceError = 14;
pub const GST_RESOURCE_ERROR_NOT_AUTHORIZED: GstResourceError = 15;
pub const GST_RESOURCE_ERROR_NUM_ERRORS: GstResourceError = 16;

pub type GstSearchMode = c_int;
pub const GST_SEARCH_MODE_EXACT: GstSearchMode = 0;
pub const GST_SEARCH_MODE_BEFORE: GstSearchMode = 1;
pub const GST_SEARCH_MODE_AFTER: GstSearchMode = 2;

pub type GstSeekType = c_int;
pub const GST_SEEK_TYPE_NONE: GstSeekType = 0;
pub const GST_SEEK_TYPE_SET: GstSeekType = 1;
pub const GST_SEEK_TYPE_END: GstSeekType = 2;

pub type GstState = c_int;
pub const GST_STATE_VOID_PENDING: GstState = 0;
pub const GST_STATE_NULL: GstState = 1;
pub const GST_STATE_READY: GstState = 2;
pub const GST_STATE_PAUSED: GstState = 3;
pub const GST_STATE_PLAYING: GstState = 4;

pub type GstStateChange = c_int;
pub const GST_STATE_CHANGE_NULL_TO_READY: GstStateChange = 10;
pub const GST_STATE_CHANGE_READY_TO_PAUSED: GstStateChange = 19;
pub const GST_STATE_CHANGE_PAUSED_TO_PLAYING: GstStateChange = 28;
pub const GST_STATE_CHANGE_PLAYING_TO_PAUSED: GstStateChange = 35;
pub const GST_STATE_CHANGE_PAUSED_TO_READY: GstStateChange = 26;
pub const GST_STATE_CHANGE_READY_TO_NULL: GstStateChange = 17;
pub const GST_STATE_CHANGE_NULL_TO_NULL: GstStateChange = 9;
pub const GST_STATE_CHANGE_READY_TO_READY: GstStateChange = 18;
pub const GST_STATE_CHANGE_PAUSED_TO_PAUSED: GstStateChange = 27;
pub const GST_STATE_CHANGE_PLAYING_TO_PLAYING: GstStateChange = 36;

pub type GstStateChangeReturn = c_int;
pub const GST_STATE_CHANGE_FAILURE: GstStateChangeReturn = 0;
pub const GST_STATE_CHANGE_SUCCESS: GstStateChangeReturn = 1;
pub const GST_STATE_CHANGE_ASYNC: GstStateChangeReturn = 2;
pub const GST_STATE_CHANGE_NO_PREROLL: GstStateChangeReturn = 3;

pub type GstStreamError = c_int;
pub const GST_STREAM_ERROR_FAILED: GstStreamError = 1;
pub const GST_STREAM_ERROR_TOO_LAZY: GstStreamError = 2;
pub const GST_STREAM_ERROR_NOT_IMPLEMENTED: GstStreamError = 3;
pub const GST_STREAM_ERROR_TYPE_NOT_FOUND: GstStreamError = 4;
pub const GST_STREAM_ERROR_WRONG_TYPE: GstStreamError = 5;
pub const GST_STREAM_ERROR_CODEC_NOT_FOUND: GstStreamError = 6;
pub const GST_STREAM_ERROR_DECODE: GstStreamError = 7;
pub const GST_STREAM_ERROR_ENCODE: GstStreamError = 8;
pub const GST_STREAM_ERROR_DEMUX: GstStreamError = 9;
pub const GST_STREAM_ERROR_MUX: GstStreamError = 10;
pub const GST_STREAM_ERROR_FORMAT: GstStreamError = 11;
pub const GST_STREAM_ERROR_DECRYPT: GstStreamError = 12;
pub const GST_STREAM_ERROR_DECRYPT_NOKEY: GstStreamError = 13;
pub const GST_STREAM_ERROR_NUM_ERRORS: GstStreamError = 14;

pub type GstStreamStatusType = c_int;
pub const GST_STREAM_STATUS_TYPE_CREATE: GstStreamStatusType = 0;
pub const GST_STREAM_STATUS_TYPE_ENTER: GstStreamStatusType = 1;
pub const GST_STREAM_STATUS_TYPE_LEAVE: GstStreamStatusType = 2;
pub const GST_STREAM_STATUS_TYPE_DESTROY: GstStreamStatusType = 3;
pub const GST_STREAM_STATUS_TYPE_START: GstStreamStatusType = 8;
pub const GST_STREAM_STATUS_TYPE_PAUSE: GstStreamStatusType = 9;
pub const GST_STREAM_STATUS_TYPE_STOP: GstStreamStatusType = 10;

pub type GstStructureChangeType = c_int;
pub const GST_STRUCTURE_CHANGE_TYPE_PAD_LINK: GstStructureChangeType = 0;
pub const GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK: GstStructureChangeType = 1;

pub type GstTagFlag = c_int;
pub const GST_TAG_FLAG_UNDEFINED: GstTagFlag = 0;
pub const GST_TAG_FLAG_META: GstTagFlag = 1;
pub const GST_TAG_FLAG_ENCODED: GstTagFlag = 2;
pub const GST_TAG_FLAG_DECODED: GstTagFlag = 3;
pub const GST_TAG_FLAG_COUNT: GstTagFlag = 4;

pub type GstTagMergeMode = c_int;
pub const GST_TAG_MERGE_UNDEFINED: GstTagMergeMode = 0;
pub const GST_TAG_MERGE_REPLACE_ALL: GstTagMergeMode = 1;
pub const GST_TAG_MERGE_REPLACE: GstTagMergeMode = 2;
pub const GST_TAG_MERGE_APPEND: GstTagMergeMode = 3;
pub const GST_TAG_MERGE_PREPEND: GstTagMergeMode = 4;
pub const GST_TAG_MERGE_KEEP: GstTagMergeMode = 5;
pub const GST_TAG_MERGE_KEEP_ALL: GstTagMergeMode = 6;
pub const GST_TAG_MERGE_COUNT: GstTagMergeMode = 7;

pub type GstTagScope = c_int;
pub const GST_TAG_SCOPE_STREAM: GstTagScope = 0;
pub const GST_TAG_SCOPE_GLOBAL: GstTagScope = 1;

pub type GstTaskState = c_int;
pub const GST_TASK_STARTED: GstTaskState = 0;
pub const GST_TASK_STOPPED: GstTaskState = 1;
pub const GST_TASK_PAUSED: GstTaskState = 2;

pub type GstTocEntryType = c_int;
pub const GST_TOC_ENTRY_TYPE_ANGLE: GstTocEntryType = -3;
pub const GST_TOC_ENTRY_TYPE_VERSION: GstTocEntryType = -2;
pub const GST_TOC_ENTRY_TYPE_EDITION: GstTocEntryType = -1;
pub const GST_TOC_ENTRY_TYPE_INVALID: GstTocEntryType = 0;
pub const GST_TOC_ENTRY_TYPE_TITLE: GstTocEntryType = 1;
pub const GST_TOC_ENTRY_TYPE_TRACK: GstTocEntryType = 2;
pub const GST_TOC_ENTRY_TYPE_CHAPTER: GstTocEntryType = 3;

pub type GstTocLoopType = c_int;
pub const GST_TOC_LOOP_NONE: GstTocLoopType = 0;
pub const GST_TOC_LOOP_FORWARD: GstTocLoopType = 1;
pub const GST_TOC_LOOP_REVERSE: GstTocLoopType = 2;
pub const GST_TOC_LOOP_PING_PONG: GstTocLoopType = 3;

pub type GstTocScope = c_int;
pub const GST_TOC_SCOPE_GLOBAL: GstTocScope = 1;
pub const GST_TOC_SCOPE_CURRENT: GstTocScope = 2;

pub type GstTracerValueScope = c_int;
pub const GST_TRACER_VALUE_SCOPE_PROCESS: GstTracerValueScope = 0;
pub const GST_TRACER_VALUE_SCOPE_THREAD: GstTracerValueScope = 1;
pub const GST_TRACER_VALUE_SCOPE_ELEMENT: GstTracerValueScope = 2;
pub const GST_TRACER_VALUE_SCOPE_PAD: GstTracerValueScope = 3;

pub type GstTypeFindProbability = c_int;
pub const GST_TYPE_FIND_NONE: GstTypeFindProbability = 0;
pub const GST_TYPE_FIND_MINIMUM: GstTypeFindProbability = 1;
pub const GST_TYPE_FIND_POSSIBLE: GstTypeFindProbability = 50;
pub const GST_TYPE_FIND_LIKELY: GstTypeFindProbability = 80;
pub const GST_TYPE_FIND_NEARLY_CERTAIN: GstTypeFindProbability = 99;
pub const GST_TYPE_FIND_MAXIMUM: GstTypeFindProbability = 100;

pub type GstURIError = c_int;
pub const GST_URI_ERROR_UNSUPPORTED_PROTOCOL: GstURIError = 0;
pub const GST_URI_ERROR_BAD_URI: GstURIError = 1;
pub const GST_URI_ERROR_BAD_STATE: GstURIError = 2;
pub const GST_URI_ERROR_BAD_REFERENCE: GstURIError = 3;

pub type GstURIType = c_int;
pub const GST_URI_UNKNOWN: GstURIType = 0;
pub const GST_URI_SINK: GstURIType = 1;
pub const GST_URI_SRC: GstURIType = 2;

// Constants
pub const GST_ALLOCATOR_SYSMEM: *const c_char = b"SystemMemory\0" as *const u8 as *const c_char;
pub const GST_BUFFER_COPY_ALL: GstBufferCopyFlags = 15;
pub const GST_BUFFER_COPY_METADATA: GstBufferCopyFlags = 7;
pub const GST_BUFFER_OFFSET_NONE: u64 = 18446744073709551615;
pub const GST_CAN_INLINE: c_int = 1;
pub const GST_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY: *const c_char =
    b"memory:SystemMemory\0" as *const u8 as *const c_char;
pub const GST_CLOCK_TIME_NONE: GstClockTime = 18446744073709551615;
pub const GST_DEBUG_BG_MASK: c_int = 240;
pub const GST_DEBUG_FG_MASK: c_int = 15;
pub const GST_DEBUG_FORMAT_MASK: c_int = 65280;
pub const GST_ELEMENT_FACTORY_KLASS_DECODER: *const c_char =
    b"Decoder\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_DECRYPTOR: *const c_char =
    b"Decryptor\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_DEMUXER: *const c_char =
    b"Demuxer\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_DEPAYLOADER: *const c_char =
    b"Depayloader\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_ENCODER: *const c_char =
    b"Encoder\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_ENCRYPTOR: *const c_char =
    b"Encryptor\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_FORMATTER: *const c_char =
    b"Formatter\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_HARDWARE: *const c_char =
    b"Hardware\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_AUDIO: *const c_char =
    b"Audio\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_IMAGE: *const c_char =
    b"Image\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_METADATA: *const c_char =
    b"Metadata\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE: *const c_char =
    b"Subtitle\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_VIDEO: *const c_char =
    b"Video\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MUXER: *const c_char = b"Muxer\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_PARSER: *const c_char =
    b"Parser\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_PAYLOADER: *const c_char =
    b"Payloader\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_SINK: *const c_char = b"Sink\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_SRC: *const c_char = b"Source\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_TYPE_ANY: GstElementFactoryListType = 562949953421311;
pub const GST_ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS: GstElementFactoryListType = 3940649673949188;
pub const GST_ELEMENT_FACTORY_TYPE_AUDIO_ENCODER: GstElementFactoryListType = 1125899906842626;
pub const GST_ELEMENT_FACTORY_TYPE_DECODABLE: GstElementFactoryListType = 1377;
pub const GST_ELEMENT_FACTORY_TYPE_DECODER: GstElementFactoryListType = 1;
pub const GST_ELEMENT_FACTORY_TYPE_DECRYPTOR: GstElementFactoryListType = 1024;
pub const GST_ELEMENT_FACTORY_TYPE_DEMUXER: GstElementFactoryListType = 32;
pub const GST_ELEMENT_FACTORY_TYPE_DEPAYLOADER: GstElementFactoryListType = 256;
pub const GST_ELEMENT_FACTORY_TYPE_ENCODER: GstElementFactoryListType = 2;
pub const GST_ELEMENT_FACTORY_TYPE_ENCRYPTOR: GstElementFactoryListType = 2048;
pub const GST_ELEMENT_FACTORY_TYPE_FORMATTER: GstElementFactoryListType = 512;
pub const GST_ELEMENT_FACTORY_TYPE_HARDWARE: GstElementFactoryListType = 4096;
pub const GST_ELEMENT_FACTORY_TYPE_MAX_ELEMENTS: GstElementFactoryListType = 281474976710656;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_ANY: GstElementFactoryListType = 18446462598732840960;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO: GstElementFactoryListType = 1125899906842624;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE: GstElementFactoryListType = 2251799813685248;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_METADATA: GstElementFactoryListType = 9007199254740992;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE: GstElementFactoryListType = 4503599627370496;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO: GstElementFactoryListType = 562949953421312;
pub const GST_ELEMENT_FACTORY_TYPE_MUXER: GstElementFactoryListType = 16;
pub const GST_ELEMENT_FACTORY_TYPE_PARSER: GstElementFactoryListType = 64;
pub const GST_ELEMENT_FACTORY_TYPE_PAYLOADER: GstElementFactoryListType = 128;
pub const GST_ELEMENT_FACTORY_TYPE_SINK: GstElementFactoryListType = 4;
pub const GST_ELEMENT_FACTORY_TYPE_SRC: GstElementFactoryListType = 8;
pub const GST_ELEMENT_FACTORY_TYPE_VIDEO_ENCODER: GstElementFactoryListType = 2814749767106562;
pub const GST_ELEMENT_METADATA_AUTHOR: *const c_char = b"author\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_DESCRIPTION: *const c_char =
    b"description\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_DOC_URI: *const c_char = b"doc-uri\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_ICON_NAME: *const c_char =
    b"icon-name\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_KLASS: *const c_char = b"klass\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_LONGNAME: *const c_char =
    b"long-name\0" as *const u8 as *const c_char;
pub const GST_EVENT_NUM_SHIFT: c_int = 8;
pub const GST_EVENT_TYPE_BOTH: GstEventTypeFlags = 3;
pub const GST_FLAG_SET_MASK_EXACT: c_uint = 4294967295;
pub const GST_FORMAT_PERCENT_MAX: i64 = 1000000;
pub const GST_FORMAT_PERCENT_SCALE: i64 = 10000;
pub const GST_GROUP_ID_INVALID: c_int = 0;
pub const GST_LICENSE_UNKNOWN: *const c_char = b"unknown\0" as *const u8 as *const c_char;
pub const GST_LOCK_FLAG_READWRITE: GstLockFlags = 3;
pub const GST_MAP_READWRITE: GstMapFlags = 3;
pub const GST_META_TAG_MEMORY_REFERENCE_STR: *const c_char =
    b"memory-reference\0" as *const u8 as *const c_char;
pub const GST_META_TAG_MEMORY_STR: *const c_char = b"memory\0" as *const u8 as *const c_char;
pub const GST_MSECOND: GstClockTimeDiff = 1000000;
pub const GST_NSECOND: GstClockTimeDiff = 1;
pub const GST_PARAM_CONDITIONALLY_AVAILABLE: c_int = 16384;
pub const GST_PARAM_CONTROLLABLE: c_int = 512;
pub const GST_PARAM_DOC_SHOW_DEFAULT: c_int = 8192;
pub const GST_PARAM_MUTABLE_PAUSED: c_int = 2048;
pub const GST_PARAM_MUTABLE_PLAYING: c_int = 4096;
pub const GST_PARAM_MUTABLE_READY: c_int = 1024;
pub const GST_PARAM_USER_SHIFT: c_int = 65536;
pub const GST_PROTECTION_SYSTEM_ID_CAPS_FIELD: *const c_char =
    b"protection-system\0" as *const u8 as *const c_char;
pub const GST_PROTECTION_UNSPECIFIED_SYSTEM_ID: *const c_char =
    b"unspecified-system-id\0" as *const u8 as *const c_char;
pub const GST_QUERY_NUM_SHIFT: c_int = 8;
pub const GST_QUERY_TYPE_BOTH: GstQueryTypeFlags = 3;
pub const GST_SECOND: GstClockTimeDiff = 1000000000;
pub const GST_SEGMENT_INSTANT_FLAGS: c_int = 912;
pub const GST_SEQNUM_INVALID: c_int = 0;
pub const GST_TAG_ALBUM: *const c_char = b"album\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_ARTIST: *const c_char = b"album-artist\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_ARTIST_SORTNAME: *const c_char =
    b"album-artist-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_GAIN: *const c_char =
    b"replaygain-album-gain\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_PEAK: *const c_char =
    b"replaygain-album-peak\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_SORTNAME: *const c_char = b"album-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_VOLUME_COUNT: *const c_char =
    b"album-disc-count\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_VOLUME_NUMBER: *const c_char =
    b"album-disc-number\0" as *const u8 as *const c_char;
pub const GST_TAG_APPLICATION_DATA: *const c_char =
    b"application-data\0" as *const u8 as *const c_char;
pub const GST_TAG_APPLICATION_NAME: *const c_char =
    b"application-name\0" as *const u8 as *const c_char;
pub const GST_TAG_ARTIST: *const c_char = b"artist\0" as *const u8 as *const c_char;
pub const GST_TAG_ARTIST_SORTNAME: *const c_char =
    b"artist-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_ATTACHMENT: *const c_char = b"attachment\0" as *const u8 as *const c_char;
pub const GST_TAG_AUDIO_CODEC: *const c_char = b"audio-codec\0" as *const u8 as *const c_char;
pub const GST_TAG_BEATS_PER_MINUTE: *const c_char =
    b"beats-per-minute\0" as *const u8 as *const c_char;
pub const GST_TAG_BITRATE: *const c_char = b"bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_CODEC: *const c_char = b"codec\0" as *const u8 as *const c_char;
pub const GST_TAG_COMMENT: *const c_char = b"comment\0" as *const u8 as *const c_char;
pub const GST_TAG_COMPOSER: *const c_char = b"composer\0" as *const u8 as *const c_char;
pub const GST_TAG_COMPOSER_SORTNAME: *const c_char =
    b"composer-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_CONDUCTOR: *const c_char = b"conductor\0" as *const u8 as *const c_char;
pub const GST_TAG_CONTACT: *const c_char = b"contact\0" as *const u8 as *const c_char;
pub const GST_TAG_CONTAINER_FORMAT: *const c_char =
    b"container-format\0" as *const u8 as *const c_char;
pub const GST_TAG_COPYRIGHT: *const c_char = b"copyright\0" as *const u8 as *const c_char;
pub const GST_TAG_COPYRIGHT_URI: *const c_char = b"copyright-uri\0" as *const u8 as *const c_char;
pub const GST_TAG_DATE: *const c_char = b"date\0" as *const u8 as *const c_char;
pub const GST_TAG_DATE_TIME: *const c_char = b"datetime\0" as *const u8 as *const c_char;
pub const GST_TAG_DESCRIPTION: *const c_char = b"description\0" as *const u8 as *const c_char;
pub const GST_TAG_DEVICE_MANUFACTURER: *const c_char =
    b"device-manufacturer\0" as *const u8 as *const c_char;
pub const GST_TAG_DEVICE_MODEL: *const c_char = b"device-model\0" as *const u8 as *const c_char;
pub const GST_TAG_DURATION: *const c_char = b"duration\0" as *const u8 as *const c_char;
pub const GST_TAG_ENCODED_BY: *const c_char = b"encoded-by\0" as *const u8 as *const c_char;
pub const GST_TAG_ENCODER: *const c_char = b"encoder\0" as *const u8 as *const c_char;
pub const GST_TAG_ENCODER_VERSION: *const c_char =
    b"encoder-version\0" as *const u8 as *const c_char;
pub const GST_TAG_EXTENDED_COMMENT: *const c_char =
    b"extended-comment\0" as *const u8 as *const c_char;
pub const GST_TAG_GENRE: *const c_char = b"genre\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION: *const c_char =
    b"geo-location-capture-direction\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_CITY: *const c_char =
    b"geo-location-city\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_COUNTRY: *const c_char =
    b"geo-location-country\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_ELEVATION: *const c_char =
    b"geo-location-elevation\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_HORIZONTAL_ERROR: *const c_char =
    b"geo-location-horizontal-error\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_LATITUDE: *const c_char =
    b"geo-location-latitude\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_LONGITUDE: *const c_char =
    b"geo-location-longitude\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION: *const c_char =
    b"geo-location-movement-direction\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_MOVEMENT_SPEED: *const c_char =
    b"geo-location-movement-speed\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_NAME: *const c_char =
    b"geo-location-name\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_SUBLOCATION: *const c_char =
    b"geo-location-sublocation\0" as *const u8 as *const c_char;
pub const GST_TAG_GROUPING: *const c_char = b"grouping\0" as *const u8 as *const c_char;
pub const GST_TAG_HOMEPAGE: *const c_char = b"homepage\0" as *const u8 as *const c_char;
pub const GST_TAG_IMAGE: *const c_char = b"image\0" as *const u8 as *const c_char;
pub const GST_TAG_IMAGE_ORIENTATION: *const c_char =
    b"image-orientation\0" as *const u8 as *const c_char;
pub const GST_TAG_INTERPRETED_BY: *const c_char = b"interpreted-by\0" as *const u8 as *const c_char;
pub const GST_TAG_ISRC: *const c_char = b"isrc\0" as *const u8 as *const c_char;
pub const GST_TAG_KEYWORDS: *const c_char = b"keywords\0" as *const u8 as *const c_char;
pub const GST_TAG_LANGUAGE_CODE: *const c_char = b"language-code\0" as *const u8 as *const c_char;
pub const GST_TAG_LANGUAGE_NAME: *const c_char = b"language-name\0" as *const u8 as *const c_char;
pub const GST_TAG_LICENSE: *const c_char = b"license\0" as *const u8 as *const c_char;
pub const GST_TAG_LICENSE_URI: *const c_char = b"license-uri\0" as *const u8 as *const c_char;
pub const GST_TAG_LOCATION: *const c_char = b"location\0" as *const u8 as *const c_char;
pub const GST_TAG_LYRICS: *const c_char = b"lyrics\0" as *const u8 as *const c_char;
pub const GST_TAG_MAXIMUM_BITRATE: *const c_char =
    b"maximum-bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_MIDI_BASE_NOTE: *const c_char = b"midi-base-note\0" as *const u8 as *const c_char;
pub const GST_TAG_MINIMUM_BITRATE: *const c_char =
    b"minimum-bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_NOMINAL_BITRATE: *const c_char =
    b"nominal-bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_ORGANIZATION: *const c_char = b"organization\0" as *const u8 as *const c_char;
pub const GST_TAG_PERFORMER: *const c_char = b"performer\0" as *const u8 as *const c_char;
pub const GST_TAG_PREVIEW_IMAGE: *const c_char = b"preview-image\0" as *const u8 as *const c_char;
pub const GST_TAG_PRIVATE_DATA: *const c_char = b"private-data\0" as *const u8 as *const c_char;
pub const GST_TAG_PUBLISHER: *const c_char = b"publisher\0" as *const u8 as *const c_char;
pub const GST_TAG_REFERENCE_LEVEL: *const c_char =
    b"replaygain-reference-level\0" as *const u8 as *const c_char;
pub const GST_TAG_SERIAL: *const c_char = b"serial\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_EPISODE_NUMBER: *const c_char =
    b"show-episode-number\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_NAME: *const c_char = b"show-name\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_SEASON_NUMBER: *const c_char =
    b"show-season-number\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_SORTNAME: *const c_char = b"show-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_SUBTITLE_CODEC: *const c_char = b"subtitle-codec\0" as *const u8 as *const c_char;
pub const GST_TAG_TITLE: *const c_char = b"title\0" as *const u8 as *const c_char;
pub const GST_TAG_TITLE_SORTNAME: *const c_char = b"title-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_COUNT: *const c_char = b"track-count\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_GAIN: *const c_char =
    b"replaygain-track-gain\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_NUMBER: *const c_char = b"track-number\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_PEAK: *const c_char =
    b"replaygain-track-peak\0" as *const u8 as *const c_char;
pub const GST_TAG_USER_RATING: *const c_char = b"user-rating\0" as *const u8 as *const c_char;
pub const GST_TAG_VERSION: *const c_char = b"version\0" as *const u8 as *const c_char;
pub const GST_TAG_VIDEO_CODEC: *const c_char = b"video-codec\0" as *const u8 as *const c_char;
pub const GST_TOC_REPEAT_COUNT_INFINITE: c_int = -1;
pub const GST_URI_NO_PORT: c_int = 0;
pub const GST_USECOND: GstClockTimeDiff = 1000;
pub const GST_VALUE_EQUAL: c_int = 0;
pub const GST_VALUE_GREATER_THAN: c_int = 1;
pub const GST_VALUE_LESS_THAN: c_int = -1;
pub const GST_VALUE_UNORDERED: c_int = 2;

// Flags
pub type GstAllocatorFlags = c_uint;
pub const GST_ALLOCATOR_FLAG_CUSTOM_ALLOC: GstAllocatorFlags = 16;
pub const GST_ALLOCATOR_FLAG_LAST: GstAllocatorFlags = 1048576;

pub type GstBinFlags = c_uint;
pub const GST_BIN_FLAG_NO_RESYNC: GstBinFlags = 16384;
pub const GST_BIN_FLAG_STREAMS_AWARE: GstBinFlags = 32768;
pub const GST_BIN_FLAG_LAST: GstBinFlags = 524288;

pub type GstBufferCopyFlags = c_uint;
pub const GST_BUFFER_COPY_NONE: GstBufferCopyFlags = 0;
pub const GST_BUFFER_COPY_FLAGS: GstBufferCopyFlags = 1;
pub const GST_BUFFER_COPY_TIMESTAMPS: GstBufferCopyFlags = 2;
pub const GST_BUFFER_COPY_META: GstBufferCopyFlags = 4;
pub const GST_BUFFER_COPY_MEMORY: GstBufferCopyFlags = 8;
pub const GST_BUFFER_COPY_MERGE: GstBufferCopyFlags = 16;
pub const GST_BUFFER_COPY_DEEP: GstBufferCopyFlags = 32;

pub type GstBufferFlags = c_uint;
pub const GST_BUFFER_FLAG_LIVE: GstBufferFlags = 16;
pub const GST_BUFFER_FLAG_DECODE_ONLY: GstBufferFlags = 32;
pub const GST_BUFFER_FLAG_DISCONT: GstBufferFlags = 64;
pub const GST_BUFFER_FLAG_RESYNC: GstBufferFlags = 128;
pub const GST_BUFFER_FLAG_CORRUPTED: GstBufferFlags = 256;
pub const GST_BUFFER_FLAG_MARKER: GstBufferFlags = 512;
pub const GST_BUFFER_FLAG_HEADER: GstBufferFlags = 1024;
pub const GST_BUFFER_FLAG_GAP: GstBufferFlags = 2048;
pub const GST_BUFFER_FLAG_DROPPABLE: GstBufferFlags = 4096;
pub const GST_BUFFER_FLAG_DELTA_UNIT: GstBufferFlags = 8192;
pub const GST_BUFFER_FLAG_TAG_MEMORY: GstBufferFlags = 16384;
pub const GST_BUFFER_FLAG_SYNC_AFTER: GstBufferFlags = 32768;
pub const GST_BUFFER_FLAG_NON_DROPPABLE: GstBufferFlags = 65536;
pub const GST_BUFFER_FLAG_LAST: GstBufferFlags = 1048576;

pub type GstBufferPoolAcquireFlags = c_uint;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_NONE: GstBufferPoolAcquireFlags = 0;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT: GstBufferPoolAcquireFlags = 1;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT: GstBufferPoolAcquireFlags = 2;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT: GstBufferPoolAcquireFlags = 4;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_LAST: GstBufferPoolAcquireFlags = 65536;

pub type GstBusFlags = c_uint;
pub const GST_BUS_FLUSHING: GstBusFlags = 16;
pub const GST_BUS_FLAG_LAST: GstBusFlags = 32;

pub type GstCapsFlags = c_uint;
pub const GST_CAPS_FLAG_ANY: GstCapsFlags = 16;

pub type GstClockFlags = c_uint;
pub const GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC: GstClockFlags = 16;
pub const GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC: GstClockFlags = 32;
pub const GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC: GstClockFlags = 64;
pub const GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC: GstClockFlags = 128;
pub const GST_CLOCK_FLAG_CAN_SET_RESOLUTION: GstClockFlags = 256;
pub const GST_CLOCK_FLAG_CAN_SET_MASTER: GstClockFlags = 512;
pub const GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC: GstClockFlags = 1024;
pub const GST_CLOCK_FLAG_LAST: GstClockFlags = 4096;

pub type GstDebugColorFlags = c_uint;
pub const GST_DEBUG_FG_BLACK: GstDebugColorFlags = 0;
pub const GST_DEBUG_FG_RED: GstDebugColorFlags = 1;
pub const GST_DEBUG_FG_GREEN: GstDebugColorFlags = 2;
pub const GST_DEBUG_FG_YELLOW: GstDebugColorFlags = 3;
pub const GST_DEBUG_FG_BLUE: GstDebugColorFlags = 4;
pub const GST_DEBUG_FG_MAGENTA: GstDebugColorFlags = 5;
pub const GST_DEBUG_FG_CYAN: GstDebugColorFlags = 6;
pub const GST_DEBUG_FG_WHITE: GstDebugColorFlags = 7;
pub const GST_DEBUG_BG_BLACK: GstDebugColorFlags = 0;
pub const GST_DEBUG_BG_RED: GstDebugColorFlags = 16;
pub const GST_DEBUG_BG_GREEN: GstDebugColorFlags = 32;
pub const GST_DEBUG_BG_YELLOW: GstDebugColorFlags = 48;
pub const GST_DEBUG_BG_BLUE: GstDebugColorFlags = 64;
pub const GST_DEBUG_BG_MAGENTA: GstDebugColorFlags = 80;
pub const GST_DEBUG_BG_CYAN: GstDebugColorFlags = 96;
pub const GST_DEBUG_BG_WHITE: GstDebugColorFlags = 112;
pub const GST_DEBUG_BOLD: GstDebugColorFlags = 256;
pub const GST_DEBUG_UNDERLINE: GstDebugColorFlags = 512;

pub type GstDebugGraphDetails = c_uint;
pub const GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE: GstDebugGraphDetails = 1;
pub const GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS: GstDebugGraphDetails = 2;
pub const GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS: GstDebugGraphDetails = 4;
pub const GST_DEBUG_GRAPH_SHOW_STATES: GstDebugGraphDetails = 8;
pub const GST_DEBUG_GRAPH_SHOW_FULL_PARAMS: GstDebugGraphDetails = 16;
pub const GST_DEBUG_GRAPH_SHOW_ALL: GstDebugGraphDetails = 15;
pub const GST_DEBUG_GRAPH_SHOW_VERBOSE: GstDebugGraphDetails = 4294967295;

pub type GstElementFlags = c_uint;
pub const GST_ELEMENT_FLAG_LOCKED_STATE: GstElementFlags = 16;
pub const GST_ELEMENT_FLAG_SINK: GstElementFlags = 32;
pub const GST_ELEMENT_FLAG_SOURCE: GstElementFlags = 64;
pub const GST_ELEMENT_FLAG_PROVIDE_CLOCK: GstElementFlags = 128;
pub const GST_ELEMENT_FLAG_REQUIRE_CLOCK: GstElementFlags = 256;
pub const GST_ELEMENT_FLAG_INDEXABLE: GstElementFlags = 512;
pub const GST_ELEMENT_FLAG_LAST: GstElementFlags = 16384;

pub type GstEventTypeFlags = c_uint;
pub const GST_EVENT_TYPE_UPSTREAM: GstEventTypeFlags = 1;
pub const GST_EVENT_TYPE_DOWNSTREAM: GstEventTypeFlags = 2;
pub const GST_EVENT_TYPE_SERIALIZED: GstEventTypeFlags = 4;
pub const GST_EVENT_TYPE_STICKY: GstEventTypeFlags = 8;
pub const GST_EVENT_TYPE_STICKY_MULTI: GstEventTypeFlags = 16;

pub type GstGapFlags = c_uint;
pub const GST_GAP_FLAG_MISSING_DATA: GstGapFlags = 1;

pub type GstLockFlags = c_uint;
pub const GST_LOCK_FLAG_READ: GstLockFlags = 1;
pub const GST_LOCK_FLAG_WRITE: GstLockFlags = 2;
pub const GST_LOCK_FLAG_EXCLUSIVE: GstLockFlags = 4;
pub const GST_LOCK_FLAG_LAST: GstLockFlags = 256;

pub type GstMapFlags = c_uint;
pub const GST_MAP_READ: GstMapFlags = 1;
pub const GST_MAP_WRITE: GstMapFlags = 2;
pub const GST_MAP_FLAG_LAST: GstMapFlags = 65536;

pub type GstMemoryFlags = c_uint;
pub const GST_MEMORY_FLAG_READONLY: GstMemoryFlags = 2;
pub const GST_MEMORY_FLAG_NO_SHARE: GstMemoryFlags = 16;
pub const GST_MEMORY_FLAG_ZERO_PREFIXED: GstMemoryFlags = 32;
pub const GST_MEMORY_FLAG_ZERO_PADDED: GstMemoryFlags = 64;
pub const GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS: GstMemoryFlags = 128;
pub const GST_MEMORY_FLAG_NOT_MAPPABLE: GstMemoryFlags = 256;
pub const GST_MEMORY_FLAG_LAST: GstMemoryFlags = 1048576;

pub type GstMessageType = c_uint;
pub const GST_MESSAGE_UNKNOWN: GstMessageType = 0;
pub const GST_MESSAGE_EOS: GstMessageType = 1;
pub const GST_MESSAGE_ERROR: GstMessageType = 2;
pub const GST_MESSAGE_WARNING: GstMessageType = 4;
pub const GST_MESSAGE_INFO: GstMessageType = 8;
pub const GST_MESSAGE_TAG: GstMessageType = 16;
pub const GST_MESSAGE_BUFFERING: GstMessageType = 32;
pub const GST_MESSAGE_STATE_CHANGED: GstMessageType = 64;
pub const GST_MESSAGE_STATE_DIRTY: GstMessageType = 128;
pub const GST_MESSAGE_STEP_DONE: GstMessageType = 256;
pub const GST_MESSAGE_CLOCK_PROVIDE: GstMessageType = 512;
pub const GST_MESSAGE_CLOCK_LOST: GstMessageType = 1024;
pub const GST_MESSAGE_NEW_CLOCK: GstMessageType = 2048;
pub const GST_MESSAGE_STRUCTURE_CHANGE: GstMessageType = 4096;
pub const GST_MESSAGE_STREAM_STATUS: GstMessageType = 8192;
pub const GST_MESSAGE_APPLICATION: GstMessageType = 16384;
pub const GST_MESSAGE_ELEMENT: GstMessageType = 32768;
pub const GST_MESSAGE_SEGMENT_START: GstMessageType = 65536;
pub const GST_MESSAGE_SEGMENT_DONE: GstMessageType = 131072;
pub const GST_MESSAGE_DURATION_CHANGED: GstMessageType = 262144;
pub const GST_MESSAGE_LATENCY: GstMessageType = 524288;
pub const GST_MESSAGE_ASYNC_START: GstMessageType = 1048576;
pub const GST_MESSAGE_ASYNC_DONE: GstMessageType = 2097152;
pub const GST_MESSAGE_REQUEST_STATE: GstMessageType = 4194304;
pub const GST_MESSAGE_STEP_START: GstMessageType = 8388608;
pub const GST_MESSAGE_QOS: GstMessageType = 16777216;
pub const GST_MESSAGE_PROGRESS: GstMessageType = 33554432;
pub const GST_MESSAGE_TOC: GstMessageType = 67108864;
pub const GST_MESSAGE_RESET_TIME: GstMessageType = 134217728;
pub const GST_MESSAGE_STREAM_START: GstMessageType = 268435456;
pub const GST_MESSAGE_NEED_CONTEXT: GstMessageType = 536870912;
pub const GST_MESSAGE_HAVE_CONTEXT: GstMessageType = 1073741824;
pub const GST_MESSAGE_EXTENDED: GstMessageType = 2147483648;
pub const GST_MESSAGE_DEVICE_ADDED: GstMessageType = 2147483649;
pub const GST_MESSAGE_DEVICE_REMOVED: GstMessageType = 2147483650;
pub const GST_MESSAGE_PROPERTY_NOTIFY: GstMessageType = 2147483651;
pub const GST_MESSAGE_STREAM_COLLECTION: GstMessageType = 2147483652;
pub const GST_MESSAGE_STREAMS_SELECTED: GstMessageType = 2147483653;
pub const GST_MESSAGE_REDIRECT: GstMessageType = 2147483654;
pub const GST_MESSAGE_DEVICE_CHANGED: GstMessageType = 2147483655;
pub const GST_MESSAGE_INSTANT_RATE_REQUEST: GstMessageType = 2147483656;
pub const GST_MESSAGE_ANY: GstMessageType = 4294967295;

pub type GstMetaFlags = c_uint;
pub const GST_META_FLAG_NONE: GstMetaFlags = 0;
pub const GST_META_FLAG_READONLY: GstMetaFlags = 1;
pub const GST_META_FLAG_POOLED: GstMetaFlags = 2;
pub const GST_META_FLAG_LOCKED: GstMetaFlags = 4;
pub const GST_META_FLAG_LAST: GstMetaFlags = 65536;

pub type GstMiniObjectFlags = c_uint;
pub const GST_MINI_OBJECT_FLAG_LOCKABLE: GstMiniObjectFlags = 1;
pub const GST_MINI_OBJECT_FLAG_LOCK_READONLY: GstMiniObjectFlags = 2;
pub const GST_MINI_OBJECT_FLAG_MAY_BE_LEAKED: GstMiniObjectFlags = 4;
pub const GST_MINI_OBJECT_FLAG_LAST: GstMiniObjectFlags = 16;

pub type GstObjectFlags = c_uint;
pub const GST_OBJECT_FLAG_MAY_BE_LEAKED: GstObjectFlags = 1;
pub const GST_OBJECT_FLAG_LAST: GstObjectFlags = 16;

pub type GstPadFlags = c_uint;
pub const GST_PAD_FLAG_BLOCKED: GstPadFlags = 16;
pub const GST_PAD_FLAG_FLUSHING: GstPadFlags = 32;
pub const GST_PAD_FLAG_EOS: GstPadFlags = 64;
pub const GST_PAD_FLAG_BLOCKING: GstPadFlags = 128;
pub const GST_PAD_FLAG_NEED_PARENT: GstPadFlags = 256;
pub const GST_PAD_FLAG_NEED_RECONFIGURE: GstPadFlags = 512;
pub const GST_PAD_FLAG_PENDING_EVENTS: GstPadFlags = 1024;
pub const GST_PAD_FLAG_FIXED_CAPS: GstPadFlags = 2048;
pub const GST_PAD_FLAG_PROXY_CAPS: GstPadFlags = 4096;
pub const GST_PAD_FLAG_PROXY_ALLOCATION: GstPadFlags = 8192;
pub const GST_PAD_FLAG_PROXY_SCHEDULING: GstPadFlags = 16384;
pub const GST_PAD_FLAG_ACCEPT_INTERSECT: GstPadFlags = 32768;
pub const GST_PAD_FLAG_ACCEPT_TEMPLATE: GstPadFlags = 65536;
pub const GST_PAD_FLAG_LAST: GstPadFlags = 1048576;

pub type GstPadLinkCheck = c_uint;
pub const GST_PAD_LINK_CHECK_NOTHING: GstPadLinkCheck = 0;
pub const GST_PAD_LINK_CHECK_HIERARCHY: GstPadLinkCheck = 1;
pub const GST_PAD_LINK_CHECK_TEMPLATE_CAPS: GstPadLinkCheck = 2;
pub const GST_PAD_LINK_CHECK_CAPS: GstPadLinkCheck = 4;
pub const GST_PAD_LINK_CHECK_NO_RECONFIGURE: GstPadLinkCheck = 8;
pub const GST_PAD_LINK_CHECK_DEFAULT: GstPadLinkCheck = 5;

pub type GstPadProbeType = c_uint;
pub const GST_PAD_PROBE_TYPE_INVALID: GstPadProbeType = 0;
pub const GST_PAD_PROBE_TYPE_IDLE: GstPadProbeType = 1;
pub const GST_PAD_PROBE_TYPE_BLOCK: GstPadProbeType = 2;
pub const GST_PAD_PROBE_TYPE_BUFFER: GstPadProbeType = 16;
pub const GST_PAD_PROBE_TYPE_BUFFER_LIST: GstPadProbeType = 32;
pub const GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM: GstPadProbeType = 64;
pub const GST_PAD_PROBE_TYPE_EVENT_UPSTREAM: GstPadProbeType = 128;
pub const GST_PAD_PROBE_TYPE_EVENT_FLUSH: GstPadProbeType = 256;
pub const GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM: GstPadProbeType = 512;
pub const GST_PAD_PROBE_TYPE_QUERY_UPSTREAM: GstPadProbeType = 1024;
pub const GST_PAD_PROBE_TYPE_PUSH: GstPadProbeType = 4096;
pub const GST_PAD_PROBE_TYPE_PULL: GstPadProbeType = 8192;
pub const GST_PAD_PROBE_TYPE_BLOCKING: GstPadProbeType = 3;
pub const GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM: GstPadProbeType = 112;
pub const GST_PAD_PROBE_TYPE_DATA_UPSTREAM: GstPadProbeType = 128;
pub const GST_PAD_PROBE_TYPE_DATA_BOTH: GstPadProbeType = 240;
pub const GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM: GstPadProbeType = 114;
pub const GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM: GstPadProbeType = 130;
pub const GST_PAD_PROBE_TYPE_EVENT_BOTH: GstPadProbeType = 192;
pub const GST_PAD_PROBE_TYPE_QUERY_BOTH: GstPadProbeType = 1536;
pub const GST_PAD_PROBE_TYPE_ALL_BOTH: GstPadProbeType = 1776;
pub const GST_PAD_PROBE_TYPE_SCHEDULING: GstPadProbeType = 12288;

pub type GstPadTemplateFlags = c_uint;
pub const GST_PAD_TEMPLATE_FLAG_LAST: GstPadTemplateFlags = 256;

pub type GstParseFlags = c_uint;
pub const GST_PARSE_FLAG_NONE: GstParseFlags = 0;
pub const GST_PARSE_FLAG_FATAL_ERRORS: GstParseFlags = 1;
pub const GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS: GstParseFlags = 2;
pub const GST_PARSE_FLAG_PLACE_IN_BIN: GstParseFlags = 4;

pub type GstPipelineFlags = c_uint;
pub const GST_PIPELINE_FLAG_FIXED_CLOCK: GstPipelineFlags = 524288;
pub const GST_PIPELINE_FLAG_LAST: GstPipelineFlags = 8388608;

pub type GstPluginAPIFlags = c_uint;
pub const GST_PLUGIN_API_FLAG_IGNORE_ENUM_MEMBERS: GstPluginAPIFlags = 1;

pub type GstPluginDependencyFlags = c_uint;
pub const GST_PLUGIN_DEPENDENCY_FLAG_NONE: GstPluginDependencyFlags = 0;
pub const GST_PLUGIN_DEPENDENCY_FLAG_RECURSE: GstPluginDependencyFlags = 1;
pub const GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY: GstPluginDependencyFlags = 2;
pub const GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX: GstPluginDependencyFlags = 4;
pub const GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX: GstPluginDependencyFlags = 8;
pub const GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_RELATIVE_TO_EXE: GstPluginDependencyFlags = 16;

pub type GstPluginFlags = c_uint;
pub const GST_PLUGIN_FLAG_CACHED: GstPluginFlags = 16;
pub const GST_PLUGIN_FLAG_BLACKLISTED: GstPluginFlags = 32;

pub type GstQueryTypeFlags = c_uint;
pub const GST_QUERY_TYPE_UPSTREAM: GstQueryTypeFlags = 1;
pub const GST_QUERY_TYPE_DOWNSTREAM: GstQueryTypeFlags = 2;
pub const GST_QUERY_TYPE_SERIALIZED: GstQueryTypeFlags = 4;

pub type GstSchedulingFlags = c_uint;
pub const GST_SCHEDULING_FLAG_SEEKABLE: GstSchedulingFlags = 1;
pub const GST_SCHEDULING_FLAG_SEQUENTIAL: GstSchedulingFlags = 2;
pub const GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED: GstSchedulingFlags = 4;

pub type GstSeekFlags = c_uint;
pub const GST_SEEK_FLAG_NONE: GstSeekFlags = 0;
pub const GST_SEEK_FLAG_FLUSH: GstSeekFlags = 1;
pub const GST_SEEK_FLAG_ACCURATE: GstSeekFlags = 2;
pub const GST_SEEK_FLAG_KEY_UNIT: GstSeekFlags = 4;
pub const GST_SEEK_FLAG_SEGMENT: GstSeekFlags = 8;
pub const GST_SEEK_FLAG_TRICKMODE: GstSeekFlags = 16;
pub const GST_SEEK_FLAG_SKIP: GstSeekFlags = 16;
pub const GST_SEEK_FLAG_SNAP_BEFORE: GstSeekFlags = 32;
pub const GST_SEEK_FLAG_SNAP_AFTER: GstSeekFlags = 64;
pub const GST_SEEK_FLAG_SNAP_NEAREST: GstSeekFlags = 96;
pub const GST_SEEK_FLAG_TRICKMODE_KEY_UNITS: GstSeekFlags = 128;
pub const GST_SEEK_FLAG_TRICKMODE_NO_AUDIO: GstSeekFlags = 256;
pub const GST_SEEK_FLAG_TRICKMODE_FORWARD_PREDICTED: GstSeekFlags = 512;
pub const GST_SEEK_FLAG_INSTANT_RATE_CHANGE: GstSeekFlags = 1024;

pub type GstSegmentFlags = c_uint;
pub const GST_SEGMENT_FLAG_NONE: GstSegmentFlags = 0;
pub const GST_SEGMENT_FLAG_RESET: GstSegmentFlags = 1;
pub const GST_SEGMENT_FLAG_TRICKMODE: GstSegmentFlags = 16;
pub const GST_SEGMENT_FLAG_SKIP: GstSegmentFlags = 16;
pub const GST_SEGMENT_FLAG_SEGMENT: GstSegmentFlags = 8;
pub const GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS: GstSegmentFlags = 128;
pub const GST_SEGMENT_FLAG_TRICKMODE_FORWARD_PREDICTED: GstSegmentFlags = 512;
pub const GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO: GstSegmentFlags = 256;

pub type GstSerializeFlags = c_uint;
pub const GST_SERIALIZE_FLAG_NONE: GstSerializeFlags = 0;
pub const GST_SERIALIZE_FLAG_BACKWARD_COMPAT: GstSerializeFlags = 1;

pub type GstStackTraceFlags = c_uint;
pub const GST_STACK_TRACE_SHOW_NONE: GstStackTraceFlags = 0;
pub const GST_STACK_TRACE_SHOW_FULL: GstStackTraceFlags = 1;

pub type GstStreamFlags = c_uint;
pub const GST_STREAM_FLAG_NONE: GstStreamFlags = 0;
pub const GST_STREAM_FLAG_SPARSE: GstStreamFlags = 1;
pub const GST_STREAM_FLAG_SELECT: GstStreamFlags = 2;
pub const GST_STREAM_FLAG_UNSELECT: GstStreamFlags = 4;

pub type GstStreamType = c_uint;
pub const GST_STREAM_TYPE_UNKNOWN: GstStreamType = 1;
pub const GST_STREAM_TYPE_AUDIO: GstStreamType = 2;
pub const GST_STREAM_TYPE_VIDEO: GstStreamType = 4;
pub const GST_STREAM_TYPE_CONTAINER: GstStreamType = 8;
pub const GST_STREAM_TYPE_TEXT: GstStreamType = 16;

pub type GstTracerValueFlags = c_uint;
pub const GST_TRACER_VALUE_FLAGS_NONE: GstTracerValueFlags = 0;
pub const GST_TRACER_VALUE_FLAGS_OPTIONAL: GstTracerValueFlags = 1;
pub const GST_TRACER_VALUE_FLAGS_AGGREGATED: GstTracerValueFlags = 2;

// Unions
#[derive(Copy, Clone)]
#[repr(C)]
pub union GstControlBinding_ABI {
    pub abi: GstControlBinding_ABI_abi,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstControlBinding_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlBinding_ABI @ {self:p}"))
            .field("abi", unsafe { &self.abi })
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub union GstPadProbeInfo_ABI {
    pub _gst_reserved: [gpointer; 4],
    pub abi: GstPadProbeInfo_ABI_abi,
}

impl ::std::fmt::Debug for GstPadProbeInfo_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadProbeInfo_ABI @ {self:p}"))
            .field("_gst_reserved", unsafe { &self._gst_reserved })
            .field("abi", unsafe { &self.abi })
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub union GstPadTemplate_ABI {
    pub _gst_reserved: [gpointer; 4],
    pub abi: GstPadTemplate_ABI_abi,
}

impl ::std::fmt::Debug for GstPadTemplate_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadTemplate_ABI @ {self:p}"))
            .field("_gst_reserved", unsafe { &self._gst_reserved })
            .field("abi", unsafe { &self.abi })
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub union GstPad_ABI {
    pub _gst_reserved: [gpointer; 4],
    pub abi: GstPad_ABI_abi,
}

impl ::std::fmt::Debug for GstPad_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPad_ABI @ {self:p}"))
            .field("_gst_reserved", unsafe { &self._gst_reserved })
            .field("abi", unsafe { &self.abi })
            .finish()
    }
}

// Callbacks
pub type GstBufferForeachMetaFunc =
    Option<unsafe extern "C" fn(*mut GstBuffer, *mut *mut GstMeta, gpointer) -> gboolean>;
pub type GstBufferListFunc =
    Option<unsafe extern "C" fn(*mut *mut GstBuffer, c_uint, gpointer) -> gboolean>;
pub type GstBusFunc =
    Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage, gpointer) -> gboolean>;
pub type GstBusSyncHandler =
    Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage, gpointer) -> GstBusSyncReply>;
pub type GstCapsFilterMapFunc =
    Option<unsafe extern "C" fn(*mut GstCapsFeatures, *mut GstStructure, gpointer) -> gboolean>;
pub type GstCapsForeachFunc =
    Option<unsafe extern "C" fn(*mut GstCapsFeatures, *mut GstStructure, gpointer) -> gboolean>;
pub type GstCapsMapFunc =
    Option<unsafe extern "C" fn(*mut GstCapsFeatures, *mut GstStructure, gpointer) -> gboolean>;
pub type GstClockCallback =
    Option<unsafe extern "C" fn(*mut GstClock, GstClockTime, GstClockID, gpointer) -> gboolean>;
pub type GstControlBindingConvert =
    Option<unsafe extern "C" fn(*mut GstControlBinding, c_double, *mut gobject::GValue)>;
pub type GstControlSourceGetValue =
    Option<unsafe extern "C" fn(*mut GstControlSource, GstClockTime, *mut c_double) -> gboolean>;
pub type GstControlSourceGetValueArray = Option<
    unsafe extern "C" fn(
        *mut GstControlSource,
        GstClockTime,
        GstClockTime,
        c_uint,
        *mut c_double,
    ) -> gboolean,
>;
pub type GstCustomMetaTransformFunction = Option<
    unsafe extern "C" fn(
        *mut GstBuffer,
        *mut GstCustomMeta,
        *mut GstBuffer,
        glib::GQuark,
        gpointer,
        gpointer,
    ) -> gboolean,
>;
pub type GstDebugFuncPtr = Option<unsafe extern "C" fn()>;
pub type GstElementCallAsyncFunc = Option<unsafe extern "C" fn(*mut GstElement, gpointer)>;
pub type GstElementForeachPadFunc =
    Option<unsafe extern "C" fn(*mut GstElement, *mut GstPad, gpointer) -> gboolean>;
pub type GstIteratorCopyFunction =
    Option<unsafe extern "C" fn(*const GstIterator, *mut GstIterator)>;
pub type GstIteratorFoldFunction = Option<
    unsafe extern "C" fn(*const gobject::GValue, *mut gobject::GValue, gpointer) -> gboolean,
>;
pub type GstIteratorForeachFunction =
    Option<unsafe extern "C" fn(*const gobject::GValue, gpointer)>;
pub type GstIteratorFreeFunction = Option<unsafe extern "C" fn(*mut GstIterator)>;
pub type GstIteratorItemFunction =
    Option<unsafe extern "C" fn(*mut GstIterator, *const gobject::GValue) -> GstIteratorItem>;
pub type GstIteratorNextFunction =
    Option<unsafe extern "C" fn(*mut GstIterator, *mut gobject::GValue) -> GstIteratorResult>;
pub type GstIteratorResyncFunction = Option<unsafe extern "C" fn(*mut GstIterator)>;
pub type GstLogFunction = Option<
    unsafe extern "C" fn(
        *mut GstDebugCategory,
        GstDebugLevel,
        *const c_char,
        *const c_char,
        c_int,
        *mut gobject::GObject,
        *mut GstDebugMessage,
        gpointer,
    ),
>;
pub type GstMemoryCopyFunction =
    Option<unsafe extern "C" fn(*mut GstMemory, ssize_t, ssize_t) -> *mut GstMemory>;
pub type GstMemoryIsSpanFunction =
    Option<unsafe extern "C" fn(*mut GstMemory, *mut GstMemory, *mut size_t) -> gboolean>;
pub type GstMemoryMapFullFunction =
    Option<unsafe extern "C" fn(*mut GstMemory, *mut GstMapInfo, size_t) -> gpointer>;
pub type GstMemoryMapFunction =
    Option<unsafe extern "C" fn(*mut GstMemory, size_t, GstMapFlags) -> gpointer>;
pub type GstMemoryShareFunction =
    Option<unsafe extern "C" fn(*mut GstMemory, ssize_t, ssize_t) -> *mut GstMemory>;
pub type GstMemoryUnmapFullFunction = Option<unsafe extern "C" fn(*mut GstMemory, *mut GstMapInfo)>;
pub type GstMemoryUnmapFunction = Option<unsafe extern "C" fn(*mut GstMemory)>;
pub type GstMetaFreeFunction = Option<unsafe extern "C" fn(*mut GstMeta, *mut GstBuffer)>;
pub type GstMetaInitFunction =
    Option<unsafe extern "C" fn(*mut GstMeta, gpointer, *mut GstBuffer) -> gboolean>;
pub type GstMetaTransformFunction = Option<
    unsafe extern "C" fn(
        *mut GstBuffer,
        *mut GstMeta,
        *mut GstBuffer,
        glib::GQuark,
        gpointer,
    ) -> gboolean,
>;
pub type GstMiniObjectCopyFunction =
    Option<unsafe extern "C" fn(*const GstMiniObject) -> *mut GstMiniObject>;
pub type GstMiniObjectDisposeFunction =
    Option<unsafe extern "C" fn(*mut GstMiniObject) -> gboolean>;
pub type GstMiniObjectFreeFunction = Option<unsafe extern "C" fn(*mut GstMiniObject)>;
pub type GstMiniObjectNotify = Option<unsafe extern "C" fn(gpointer, *mut GstMiniObject)>;
pub type GstPadActivateFunction =
    Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject) -> gboolean>;
pub type GstPadActivateModeFunction =
    Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, GstPadMode, gboolean) -> gboolean>;
pub type GstPadChainFunction =
    Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstBuffer) -> GstFlowReturn>;
pub type GstPadChainListFunction =
    Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstBufferList) -> GstFlowReturn>;
pub type GstPadEventFullFunction =
    Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstEvent) -> GstFlowReturn>;
pub type GstPadEventFunction =
    Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstEvent) -> gboolean>;
pub type GstPadForwardFunction = Option<unsafe extern "C" fn(*mut GstPad, gpointer) -> gboolean>;
pub type GstPadGetRangeFunction = Option<
    unsafe extern "C" fn(
        *mut GstPad,
        *mut GstObject,
        u64,
        c_uint,
        *mut *mut GstBuffer,
    ) -> GstFlowReturn,
>;
pub type GstPadIterIntLinkFunction =
    Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject) -> *mut GstIterator>;
pub type GstPadLinkFunction =
    Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstPad) -> GstPadLinkReturn>;
pub type GstPadProbeCallback =
    Option<unsafe extern "C" fn(*mut GstPad, *mut GstPadProbeInfo, gpointer) -> GstPadProbeReturn>;
pub type GstPadQueryFunction =
    Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstQuery) -> gboolean>;
pub type GstPadStickyEventsForeachFunction =
    Option<unsafe extern "C" fn(*mut GstPad, *mut *mut GstEvent, gpointer) -> gboolean>;
pub type GstPadUnlinkFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject)>;
pub type GstPluginFeatureFilter =
    Option<unsafe extern "C" fn(*mut GstPluginFeature, gpointer) -> gboolean>;
pub type GstPluginFilter = Option<unsafe extern "C" fn(*mut GstPlugin, gpointer) -> gboolean>;
pub type GstPluginInitFullFunc = Option<unsafe extern "C" fn(*mut GstPlugin, gpointer) -> gboolean>;
pub type GstPluginInitFunc = Option<unsafe extern "C" fn(*mut GstPlugin) -> gboolean>;
pub type GstPromiseChangeFunc = Option<unsafe extern "C" fn(*mut GstPromise, gpointer)>;
pub type GstStructureFilterMapFunc =
    Option<unsafe extern "C" fn(glib::GQuark, *mut gobject::GValue, gpointer) -> gboolean>;
pub type GstStructureForeachFunc =
    Option<unsafe extern "C" fn(glib::GQuark, *const gobject::GValue, gpointer) -> gboolean>;
pub type GstStructureMapFunc =
    Option<unsafe extern "C" fn(glib::GQuark, *mut gobject::GValue, gpointer) -> gboolean>;
pub type GstTagForeachFunc =
    Option<unsafe extern "C" fn(*const GstTagList, *const c_char, gpointer)>;
pub type GstTagMergeFunc =
    Option<unsafe extern "C" fn(*mut gobject::GValue, *const gobject::GValue)>;
pub type GstTaskFunction = Option<unsafe extern "C" fn(gpointer)>;
pub type GstTaskPoolFunction = Option<unsafe extern "C" fn(*mut c_void)>;
pub type GstTaskThreadFunc =
    Option<unsafe extern "C" fn(*mut GstTask, *mut glib::GThread, gpointer)>;
pub type GstTypeFindFunction = Option<unsafe extern "C" fn(*mut GstTypeFind, gpointer)>;
pub type GstValueCompareFunc =
    Option<unsafe extern "C" fn(*const gobject::GValue, *const gobject::GValue) -> c_int>;
pub type GstValueDeserializeFunc =
    Option<unsafe extern "C" fn(*mut gobject::GValue, *const c_char) -> gboolean>;
pub type GstValueDeserializeWithPSpecFunc = Option<
    unsafe extern "C" fn(*mut gobject::GValue, *const c_char, *mut gobject::GParamSpec) -> gboolean,
>;
pub type GstValueSerializeFunc =
    Option<unsafe extern "C" fn(*const gobject::GValue) -> *mut c_char>;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAllocationParams {
    pub flags: GstMemoryFlags,
    pub align: size_t,
    pub prefix: size_t,
    pub padding: size_t,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAllocationParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAllocationParams @ {self:p}"))
            .field("flags", &self.flags)
            .field("align", &self.align)
            .field("prefix", &self.prefix)
            .field("padding", &self.padding)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAllocatorClass {
    pub object_class: GstObjectClass,
    pub alloc: Option<
        unsafe extern "C" fn(*mut GstAllocator, size_t, *mut GstAllocationParams) -> *mut GstMemory,
    >,
    pub free: Option<unsafe extern "C" fn(*mut GstAllocator, *mut GstMemory)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAllocatorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAllocatorClass @ {self:p}"))
            .field("object_class", &self.object_class)
            .field("alloc", &self.alloc)
            .field("free", &self.free)
            .finish()
    }
}

#[repr(C)]
pub struct _GstAllocatorPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAllocatorPrivate = *mut _GstAllocatorPrivate;

#[repr(C)]
pub struct GstAtomicQueue {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstAtomicQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAtomicQueue @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstBinClass {
    pub parent_class: GstElementClass,
    pub pool: *mut glib::GThreadPool,
    pub element_added: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement)>,
    pub element_removed: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement)>,
    pub add_element: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement) -> gboolean>,
    pub remove_element: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement) -> gboolean>,
    pub handle_message: Option<unsafe extern "C" fn(*mut GstBin, *mut GstMessage)>,
    pub do_latency: Option<unsafe extern "C" fn(*mut GstBin) -> gboolean>,
    pub deep_element_added: Option<unsafe extern "C" fn(*mut GstBin, *mut GstBin, *mut GstElement)>,
    pub deep_element_removed:
        Option<unsafe extern "C" fn(*mut GstBin, *mut GstBin, *mut GstElement)>,
    pub _gst_reserved: [gpointer; 2],
}

impl ::std::fmt::Debug for GstBinClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBinClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("element_added", &self.element_added)
            .field("element_removed", &self.element_removed)
            .field("add_element", &self.add_element)
            .field("remove_element", &self.remove_element)
            .field("handle_message", &self.handle_message)
            .field("do_latency", &self.do_latency)
            .field("deep_element_added", &self.deep_element_added)
            .field("deep_element_removed", &self.deep_element_removed)
            .finish()
    }
}

#[repr(C)]
pub struct _GstBinPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstBinPrivate = *mut _GstBinPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstBuffer {
    pub mini_object: GstMiniObject,
    pub pool: *mut GstBufferPool,
    pub pts: GstClockTime,
    pub dts: GstClockTime,
    pub duration: GstClockTime,
    pub offset: u64,
    pub offset_end: u64,
}

impl ::std::fmt::Debug for GstBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBuffer @ {self:p}"))
            .field("mini_object", &self.mini_object)
            .field("pool", &self.pool)
            .field("pts", &self.pts)
            .field("dts", &self.dts)
            .field("duration", &self.duration)
            .field("offset", &self.offset)
            .field("offset_end", &self.offset_end)
            .finish()
    }
}

#[repr(C)]
pub struct GstBufferList {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstBufferList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBufferList @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstBufferPoolAcquireParams {
    pub format: GstFormat,
    pub start: i64,
    pub stop: i64,
    pub flags: GstBufferPoolAcquireFlags,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstBufferPoolAcquireParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBufferPoolAcquireParams @ {self:p}"))
            .field("format", &self.format)
            .field("start", &self.start)
            .field("stop", &self.stop)
            .field("flags", &self.flags)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstBufferPoolClass {
    pub object_class: GstObjectClass,
    pub get_options: Option<unsafe extern "C" fn(*mut GstBufferPool) -> *mut *const c_char>,
    pub set_config: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstStructure) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GstBufferPool) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstBufferPool) -> gboolean>,
    pub acquire_buffer: Option<
        unsafe extern "C" fn(
            *mut GstBufferPool,
            *mut *mut GstBuffer,
            *mut GstBufferPoolAcquireParams,
        ) -> GstFlowReturn,
    >,
    pub alloc_buffer: Option<
        unsafe extern "C" fn(
            *mut GstBufferPool,
            *mut *mut GstBuffer,
            *mut GstBufferPoolAcquireParams,
        ) -> GstFlowReturn,
    >,
    pub reset_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstBuffer)>,
    pub release_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstBuffer)>,
    pub free_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstBuffer)>,
    pub flush_start: Option<unsafe extern "C" fn(*mut GstBufferPool)>,
    pub flush_stop: Option<unsafe extern "C" fn(*mut GstBufferPool)>,
    pub _gst_reserved: [gpointer; 2],
}

impl ::std::fmt::Debug for GstBufferPoolClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBufferPoolClass @ {self:p}"))
            .field("object_class", &self.object_class)
            .field("get_options", &self.get_options)
            .field("set_config", &self.set_config)
            .field("start", &self.start)
            .field("stop", &self.stop)
            .field("acquire_buffer", &self.acquire_buffer)
            .field("alloc_buffer", &self.alloc_buffer)
            .field("reset_buffer", &self.reset_buffer)
            .field("release_buffer", &self.release_buffer)
            .field("free_buffer", &self.free_buffer)
            .field("flush_start", &self.flush_start)
            .field("flush_stop", &self.flush_stop)
            .finish()
    }
}

#[repr(C)]
pub struct _GstBufferPoolPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstBufferPoolPrivate = *mut _GstBufferPoolPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstBusClass {
    pub parent_class: GstObjectClass,
    pub message: Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage)>,
    pub sync_message: Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstBusClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBusClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("message", &self.message)
            .field("sync_message", &self.sync_message)
            .finish()
    }
}

#[repr(C)]
pub struct _GstBusPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstBusPrivate = *mut _GstBusPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstCaps {
    pub mini_object: GstMiniObject,
}

impl ::std::fmt::Debug for GstCaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstCaps @ {self:p}"))
            .field("mini_object", &self.mini_object)
            .finish()
    }
}

#[repr(C)]
pub struct GstCapsFeatures {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstCapsFeatures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstCapsFeatures @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstChildProxyInterface {
    pub parent: gobject::GTypeInterface,
    pub get_child_by_name:
        Option<unsafe extern "C" fn(*mut GstChildProxy, *const c_char) -> *mut gobject::GObject>,
    pub get_child_by_index:
        Option<unsafe extern "C" fn(*mut GstChildProxy, c_uint) -> *mut gobject::GObject>,
    pub get_children_count: Option<unsafe extern "C" fn(*mut GstChildProxy) -> c_uint>,
    pub child_added:
        Option<unsafe extern "C" fn(*mut GstChildProxy, *mut gobject::GObject, *const c_char)>,
    pub child_removed:
        Option<unsafe extern "C" fn(*mut GstChildProxy, *mut gobject::GObject, *const c_char)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstChildProxyInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstChildProxyInterface @ {self:p}"))
            .field("parent", &self.parent)
            .field("get_child_by_name", &self.get_child_by_name)
            .field("get_child_by_index", &self.get_child_by_index)
            .field("get_children_count", &self.get_children_count)
            .field("child_added", &self.child_added)
            .field("child_removed", &self.child_removed)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstClockClass {
    pub parent_class: GstObjectClass,
    pub change_resolution:
        Option<unsafe extern "C" fn(*mut GstClock, GstClockTime, GstClockTime) -> GstClockTime>,
    pub get_resolution: Option<unsafe extern "C" fn(*mut GstClock) -> GstClockTime>,
    pub get_internal_time: Option<unsafe extern "C" fn(*mut GstClock) -> GstClockTime>,
    pub wait: Option<
        unsafe extern "C" fn(
            *mut GstClock,
            *mut GstClockEntry,
            *mut GstClockTimeDiff,
        ) -> GstClockReturn,
    >,
    pub wait_async:
        Option<unsafe extern "C" fn(*mut GstClock, *mut GstClockEntry) -> GstClockReturn>,
    pub unschedule: Option<unsafe extern "C" fn(*mut GstClock, *mut GstClockEntry)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstClockClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstClockClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("change_resolution", &self.change_resolution)
            .field("get_resolution", &self.get_resolution)
            .field("get_internal_time", &self.get_internal_time)
            .field("wait", &self.wait)
            .field("wait_async", &self.wait_async)
            .field("unschedule", &self.unschedule)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstClockEntry {
    pub refcount: c_int,
    pub clock: *mut GstClock,
    pub type_: GstClockEntryType,
    pub time: GstClockTime,
    pub interval: GstClockTime,
    pub status: GstClockReturn,
    pub func: GstClockCallback,
    pub user_data: gpointer,
    pub destroy_data: glib::GDestroyNotify,
    pub unscheduled: gboolean,
    pub woken_up: gboolean,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstClockEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstClockEntry @ {self:p}"))
            .field("refcount", &self.refcount)
            .finish()
    }
}

#[repr(C)]
pub struct _GstClockPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstClockPrivate = *mut _GstClockPrivate;

#[repr(C)]
pub struct GstContext {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstContext @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstControlBindingClass {
    pub parent_class: GstObjectClass,
    pub sync_values: Option<
        unsafe extern "C" fn(
            *mut GstControlBinding,
            *mut GstObject,
            GstClockTime,
            GstClockTime,
        ) -> gboolean,
    >,
    pub get_value:
        Option<unsafe extern "C" fn(*mut GstControlBinding, GstClockTime) -> *mut gobject::GValue>,
    pub get_value_array: Option<
        unsafe extern "C" fn(
            *mut GstControlBinding,
            GstClockTime,
            GstClockTime,
            c_uint,
            gpointer,
        ) -> gboolean,
    >,
    pub get_g_value_array: Option<
        unsafe extern "C" fn(
            *mut GstControlBinding,
            GstClockTime,
            GstClockTime,
            c_uint,
            *mut gobject::GValue,
        ) -> gboolean,
    >,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstControlBindingClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlBindingClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("sync_values", &self.sync_values)
            .field("get_value", &self.get_value)
            .field("get_value_array", &self.get_value_array)
            .field("get_g_value_array", &self.get_g_value_array)
            .finish()
    }
}

#[repr(C)]
pub struct _GstControlBindingPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstControlBindingPrivate = *mut _GstControlBindingPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstControlBinding_ABI_abi {
    pub priv_: *mut GstControlBindingPrivate,
}

impl ::std::fmt::Debug for GstControlBinding_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlBinding_ABI_abi @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstControlSourceClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstControlSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlSourceClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstCustomMeta {
    pub meta: GstMeta,
}

impl ::std::fmt::Debug for GstCustomMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstCustomMeta @ {self:p}"))
            .field("meta", &self.meta)
            .finish()
    }
}

#[repr(C)]
pub struct GstDateTime {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstDateTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDateTime @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstDebugCategory {
    pub threshold: c_int,
    pub color: c_uint,
    pub name: *const c_char,
    pub description: *const c_char,
}

impl ::std::fmt::Debug for GstDebugCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDebugCategory @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct _GstDebugMessage {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstDebugMessage = *mut _GstDebugMessage;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstDeviceClass {
    pub parent_class: GstObjectClass,
    pub create_element:
        Option<unsafe extern "C" fn(*mut GstDevice, *const c_char) -> *mut GstElement>,
    pub reconfigure_element:
        Option<unsafe extern "C" fn(*mut GstDevice, *mut GstElement) -> gboolean>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("create_element", &self.create_element)
            .field("reconfigure_element", &self.reconfigure_element)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstDeviceMonitorClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDeviceMonitorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceMonitorClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GstDeviceMonitorPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstDeviceMonitorPrivate = *mut _GstDeviceMonitorPrivate;

#[repr(C)]
pub struct _GstDevicePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstDevicePrivate = *mut _GstDevicePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstDeviceProviderClass {
    pub parent_class: GstObjectClass,
    pub factory: *mut GstDeviceProviderFactory,
    pub probe: Option<unsafe extern "C" fn(*mut GstDeviceProvider) -> *mut glib::GList>,
    pub start: Option<unsafe extern "C" fn(*mut GstDeviceProvider) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstDeviceProvider)>,
    pub metadata: gpointer,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDeviceProviderClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceProviderClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("factory", &self.factory)
            .field("probe", &self.probe)
            .field("start", &self.start)
            .field("stop", &self.stop)
            .finish()
    }
}

#[repr(C)]
pub struct _GstDeviceProviderFactoryClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstDeviceProviderFactoryClass = *mut _GstDeviceProviderFactoryClass;

#[repr(C)]
pub struct _GstDeviceProviderPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstDeviceProviderPrivate = *mut _GstDeviceProviderPrivate;

#[repr(C)]
pub struct _GstDynamicTypeFactoryClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstDynamicTypeFactoryClass = *mut _GstDynamicTypeFactoryClass;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstElementClass {
    pub parent_class: GstObjectClass,
    pub metadata: gpointer,
    pub elementfactory: *mut GstElementFactory,
    pub padtemplates: *mut glib::GList,
    pub numpadtemplates: c_int,
    pub pad_templ_cookie: u32,
    pub pad_added: Option<unsafe extern "C" fn(*mut GstElement, *mut GstPad)>,
    pub pad_removed: Option<unsafe extern "C" fn(*mut GstElement, *mut GstPad)>,
    pub no_more_pads: Option<unsafe extern "C" fn(*mut GstElement)>,
    pub request_new_pad: Option<
        unsafe extern "C" fn(
            *mut GstElement,
            *mut GstPadTemplate,
            *const c_char,
            *const GstCaps,
        ) -> *mut GstPad,
    >,
    pub release_pad: Option<unsafe extern "C" fn(*mut GstElement, *mut GstPad)>,
    pub get_state: Option<
        unsafe extern "C" fn(
            *mut GstElement,
            *mut GstState,
            *mut GstState,
            GstClockTime,
        ) -> GstStateChangeReturn,
    >,
    pub set_state: Option<unsafe extern "C" fn(*mut GstElement, GstState) -> GstStateChangeReturn>,
    pub change_state:
        Option<unsafe extern "C" fn(*mut GstElement, GstStateChange) -> GstStateChangeReturn>,
    pub state_changed: Option<unsafe extern "C" fn(*mut GstElement, GstState, GstState, GstState)>,
    pub set_bus: Option<unsafe extern "C" fn(*mut GstElement, *mut GstBus)>,
    pub provide_clock: Option<unsafe extern "C" fn(*mut GstElement) -> *mut GstClock>,
    pub set_clock: Option<unsafe extern "C" fn(*mut GstElement, *mut GstClock) -> gboolean>,
    pub send_event: Option<unsafe extern "C" fn(*mut GstElement, *mut GstEvent) -> gboolean>,
    pub query: Option<unsafe extern "C" fn(*mut GstElement, *mut GstQuery) -> gboolean>,
    pub post_message: Option<unsafe extern "C" fn(*mut GstElement, *mut GstMessage) -> gboolean>,
    pub set_context: Option<unsafe extern "C" fn(*mut GstElement, *mut GstContext)>,
    pub _gst_reserved: [gpointer; 18],
}

impl ::std::fmt::Debug for GstElementClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstElementClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("metadata", &self.metadata)
            .field("elementfactory", &self.elementfactory)
            .field("padtemplates", &self.padtemplates)
            .field("numpadtemplates", &self.numpadtemplates)
            .field("pad_templ_cookie", &self.pad_templ_cookie)
            .field("pad_added", &self.pad_added)
            .field("pad_removed", &self.pad_removed)
            .field("no_more_pads", &self.no_more_pads)
            .field("request_new_pad", &self.request_new_pad)
            .field("release_pad", &self.release_pad)
            .field("get_state", &self.get_state)
            .field("set_state", &self.set_state)
            .field("change_state", &self.change_state)
            .field("state_changed", &self.state_changed)
            .field("set_bus", &self.set_bus)
            .field("provide_clock", &self.provide_clock)
            .field("set_clock", &self.set_clock)
            .field("send_event", &self.send_event)
            .field("query", &self.query)
            .field("post_message", &self.post_message)
            .field("set_context", &self.set_context)
            .finish()
    }
}

#[repr(C)]
pub struct _GstElementFactoryClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstElementFactoryClass = *mut _GstElementFactoryClass;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstEvent {
    pub mini_object: GstMiniObject,
    pub type_: GstEventType,
    pub timestamp: u64,
    pub seqnum: u32,
}

impl ::std::fmt::Debug for GstEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstEvent @ {self:p}"))
            .field("mini_object", &self.mini_object)
            .field("type_", &self.type_)
            .field("timestamp", &self.timestamp)
            .field("seqnum", &self.seqnum)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstFormatDefinition {
    pub value: GstFormat,
    pub nick: *const c_char,
    pub description: *const c_char,
    pub quark: glib::GQuark,
}

impl ::std::fmt::Debug for GstFormatDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstFormatDefinition @ {self:p}"))
            .field("value", &self.value)
            .field("nick", &self.nick)
            .field("description", &self.description)
            .field("quark", &self.quark)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstGhostPadClass {
    pub parent_class: GstProxyPadClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstGhostPadClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstGhostPadClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GstGhostPadPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstGhostPadPrivate = *mut _GstGhostPadPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstIterator {
    pub copy: GstIteratorCopyFunction,
    pub next: GstIteratorNextFunction,
    pub item: GstIteratorItemFunction,
    pub resync: GstIteratorResyncFunction,
    pub free: GstIteratorFreeFunction,
    pub pushed: *mut GstIterator,
    pub type_: GType,
    pub lock: *mut glib::GMutex,
    pub cookie: u32,
    pub master_cookie: *mut u32,
    pub size: c_uint,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstIterator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstIterator @ {self:p}"))
            .field("copy", &self.copy)
            .field("next", &self.next)
            .field("item", &self.item)
            .field("resync", &self.resync)
            .field("free", &self.free)
            .field("pushed", &self.pushed)
            .field("type_", &self.type_)
            .field("lock", &self.lock)
            .field("cookie", &self.cookie)
            .field("master_cookie", &self.master_cookie)
            .field("size", &self.size)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstMapInfo {
    pub memory: *mut GstMemory,
    pub flags: GstMapFlags,
    pub data: *mut u8,
    pub size: size_t,
    pub maxsize: size_t,
    pub user_data: [gpointer; 4],
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstMapInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMapInfo @ {self:p}"))
            .field("memory", &self.memory)
            .field("flags", &self.flags)
            .field("data", &self.data)
            .field("size", &self.size)
            .field("maxsize", &self.maxsize)
            .field("user_data", &self.user_data)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstMemory {
    pub mini_object: GstMiniObject,
    pub allocator: *mut GstAllocator,
    pub parent: *mut GstMemory,
    pub maxsize: size_t,
    pub align: size_t,
    pub offset: size_t,
    pub size: size_t,
}

impl ::std::fmt::Debug for GstMemory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMemory @ {self:p}"))
            .field("mini_object", &self.mini_object)
            .field("allocator", &self.allocator)
            .field("parent", &self.parent)
            .field("maxsize", &self.maxsize)
            .field("align", &self.align)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstMessage {
    pub mini_object: GstMiniObject,
    pub type_: GstMessageType,
    pub timestamp: u64,
    pub src: *mut GstObject,
    pub seqnum: u32,
    pub lock: glib::GMutex,
    pub cond: glib::GCond,
}

impl ::std::fmt::Debug for GstMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMessage @ {self:p}"))
            .field("mini_object", &self.mini_object)
            .field("type_", &self.type_)
            .field("timestamp", &self.timestamp)
            .field("src", &self.src)
            .field("seqnum", &self.seqnum)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstMeta {
    pub flags: GstMetaFlags,
    pub info: *const GstMetaInfo,
}

impl ::std::fmt::Debug for GstMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMeta @ {self:p}"))
            .field("flags", &self.flags)
            .field("info", &self.info)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstMetaInfo {
    pub api: GType,
    pub type_: GType,
    pub size: size_t,
    pub init_func: GstMetaInitFunction,
    pub free_func: GstMetaFreeFunction,
    pub transform_func: GstMetaTransformFunction,
}

impl ::std::fmt::Debug for GstMetaInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMetaInfo @ {self:p}"))
            .field("api", &self.api)
            .field("type_", &self.type_)
            .field("size", &self.size)
            .field("init_func", &self.init_func)
            .field("free_func", &self.free_func)
            .field("transform_func", &self.transform_func)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstMetaTransformCopy {
    pub region: gboolean,
    pub offset: size_t,
    pub size: size_t,
}

impl ::std::fmt::Debug for GstMetaTransformCopy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMetaTransformCopy @ {self:p}"))
            .field("region", &self.region)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstMiniObject {
    pub type_: GType,
    pub refcount: c_int,
    pub lockstate: c_int,
    pub flags: c_uint,
    pub copy: GstMiniObjectCopyFunction,
    pub dispose: GstMiniObjectDisposeFunction,
    pub free: GstMiniObjectFreeFunction,
    pub priv_uint: c_uint,
    pub priv_pointer: gpointer,
}

impl ::std::fmt::Debug for GstMiniObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMiniObject @ {self:p}"))
            .field("type_", &self.type_)
            .field("refcount", &self.refcount)
            .field("lockstate", &self.lockstate)
            .field("flags", &self.flags)
            .field("copy", &self.copy)
            .field("dispose", &self.dispose)
            .field("free", &self.free)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstObjectClass {
    pub parent_class: gobject::GInitiallyUnownedClass,
    pub path_string_separator: *const c_char,
    pub deep_notify:
        Option<unsafe extern "C" fn(*mut GstObject, *mut GstObject, *mut gobject::GParamSpec)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstObjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstObjectClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("path_string_separator", &self.path_string_separator)
            .field("deep_notify", &self.deep_notify)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPadClass {
    pub parent_class: GstObjectClass,
    pub linked: Option<unsafe extern "C" fn(*mut GstPad, *mut GstPad)>,
    pub unlinked: Option<unsafe extern "C" fn(*mut GstPad, *mut GstPad)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPadClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("linked", &self.linked)
            .field("unlinked", &self.unlinked)
            .finish()
    }
}

#[repr(C)]
pub struct _GstPadPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstPadPrivate = *mut _GstPadPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPadProbeInfo {
    pub type_: GstPadProbeType,
    pub id: c_ulong,
    pub data: gpointer,
    pub offset: u64,
    pub size: c_uint,
    pub ABI: GstPadProbeInfo_ABI,
}

impl ::std::fmt::Debug for GstPadProbeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadProbeInfo @ {self:p}"))
            .field("type_", &self.type_)
            .field("id", &self.id)
            .field("data", &self.data)
            .field("offset", &self.offset)
            .field("size", &self.size)
            .field("ABI", &self.ABI)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPadProbeInfo_ABI_abi {
    pub flow_ret: GstFlowReturn,
}

impl ::std::fmt::Debug for GstPadProbeInfo_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadProbeInfo_ABI_abi @ {self:p}"))
            .field("flow_ret", &self.flow_ret)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPadTemplateClass {
    pub parent_class: GstObjectClass,
    pub pad_created: Option<unsafe extern "C" fn(*mut GstPadTemplate, *mut GstPad)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPadTemplateClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadTemplateClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("pad_created", &self.pad_created)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPadTemplate_ABI_abi {
    pub gtype: GType,
    pub documentation_caps: *mut GstCaps,
}

impl ::std::fmt::Debug for GstPadTemplate_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadTemplate_ABI_abi @ {self:p}"))
            .field("gtype", &self.gtype)
            .field("documentation_caps", &self.documentation_caps)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPad_ABI_abi {
    pub last_flowret: GstFlowReturn,
    pub eventfullfunc: GstPadEventFullFunction,
}

impl ::std::fmt::Debug for GstPad_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPad_ABI_abi @ {self:p}"))
            .field("last_flowret", &self.last_flowret)
            .field("eventfullfunc", &self.eventfullfunc)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstParamSpecArray {
    pub parent_instance: gobject::GParamSpec,
    pub element_spec: *mut gobject::GParamSpec,
}

impl ::std::fmt::Debug for GstParamSpecArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParamSpecArray @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("element_spec", &self.element_spec)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstParamSpecFraction {
    pub parent_instance: gobject::GParamSpec,
    pub min_num: c_int,
    pub min_den: c_int,
    pub max_num: c_int,
    pub max_den: c_int,
    pub def_num: c_int,
    pub def_den: c_int,
}

impl ::std::fmt::Debug for GstParamSpecFraction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParamSpecFraction @ {self:p}"))
            .field("parent_instance", &self.parent_instance)
            .field("min_num", &self.min_num)
            .field("min_den", &self.min_den)
            .field("max_num", &self.max_num)
            .field("max_den", &self.max_den)
            .field("def_num", &self.def_num)
            .field("def_den", &self.def_den)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstParentBufferMeta {
    pub parent: GstMeta,
    pub buffer: *mut GstBuffer,
}

impl ::std::fmt::Debug for GstParentBufferMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParentBufferMeta @ {self:p}"))
            .field("parent", &self.parent)
            .field("buffer", &self.buffer)
            .finish()
    }
}

#[repr(C)]
pub struct GstParseContext {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstParseContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParseContext @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPipelineClass {
    pub parent_class: GstBinClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPipelineClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPipelineClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GstPipelinePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstPipelinePrivate = *mut _GstPipelinePrivate;

#[repr(C)]
pub struct _GstPluginClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstPluginClass = *mut _GstPluginClass;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPluginDesc {
    pub major_version: c_int,
    pub minor_version: c_int,
    pub name: *const c_char,
    pub description: *const c_char,
    pub plugin_init: GstPluginInitFunc,
    pub version: *const c_char,
    pub license: *const c_char,
    pub source: *const c_char,
    pub package: *const c_char,
    pub origin: *const c_char,
    pub release_datetime: *const c_char,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPluginDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPluginDesc @ {self:p}"))
            .field("major_version", &self.major_version)
            .field("minor_version", &self.minor_version)
            .field("name", &self.name)
            .field("description", &self.description)
            .field("plugin_init", &self.plugin_init)
            .field("version", &self.version)
            .field("license", &self.license)
            .field("source", &self.source)
            .field("package", &self.package)
            .field("origin", &self.origin)
            .field("release_datetime", &self.release_datetime)
            .finish()
    }
}

#[repr(C)]
pub struct _GstPluginFeatureClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstPluginFeatureClass = *mut _GstPluginFeatureClass;

#[repr(C)]
pub struct _GstPoll {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstPoll = *mut _GstPoll;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPollFD {
    pub fd: c_int,
    pub idx: c_int,
}

impl ::std::fmt::Debug for GstPollFD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPollFD @ {self:p}"))
            .field("fd", &self.fd)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPresetInterface {
    pub parent: gobject::GTypeInterface,
    pub get_preset_names: Option<unsafe extern "C" fn(*mut GstPreset) -> *mut *mut c_char>,
    pub get_property_names: Option<unsafe extern "C" fn(*mut GstPreset) -> *mut *mut c_char>,
    pub load_preset: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char) -> gboolean>,
    pub save_preset: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char) -> gboolean>,
    pub rename_preset:
        Option<unsafe extern "C" fn(*mut GstPreset, *const c_char, *const c_char) -> gboolean>,
    pub delete_preset: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char) -> gboolean>,
    pub set_meta: Option<
        unsafe extern "C" fn(
            *mut GstPreset,
            *const c_char,
            *const c_char,
            *mut *mut c_char,
        ) -> gboolean,
    >,
    pub get_meta: Option<
        unsafe extern "C" fn(
            *mut GstPreset,
            *const c_char,
            *const c_char,
            *mut *mut c_char,
        ) -> gboolean,
    >,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPresetInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPresetInterface @ {self:p}"))
            .field("parent", &self.parent)
            .field("get_preset_names", &self.get_preset_names)
            .field("get_property_names", &self.get_property_names)
            .field("load_preset", &self.load_preset)
            .field("save_preset", &self.save_preset)
            .field("rename_preset", &self.rename_preset)
            .field("delete_preset", &self.delete_preset)
            .field("set_meta", &self.set_meta)
            .field("get_meta", &self.get_meta)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPromise {
    pub parent: GstMiniObject,
}

impl ::std::fmt::Debug for GstPromise {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPromise @ {self:p}"))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstProtectionMeta {
    pub meta: GstMeta,
    pub info: *mut GstStructure,
}

impl ::std::fmt::Debug for GstProtectionMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstProtectionMeta @ {self:p}"))
            .field("meta", &self.meta)
            .field("info", &self.info)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstProxyPadClass {
    pub parent_class: GstPadClass,
    pub _gst_reserved: [gpointer; 1],
}

impl ::std::fmt::Debug for GstProxyPadClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstProxyPadClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GstProxyPadPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstProxyPadPrivate = *mut _GstProxyPadPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstQuery {
    pub mini_object: GstMiniObject,
    pub type_: GstQueryType,
}

impl ::std::fmt::Debug for GstQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstQuery @ {self:p}"))
            .field("mini_object", &self.mini_object)
            .field("type_", &self.type_)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstReferenceTimestampMeta {
    pub parent: GstMeta,
    pub reference: *mut GstCaps,
    pub timestamp: GstClockTime,
    pub duration: GstClockTime,
}

impl ::std::fmt::Debug for GstReferenceTimestampMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstReferenceTimestampMeta @ {self:p}"))
            .field("parent", &self.parent)
            .field("reference", &self.reference)
            .field("timestamp", &self.timestamp)
            .field("duration", &self.duration)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstRegistryClass {
    pub parent_class: GstObjectClass,
}

impl ::std::fmt::Debug for GstRegistryClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstRegistryClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GstRegistryPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstRegistryPrivate = *mut _GstRegistryPrivate;

#[repr(C)]
pub struct GstSample {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstSample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstSample @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstSegment {
    pub flags: GstSegmentFlags,
    pub rate: c_double,
    pub applied_rate: c_double,
    pub format: GstFormat,
    pub base: u64,
    pub offset: u64,
    pub start: u64,
    pub stop: u64,
    pub time: u64,
    pub position: u64,
    pub duration: u64,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstSegment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstSegment @ {self:p}"))
            .field("flags", &self.flags)
            .field("rate", &self.rate)
            .field("applied_rate", &self.applied_rate)
            .field("format", &self.format)
            .field("base", &self.base)
            .field("offset", &self.offset)
            .field("start", &self.start)
            .field("stop", &self.stop)
            .field("time", &self.time)
            .field("position", &self.position)
            .field("duration", &self.duration)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstSharedTaskPoolClass {
    pub parent_class: GstTaskPoolClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstSharedTaskPoolClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstSharedTaskPoolClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GstSharedTaskPoolPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstSharedTaskPoolPrivate = *mut _GstSharedTaskPoolPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstStaticCaps {
    pub caps: *mut GstCaps,
    pub string: *const c_char,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstStaticCaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStaticCaps @ {self:p}"))
            .field("caps", &self.caps)
            .field("string", &self.string)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstStaticPadTemplate {
    pub name_template: *const c_char,
    pub direction: GstPadDirection,
    pub presence: GstPadPresence,
    pub static_caps: GstStaticCaps,
}

impl ::std::fmt::Debug for GstStaticPadTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStaticPadTemplate @ {self:p}"))
            .field("name_template", &self.name_template)
            .field("direction", &self.direction)
            .field("presence", &self.presence)
            .field("static_caps", &self.static_caps)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstStreamClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstStreamClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStreamClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstStreamCollectionClass {
    pub parent_class: GstObjectClass,
    pub stream_notify: Option<
        unsafe extern "C" fn(*mut GstStreamCollection, *mut GstStream, *mut gobject::GParamSpec),
    >,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstStreamCollectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStreamCollectionClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("stream_notify", &self.stream_notify)
            .finish()
    }
}

#[repr(C)]
pub struct _GstStreamCollectionPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstStreamCollectionPrivate = *mut _GstStreamCollectionPrivate;

#[repr(C)]
pub struct _GstStreamPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstStreamPrivate = *mut _GstStreamPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstStructure {
    pub type_: GType,
    pub name: glib::GQuark,
}

impl ::std::fmt::Debug for GstStructure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStructure @ {self:p}"))
            .field("type_", &self.type_)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstSystemClockClass {
    pub parent_class: GstClockClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstSystemClockClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstSystemClockClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GstSystemClockPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstSystemClockPrivate = *mut _GstSystemClockPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstTagList {
    pub mini_object: GstMiniObject,
}

impl ::std::fmt::Debug for GstTagList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTagList @ {self:p}"))
            .field("mini_object", &self.mini_object)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstTagSetterInterface {
    pub g_iface: gobject::GTypeInterface,
}

impl ::std::fmt::Debug for GstTagSetterInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTagSetterInterface @ {self:p}"))
            .field("g_iface", &self.g_iface)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstTaskClass {
    pub parent_class: GstObjectClass,
    pub pool: *mut GstTaskPool,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTaskClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTaskClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstTaskPoolClass {
    pub parent_class: GstObjectClass,
    pub prepare: Option<unsafe extern "C" fn(*mut GstTaskPool, *mut *mut glib::GError)>,
    pub cleanup: Option<unsafe extern "C" fn(*mut GstTaskPool)>,
    pub push: Option<
        unsafe extern "C" fn(
            *mut GstTaskPool,
            GstTaskPoolFunction,
            gpointer,
            *mut *mut glib::GError,
        ) -> gpointer,
    >,
    pub join: Option<unsafe extern "C" fn(*mut GstTaskPool, gpointer)>,
    pub dispose_handle: Option<unsafe extern "C" fn(*mut GstTaskPool, gpointer)>,
    pub _gst_reserved: [gpointer; 3],
}

impl ::std::fmt::Debug for GstTaskPoolClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTaskPoolClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("prepare", &self.prepare)
            .field("cleanup", &self.cleanup)
            .field("push", &self.push)
            .field("join", &self.join)
            .field("dispose_handle", &self.dispose_handle)
            .finish()
    }
}

#[repr(C)]
pub struct _GstTaskPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstTaskPrivate = *mut _GstTaskPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstTimedValue {
    pub timestamp: GstClockTime,
    pub value: c_double,
}

impl ::std::fmt::Debug for GstTimedValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTimedValue @ {self:p}"))
            .field("timestamp", &self.timestamp)
            .field("value", &self.value)
            .finish()
    }
}

#[repr(C)]
pub struct GstToc {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstToc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstToc @ {self:p}")).finish()
    }
}

#[repr(C)]
pub struct GstTocEntry {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstTocEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTocEntry @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstTocSetterInterface {
    pub g_iface: gobject::GTypeInterface,
}

impl ::std::fmt::Debug for GstTocSetterInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTocSetterInterface @ {self:p}"))
            .field("g_iface", &self.g_iface)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstTracerClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTracerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTracerClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GstTracerFactoryClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstTracerFactoryClass = *mut _GstTracerFactoryClass;

#[repr(C)]
pub struct _GstTracerPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstTracerPrivate = *mut _GstTracerPrivate;

#[repr(C)]
pub struct _GstTracerRecordClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstTracerRecordClass = *mut _GstTracerRecordClass;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstTypeFind {
    pub peek: Option<unsafe extern "C" fn(gpointer, i64, c_uint) -> *const u8>,
    pub suggest: Option<unsafe extern "C" fn(gpointer, c_uint, *mut GstCaps)>,
    pub data: gpointer,
    pub get_length: Option<unsafe extern "C" fn(gpointer) -> u64>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTypeFind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTypeFind @ {self:p}"))
            .field("peek", &self.peek)
            .field("suggest", &self.suggest)
            .field("data", &self.data)
            .field("get_length", &self.get_length)
            .finish()
    }
}

#[repr(C)]
pub struct _GstTypeFindFactoryClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstTypeFindFactoryClass = *mut _GstTypeFindFactoryClass;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstURIHandlerInterface {
    pub parent: gobject::GTypeInterface,
    pub get_type: Option<unsafe extern "C" fn(GType) -> GstURIType>,
    pub get_protocols: Option<unsafe extern "C" fn(GType) -> *const *const c_char>,
    pub get_uri: Option<unsafe extern "C" fn(*mut GstURIHandler) -> *mut c_char>,
    pub set_uri: Option<
        unsafe extern "C" fn(*mut GstURIHandler, *const c_char, *mut *mut glib::GError) -> gboolean,
    >,
}

impl ::std::fmt::Debug for GstURIHandlerInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstURIHandlerInterface @ {self:p}"))
            .field("parent", &self.parent)
            .field("get_type", &self.get_type)
            .field("get_protocols", &self.get_protocols)
            .field("get_uri", &self.get_uri)
            .field("set_uri", &self.set_uri)
            .finish()
    }
}

#[repr(C)]
pub struct GstUri {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstUri {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstUri @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstValueTable {
    pub type_: GType,
    pub compare: GstValueCompareFunc,
    pub serialize: GstValueSerializeFunc,
    pub deserialize: GstValueDeserializeFunc,
    pub deserialize_with_pspec: GstValueDeserializeWithPSpecFunc,
    pub _gst_reserved: [gpointer; 3],
}

impl ::std::fmt::Debug for GstValueTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstValueTable @ {self:p}"))
            .field("type_", &self.type_)
            .field("compare", &self.compare)
            .field("serialize", &self.serialize)
            .field("deserialize", &self.deserialize)
            .field("deserialize_with_pspec", &self.deserialize_with_pspec)
            .finish()
    }
}

// Classes
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAllocator {
    pub object: GstObject,
    pub mem_type: *const c_char,
    pub mem_map: GstMemoryMapFunction,
    pub mem_unmap: GstMemoryUnmapFunction,
    pub mem_copy: GstMemoryCopyFunction,
    pub mem_share: GstMemoryShareFunction,
    pub mem_is_span: GstMemoryIsSpanFunction,
    pub mem_map_full: GstMemoryMapFullFunction,
    pub mem_unmap_full: GstMemoryUnmapFullFunction,
    pub _gst_reserved: [gpointer; 2],
    pub priv_: *mut GstAllocatorPrivate,
}

impl ::std::fmt::Debug for GstAllocator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAllocator @ {self:p}"))
            .field("object", &self.object)
            .field("mem_type", &self.mem_type)
            .field("mem_map", &self.mem_map)
            .field("mem_unmap", &self.mem_unmap)
            .field("mem_copy", &self.mem_copy)
            .field("mem_share", &self.mem_share)
            .field("mem_is_span", &self.mem_is_span)
            .field("mem_map_full", &self.mem_map_full)
            .field("mem_unmap_full", &self.mem_unmap_full)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstBin {
    pub element: GstElement,
    pub numchildren: c_int,
    pub children: *mut glib::GList,
    pub children_cookie: u32,
    pub child_bus: *mut GstBus,
    pub messages: *mut glib::GList,
    pub polling: gboolean,
    pub state_dirty: gboolean,
    pub clock_dirty: gboolean,
    pub provided_clock: *mut GstClock,
    pub clock_provider: *mut GstElement,
    pub priv_: *mut GstBinPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstBin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBin @ {self:p}"))
            .field("element", &self.element)
            .field("numchildren", &self.numchildren)
            .field("children", &self.children)
            .field("children_cookie", &self.children_cookie)
            .field("child_bus", &self.child_bus)
            .field("messages", &self.messages)
            .field("polling", &self.polling)
            .field("state_dirty", &self.state_dirty)
            .field("clock_dirty", &self.clock_dirty)
            .field("provided_clock", &self.provided_clock)
            .field("clock_provider", &self.clock_provider)
            .finish()
    }
}

#[repr(C)]
pub struct GstBitmask {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstBitmask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBitmask @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstBufferPool {
    pub object: GstObject,
    pub flushing: c_int,
    pub priv_: *mut GstBufferPoolPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstBufferPool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBufferPool @ {self:p}"))
            .field("object", &self.object)
            .field("flushing", &self.flushing)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstBus {
    pub object: GstObject,
    pub priv_: *mut GstBusPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstBus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBus @ {self:p}"))
            .field("object", &self.object)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstClock {
    pub object: GstObject,
    pub priv_: *mut GstClockPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstClock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstClock @ {self:p}"))
            .field("object", &self.object)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstControlBinding {
    pub parent: GstObject,
    pub name: *mut c_char,
    pub pspec: *mut gobject::GParamSpec,
    pub object: *mut GstObject,
    pub disabled: gboolean,
    pub ABI: GstControlBinding_ABI,
}

impl ::std::fmt::Debug for GstControlBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlBinding @ {self:p}"))
            .field("parent", &self.parent)
            .field("name", &self.name)
            .field("pspec", &self.pspec)
            .field("ABI", &self.ABI)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstControlSource {
    pub parent: GstObject,
    pub get_value: GstControlSourceGetValue,
    pub get_value_array: GstControlSourceGetValueArray,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstControlSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlSource @ {self:p}"))
            .field("parent", &self.parent)
            .field("get_value", &self.get_value)
            .field("get_value_array", &self.get_value_array)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstDevice {
    pub parent: GstObject,
    pub priv_: *mut GstDevicePrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDevice @ {self:p}"))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstDeviceMonitor {
    pub parent: GstObject,
    pub priv_: *mut GstDeviceMonitorPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDeviceMonitor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceMonitor @ {self:p}"))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstDeviceProvider {
    pub parent: GstObject,
    pub devices: *mut glib::GList,
    pub priv_: *mut GstDeviceProviderPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDeviceProvider {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceProvider @ {self:p}"))
            .field("parent", &self.parent)
            .field("devices", &self.devices)
            .finish()
    }
}

#[repr(C)]
pub struct GstDeviceProviderFactory {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstDeviceProviderFactory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceProviderFactory @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct GstDoubleRange {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstDoubleRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDoubleRange @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct GstDynamicTypeFactory {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstDynamicTypeFactory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDynamicTypeFactory @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstElement {
    pub object: GstObject,
    pub state_lock: glib::GRecMutex,
    pub state_cond: glib::GCond,
    pub state_cookie: u32,
    pub target_state: GstState,
    pub current_state: GstState,
    pub next_state: GstState,
    pub pending_state: GstState,
    pub last_return: GstStateChangeReturn,
    pub bus: *mut GstBus,
    pub clock: *mut GstClock,
    pub base_time: GstClockTimeDiff,
    pub start_time: GstClockTime,
    pub numpads: u16,
    pub pads: *mut glib::GList,
    pub numsrcpads: u16,
    pub srcpads: *mut glib::GList,
    pub numsinkpads: u16,
    pub sinkpads: *mut glib::GList,
    pub pads_cookie: u32,
    pub contexts: *mut glib::GList,
    pub _gst_reserved: [gpointer; 3],
}

impl ::std::fmt::Debug for GstElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstElement @ {self:p}"))
            .field("object", &self.object)
            .field("state_lock", &self.state_lock)
            .field("state_cond", &self.state_cond)
            .field("state_cookie", &self.state_cookie)
            .field("target_state", &self.target_state)
            .field("current_state", &self.current_state)
            .field("next_state", &self.next_state)
            .field("pending_state", &self.pending_state)
            .field("last_return", &self.last_return)
            .field("bus", &self.bus)
            .field("clock", &self.clock)
            .field("base_time", &self.base_time)
            .field("start_time", &self.start_time)
            .field("numpads", &self.numpads)
            .field("pads", &self.pads)
            .field("numsrcpads", &self.numsrcpads)
            .field("srcpads", &self.srcpads)
            .field("numsinkpads", &self.numsinkpads)
            .field("sinkpads", &self.sinkpads)
            .field("pads_cookie", &self.pads_cookie)
            .field("contexts", &self.contexts)
            .finish()
    }
}

#[repr(C)]
pub struct GstElementFactory {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstElementFactory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstElementFactory @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct GstFlagSet {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstFlagSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstFlagSet @ {self:p}")).finish()
    }
}

#[repr(C)]
pub struct GstFraction {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstFraction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstFraction @ {self:p}")).finish()
    }
}

#[repr(C)]
pub struct GstFractionRange {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstFractionRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstFractionRange @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstGhostPad {
    pub pad: GstProxyPad,
    pub priv_: *mut GstGhostPadPrivate,
}

impl ::std::fmt::Debug for GstGhostPad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstGhostPad @ {self:p}"))
            .field("pad", &self.pad)
            .finish()
    }
}

#[repr(C)]
pub struct GstInt64Range {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstInt64Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstInt64Range @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct GstIntRange {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstIntRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstIntRange @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstObject {
    pub object: gobject::GInitiallyUnowned,
    pub lock: glib::GMutex,
    pub name: *mut c_char,
    pub parent: *mut GstObject,
    pub flags: u32,
    pub control_bindings: *mut glib::GList,
    pub control_rate: u64,
    pub last_sync: u64,
    pub _gst_reserved: gpointer,
}

impl ::std::fmt::Debug for GstObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstObject @ {self:p}"))
            .field("object", &self.object)
            .field("lock", &self.lock)
            .field("name", &self.name)
            .field("parent", &self.parent)
            .field("flags", &self.flags)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPad {
    pub object: GstObject,
    pub element_private: gpointer,
    pub padtemplate: *mut GstPadTemplate,
    pub direction: GstPadDirection,
    pub stream_rec_lock: glib::GRecMutex,
    pub task: *mut GstTask,
    pub block_cond: glib::GCond,
    pub probes: glib::GHookList,
    pub mode: GstPadMode,
    pub activatefunc: GstPadActivateFunction,
    pub activatedata: gpointer,
    pub activatenotify: glib::GDestroyNotify,
    pub activatemodefunc: GstPadActivateModeFunction,
    pub activatemodedata: gpointer,
    pub activatemodenotify: glib::GDestroyNotify,
    pub peer: *mut GstPad,
    pub linkfunc: GstPadLinkFunction,
    pub linkdata: gpointer,
    pub linknotify: glib::GDestroyNotify,
    pub unlinkfunc: GstPadUnlinkFunction,
    pub unlinkdata: gpointer,
    pub unlinknotify: glib::GDestroyNotify,
    pub chainfunc: GstPadChainFunction,
    pub chaindata: gpointer,
    pub chainnotify: glib::GDestroyNotify,
    pub chainlistfunc: GstPadChainListFunction,
    pub chainlistdata: gpointer,
    pub chainlistnotify: glib::GDestroyNotify,
    pub getrangefunc: GstPadGetRangeFunction,
    pub getrangedata: gpointer,
    pub getrangenotify: glib::GDestroyNotify,
    pub eventfunc: GstPadEventFunction,
    pub eventdata: gpointer,
    pub eventnotify: glib::GDestroyNotify,
    pub offset: i64,
    pub queryfunc: GstPadQueryFunction,
    pub querydata: gpointer,
    pub querynotify: glib::GDestroyNotify,
    pub iterintlinkfunc: GstPadIterIntLinkFunction,
    pub iterintlinkdata: gpointer,
    pub iterintlinknotify: glib::GDestroyNotify,
    pub num_probes: c_int,
    pub num_blocked: c_int,
    pub priv_: *mut GstPadPrivate,
    pub ABI: GstPad_ABI,
}

impl ::std::fmt::Debug for GstPad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPad @ {self:p}"))
            .field("object", &self.object)
            .field("element_private", &self.element_private)
            .field("padtemplate", &self.padtemplate)
            .field("direction", &self.direction)
            .field("ABI", &self.ABI)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPadTemplate {
    pub object: GstObject,
    pub name_template: *mut c_char,
    pub direction: GstPadDirection,
    pub presence: GstPadPresence,
    pub caps: *mut GstCaps,
    pub ABI: GstPadTemplate_ABI,
}

impl ::std::fmt::Debug for GstPadTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadTemplate @ {self:p}"))
            .field("object", &self.object)
            .field("name_template", &self.name_template)
            .field("direction", &self.direction)
            .field("presence", &self.presence)
            .field("caps", &self.caps)
            .field("ABI", &self.ABI)
            .finish()
    }
}

#[repr(C)]
pub struct GstParamArray {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstParamArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParamArray @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct GstParamFraction {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstParamFraction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParamFraction @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstPipeline {
    pub bin: GstBin,
    pub fixed_clock: *mut GstClock,
    pub stream_time: GstClockTime,
    pub delay: GstClockTime,
    pub priv_: *mut GstPipelinePrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPipeline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPipeline @ {self:p}"))
            .field("bin", &self.bin)
            .field("fixed_clock", &self.fixed_clock)
            .field("stream_time", &self.stream_time)
            .field("delay", &self.delay)
            .finish()
    }
}

#[repr(C)]
pub struct GstPlugin {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstPlugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPlugin @ {self:p}")).finish()
    }
}

#[repr(C)]
pub struct GstPluginFeature {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstPluginFeature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPluginFeature @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstProxyPad {
    pub pad: GstPad,
    pub priv_: *mut GstProxyPadPrivate,
}

impl ::std::fmt::Debug for GstProxyPad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstProxyPad @ {self:p}"))
            .field("pad", &self.pad)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstRegistry {
    pub object: GstObject,
    pub priv_: *mut GstRegistryPrivate,
}

impl ::std::fmt::Debug for GstRegistry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstRegistry @ {self:p}"))
            .field("object", &self.object)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstSharedTaskPool {
    pub parent: GstTaskPool,
    pub priv_: *mut GstSharedTaskPoolPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstSharedTaskPool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstSharedTaskPool @ {self:p}"))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstStream {
    pub object: GstObject,
    pub stream_id: *const c_char,
    pub priv_: *mut GstStreamPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStream @ {self:p}"))
            .field("stream_id", &self.stream_id)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstStreamCollection {
    pub object: GstObject,
    pub upstream_id: *mut c_char,
    pub priv_: *mut GstStreamCollectionPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstStreamCollection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStreamCollection @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstSystemClock {
    pub clock: GstClock,
    pub priv_: *mut GstSystemClockPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstSystemClock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstSystemClock @ {self:p}"))
            .field("clock", &self.clock)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstTask {
    pub object: GstObject,
    pub state: GstTaskState,
    pub cond: glib::GCond,
    pub lock: *mut glib::GRecMutex,
    pub func: GstTaskFunction,
    pub user_data: gpointer,
    pub notify: glib::GDestroyNotify,
    pub running: gboolean,
    pub thread: *mut glib::GThread,
    pub priv_: *mut GstTaskPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTask @ {self:p}"))
            .field("object", &self.object)
            .field("state", &self.state)
            .field("cond", &self.cond)
            .field("lock", &self.lock)
            .field("func", &self.func)
            .field("user_data", &self.user_data)
            .field("notify", &self.notify)
            .field("running", &self.running)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstTaskPool {
    pub object: GstObject,
    pub pool: *mut glib::GThreadPool,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTaskPool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTaskPool @ {self:p}"))
            .field("object", &self.object)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstTracer {
    pub parent: GstObject,
    pub priv_: *mut GstTracerPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTracer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTracer @ {self:p}"))
            .field("parent", &self.parent)
            .finish()
    }
}

#[repr(C)]
pub struct GstTracerFactory {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstTracerFactory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTracerFactory @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct GstTracerRecord {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstTracerRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTracerRecord @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct GstTypeFindFactory {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstTypeFindFactory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTypeFindFactory @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct GstValueArray {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstValueArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstValueArray @ {self:p}"))
            .finish()
    }
}

#[repr(C)]
pub struct GstValueList {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstValueList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstValueList @ {self:p}")).finish()
    }
}

// Interfaces
#[repr(C)]
pub struct GstChildProxy {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstChildProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstChildProxy @ {self:p}")
    }
}

#[repr(C)]
pub struct GstPreset {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstPreset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstPreset @ {self:p}")
    }
}

#[repr(C)]
pub struct GstTagSetter {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstTagSetter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstTagSetter @ {self:p}")
    }
}

#[repr(C)]
pub struct GstTocSetter {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstTocSetter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstTocSetter @ {self:p}")
    }
}

#[repr(C)]
pub struct GstURIHandler {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstURIHandler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstURIHandler @ {self:p}")
    }
}

#[link(name = "gstreamer-1.0")]
extern "C" {

    //=========================================================================
    // GstBufferingMode
    //=========================================================================
    pub fn gst_buffering_mode_get_type() -> GType;

    //=========================================================================
    // GstBusSyncReply
    //=========================================================================
    pub fn gst_bus_sync_reply_get_type() -> GType;

    //=========================================================================
    // GstCapsIntersectMode
    //=========================================================================
    pub fn gst_caps_intersect_mode_get_type() -> GType;

    //=========================================================================
    // GstClockEntryType
    //=========================================================================
    pub fn gst_clock_entry_type_get_type() -> GType;

    //=========================================================================
    // GstClockReturn
    //=========================================================================
    pub fn gst_clock_return_get_type() -> GType;

    //=========================================================================
    // GstClockType
    //=========================================================================
    pub fn gst_clock_type_get_type() -> GType;

    //=========================================================================
    // GstCoreError
    //=========================================================================
    pub fn gst_core_error_get_type() -> GType;
    pub fn gst_core_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstDebugColorMode
    //=========================================================================
    pub fn gst_debug_color_mode_get_type() -> GType;

    //=========================================================================
    // GstDebugLevel
    //=========================================================================
    pub fn gst_debug_level_get_type() -> GType;
    pub fn gst_debug_level_get_name(level: GstDebugLevel) -> *const c_char;

    //=========================================================================
    // GstEventType
    //=========================================================================
    pub fn gst_event_type_get_type() -> GType;
    pub fn gst_event_type_get_flags(type_: GstEventType) -> GstEventTypeFlags;
    pub fn gst_event_type_get_name(type_: GstEventType) -> *const c_char;
    pub fn gst_event_type_to_quark(type_: GstEventType) -> glib::GQuark;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    pub fn gst_event_type_to_sticky_ordering(type_: GstEventType) -> c_uint;

    //=========================================================================
    // GstFlowReturn
    //=========================================================================
    pub fn gst_flow_return_get_type() -> GType;

    //=========================================================================
    // GstFormat
    //=========================================================================
    pub fn gst_format_get_type() -> GType;
    pub fn gst_format_get_by_nick(nick: *const c_char) -> GstFormat;
    pub fn gst_format_get_details(format: GstFormat) -> *const GstFormatDefinition;
    pub fn gst_format_get_name(format: GstFormat) -> *const c_char;
    pub fn gst_format_iterate_definitions() -> *mut GstIterator;
    pub fn gst_format_register(nick: *const c_char, description: *const c_char) -> GstFormat;
    pub fn gst_format_to_quark(format: GstFormat) -> glib::GQuark;

    //=========================================================================
    // GstIteratorItem
    //=========================================================================
    pub fn gst_iterator_item_get_type() -> GType;

    //=========================================================================
    // GstIteratorResult
    //=========================================================================
    pub fn gst_iterator_result_get_type() -> GType;

    //=========================================================================
    // GstLibraryError
    //=========================================================================
    pub fn gst_library_error_get_type() -> GType;
    pub fn gst_library_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstPadDirection
    //=========================================================================
    pub fn gst_pad_direction_get_type() -> GType;

    //=========================================================================
    // GstPadLinkReturn
    //=========================================================================
    pub fn gst_pad_link_return_get_type() -> GType;

    //=========================================================================
    // GstPadMode
    //=========================================================================
    pub fn gst_pad_mode_get_type() -> GType;
    pub fn gst_pad_mode_get_name(mode: GstPadMode) -> *const c_char;

    //=========================================================================
    // GstPadPresence
    //=========================================================================
    pub fn gst_pad_presence_get_type() -> GType;

    //=========================================================================
    // GstPadProbeReturn
    //=========================================================================
    pub fn gst_pad_probe_return_get_type() -> GType;

    //=========================================================================
    // GstParseError
    //=========================================================================
    pub fn gst_parse_error_get_type() -> GType;
    pub fn gst_parse_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstPluginError
    //=========================================================================
    pub fn gst_plugin_error_get_type() -> GType;
    pub fn gst_plugin_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstProgressType
    //=========================================================================
    pub fn gst_progress_type_get_type() -> GType;

    //=========================================================================
    // GstPromiseResult
    //=========================================================================
    pub fn gst_promise_result_get_type() -> GType;

    //=========================================================================
    // GstQOSType
    //=========================================================================
    pub fn gst_qos_type_get_type() -> GType;

    //=========================================================================
    // GstQueryType
    //=========================================================================
    pub fn gst_query_type_get_type() -> GType;
    pub fn gst_query_type_get_flags(type_: GstQueryType) -> GstQueryTypeFlags;
    pub fn gst_query_type_get_name(type_: GstQueryType) -> *const c_char;
    pub fn gst_query_type_to_quark(type_: GstQueryType) -> glib::GQuark;

    //=========================================================================
    // GstRank
    //=========================================================================
    pub fn gst_rank_get_type() -> GType;

    //=========================================================================
    // GstResourceError
    //=========================================================================
    pub fn gst_resource_error_get_type() -> GType;
    pub fn gst_resource_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstSearchMode
    //=========================================================================
    pub fn gst_search_mode_get_type() -> GType;

    //=========================================================================
    // GstSeekType
    //=========================================================================
    pub fn gst_seek_type_get_type() -> GType;

    //=========================================================================
    // GstState
    //=========================================================================
    pub fn gst_state_get_type() -> GType;

    //=========================================================================
    // GstStateChange
    //=========================================================================
    pub fn gst_state_change_get_type() -> GType;
    pub fn gst_state_change_get_name(transition: GstStateChange) -> *const c_char;

    //=========================================================================
    // GstStateChangeReturn
    //=========================================================================
    pub fn gst_state_change_return_get_type() -> GType;

    //=========================================================================
    // GstStreamError
    //=========================================================================
    pub fn gst_stream_error_get_type() -> GType;
    pub fn gst_stream_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstStreamStatusType
    //=========================================================================
    pub fn gst_stream_status_type_get_type() -> GType;

    //=========================================================================
    // GstStructureChangeType
    //=========================================================================
    pub fn gst_structure_change_type_get_type() -> GType;

    //=========================================================================
    // GstTagFlag
    //=========================================================================
    pub fn gst_tag_flag_get_type() -> GType;

    //=========================================================================
    // GstTagMergeMode
    //=========================================================================
    pub fn gst_tag_merge_mode_get_type() -> GType;

    //=========================================================================
    // GstTagScope
    //=========================================================================
    pub fn gst_tag_scope_get_type() -> GType;

    //=========================================================================
    // GstTaskState
    //=========================================================================
    pub fn gst_task_state_get_type() -> GType;

    //=========================================================================
    // GstTocEntryType
    //=========================================================================
    pub fn gst_toc_entry_type_get_type() -> GType;
    pub fn gst_toc_entry_type_get_nick(type_: GstTocEntryType) -> *const c_char;

    //=========================================================================
    // GstTocLoopType
    //=========================================================================
    pub fn gst_toc_loop_type_get_type() -> GType;

    //=========================================================================
    // GstTocScope
    //=========================================================================
    pub fn gst_toc_scope_get_type() -> GType;

    //=========================================================================
    // GstTracerValueScope
    //=========================================================================
    pub fn gst_tracer_value_scope_get_type() -> GType;

    //=========================================================================
    // GstTypeFindProbability
    //=========================================================================
    pub fn gst_type_find_probability_get_type() -> GType;

    //=========================================================================
    // GstURIError
    //=========================================================================
    pub fn gst_uri_error_get_type() -> GType;
    pub fn gst_uri_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstURIType
    //=========================================================================
    pub fn gst_uri_type_get_type() -> GType;

    //=========================================================================
    // GstAllocatorFlags
    //=========================================================================
    pub fn gst_allocator_flags_get_type() -> GType;

    //=========================================================================
    // GstBinFlags
    //=========================================================================
    pub fn gst_bin_flags_get_type() -> GType;

    //=========================================================================
    // GstBufferCopyFlags
    //=========================================================================
    pub fn gst_buffer_copy_flags_get_type() -> GType;

    //=========================================================================
    // GstBufferFlags
    //=========================================================================
    pub fn gst_buffer_flags_get_type() -> GType;

    //=========================================================================
    // GstBufferPoolAcquireFlags
    //=========================================================================
    pub fn gst_buffer_pool_acquire_flags_get_type() -> GType;

    //=========================================================================
    // GstBusFlags
    //=========================================================================
    pub fn gst_bus_flags_get_type() -> GType;

    //=========================================================================
    // GstCapsFlags
    //=========================================================================
    pub fn gst_caps_flags_get_type() -> GType;

    //=========================================================================
    // GstClockFlags
    //=========================================================================
    pub fn gst_clock_flags_get_type() -> GType;

    //=========================================================================
    // GstDebugColorFlags
    //=========================================================================
    pub fn gst_debug_color_flags_get_type() -> GType;

    //=========================================================================
    // GstDebugGraphDetails
    //=========================================================================
    pub fn gst_debug_graph_details_get_type() -> GType;

    //=========================================================================
    // GstElementFlags
    //=========================================================================
    pub fn gst_element_flags_get_type() -> GType;

    //=========================================================================
    // GstEventTypeFlags
    //=========================================================================
    pub fn gst_event_type_flags_get_type() -> GType;

    //=========================================================================
    // GstGapFlags
    //=========================================================================
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_gap_flags_get_type() -> GType;

    //=========================================================================
    // GstLockFlags
    //=========================================================================
    pub fn gst_lock_flags_get_type() -> GType;

    //=========================================================================
    // GstMapFlags
    //=========================================================================
    pub fn gst_map_flags_get_type() -> GType;

    //=========================================================================
    // GstMemoryFlags
    //=========================================================================
    pub fn gst_memory_flags_get_type() -> GType;

    //=========================================================================
    // GstMessageType
    //=========================================================================
    pub fn gst_message_type_get_type() -> GType;
    pub fn gst_message_type_get_name(type_: GstMessageType) -> *const c_char;
    pub fn gst_message_type_to_quark(type_: GstMessageType) -> glib::GQuark;

    //=========================================================================
    // GstMetaFlags
    //=========================================================================
    pub fn gst_meta_flags_get_type() -> GType;

    //=========================================================================
    // GstMiniObjectFlags
    //=========================================================================
    pub fn gst_mini_object_flags_get_type() -> GType;

    //=========================================================================
    // GstObjectFlags
    //=========================================================================
    pub fn gst_object_flags_get_type() -> GType;

    //=========================================================================
    // GstPadFlags
    //=========================================================================
    pub fn gst_pad_flags_get_type() -> GType;

    //=========================================================================
    // GstPadLinkCheck
    //=========================================================================
    pub fn gst_pad_link_check_get_type() -> GType;

    //=========================================================================
    // GstPadProbeType
    //=========================================================================
    pub fn gst_pad_probe_type_get_type() -> GType;

    //=========================================================================
    // GstPadTemplateFlags
    //=========================================================================
    pub fn gst_pad_template_flags_get_type() -> GType;

    //=========================================================================
    // GstParseFlags
    //=========================================================================
    pub fn gst_parse_flags_get_type() -> GType;

    //=========================================================================
    // GstPipelineFlags
    //=========================================================================
    pub fn gst_pipeline_flags_get_type() -> GType;

    //=========================================================================
    // GstPluginAPIFlags
    //=========================================================================
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_plugin_api_flags_get_type() -> GType;

    //=========================================================================
    // GstPluginDependencyFlags
    //=========================================================================
    pub fn gst_plugin_dependency_flags_get_type() -> GType;

    //=========================================================================
    // GstPluginFlags
    //=========================================================================
    pub fn gst_plugin_flags_get_type() -> GType;

    //=========================================================================
    // GstQueryTypeFlags
    //=========================================================================
    pub fn gst_query_type_flags_get_type() -> GType;

    //=========================================================================
    // GstSchedulingFlags
    //=========================================================================
    pub fn gst_scheduling_flags_get_type() -> GType;

    //=========================================================================
    // GstSeekFlags
    //=========================================================================
    pub fn gst_seek_flags_get_type() -> GType;

    //=========================================================================
    // GstSegmentFlags
    //=========================================================================
    pub fn gst_segment_flags_get_type() -> GType;

    //=========================================================================
    // GstSerializeFlags
    //=========================================================================
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_serialize_flags_get_type() -> GType;

    //=========================================================================
    // GstStackTraceFlags
    //=========================================================================
    pub fn gst_stack_trace_flags_get_type() -> GType;

    //=========================================================================
    // GstStreamFlags
    //=========================================================================
    pub fn gst_stream_flags_get_type() -> GType;

    //=========================================================================
    // GstStreamType
    //=========================================================================
    pub fn gst_stream_type_get_type() -> GType;
    pub fn gst_stream_type_get_name(stype: GstStreamType) -> *const c_char;

    //=========================================================================
    // GstTracerValueFlags
    //=========================================================================
    pub fn gst_tracer_value_flags_get_type() -> GType;

    //=========================================================================
    // GstAllocationParams
    //=========================================================================
    pub fn gst_allocation_params_get_type() -> GType;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_allocation_params_new() -> *mut GstAllocationParams;
    pub fn gst_allocation_params_copy(
        params: *const GstAllocationParams,
    ) -> *mut GstAllocationParams;
    pub fn gst_allocation_params_free(params: *mut GstAllocationParams);
    pub fn gst_allocation_params_init(params: *mut GstAllocationParams);

    //=========================================================================
    // GstAtomicQueue
    //=========================================================================
    pub fn gst_atomic_queue_get_type() -> GType;
    pub fn gst_atomic_queue_new(initial_size: c_uint) -> *mut GstAtomicQueue;
    pub fn gst_atomic_queue_length(queue: *mut GstAtomicQueue) -> c_uint;
    pub fn gst_atomic_queue_peek(queue: *mut GstAtomicQueue) -> gpointer;
    pub fn gst_atomic_queue_pop(queue: *mut GstAtomicQueue) -> gpointer;
    pub fn gst_atomic_queue_push(queue: *mut GstAtomicQueue, data: gpointer);
    pub fn gst_atomic_queue_ref(queue: *mut GstAtomicQueue);
    pub fn gst_atomic_queue_unref(queue: *mut GstAtomicQueue);

    //=========================================================================
    // GstBuffer
    //=========================================================================
    pub fn gst_buffer_get_type() -> GType;
    pub fn gst_buffer_new() -> *mut GstBuffer;
    pub fn gst_buffer_new_allocate(
        allocator: *mut GstAllocator,
        size: size_t,
        params: *mut GstAllocationParams,
    ) -> *mut GstBuffer;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_buffer_new_memdup(data: gconstpointer, size: size_t) -> *mut GstBuffer;
    pub fn gst_buffer_new_wrapped(data: gpointer, size: size_t) -> *mut GstBuffer;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_buffer_new_wrapped_bytes(bytes: *mut glib::GBytes) -> *mut GstBuffer;
    pub fn gst_buffer_new_wrapped_full(
        flags: GstMemoryFlags,
        data: gpointer,
        maxsize: size_t,
        offset: size_t,
        size: size_t,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    ) -> *mut GstBuffer;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_buffer_add_custom_meta(
        buffer: *mut GstBuffer,
        name: *const c_char,
    ) -> *mut GstCustomMeta;
    pub fn gst_buffer_add_meta(
        buffer: *mut GstBuffer,
        info: *const GstMetaInfo,
        params: gpointer,
    ) -> *mut GstMeta;
    pub fn gst_buffer_add_parent_buffer_meta(
        buffer: *mut GstBuffer,
        ref_: *mut GstBuffer,
    ) -> *mut GstParentBufferMeta;
    pub fn gst_buffer_add_protection_meta(
        buffer: *mut GstBuffer,
        info: *mut GstStructure,
    ) -> *mut GstProtectionMeta;
    pub fn gst_buffer_add_reference_timestamp_meta(
        buffer: *mut GstBuffer,
        reference: *mut GstCaps,
        timestamp: GstClockTime,
        duration: GstClockTime,
    ) -> *mut GstReferenceTimestampMeta;
    pub fn gst_buffer_append(buf1: *mut GstBuffer, buf2: *mut GstBuffer) -> *mut GstBuffer;
    pub fn gst_buffer_append_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
    pub fn gst_buffer_append_region(
        buf1: *mut GstBuffer,
        buf2: *mut GstBuffer,
        offset: ssize_t,
        size: ssize_t,
    ) -> *mut GstBuffer;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_buffer_copy(buf: *const GstBuffer) -> *mut GstBuffer;
    pub fn gst_buffer_copy_deep(buf: *const GstBuffer) -> *mut GstBuffer;
    pub fn gst_buffer_copy_into(
        dest: *mut GstBuffer,
        src: *mut GstBuffer,
        flags: GstBufferCopyFlags,
        offset: size_t,
        size: size_t,
    ) -> gboolean;
    pub fn gst_buffer_copy_region(
        parent: *mut GstBuffer,
        flags: GstBufferCopyFlags,
        offset: size_t,
        size: size_t,
    ) -> *mut GstBuffer;
    pub fn gst_buffer_extract(
        buffer: *mut GstBuffer,
        offset: size_t,
        dest: gpointer,
        size: size_t,
    ) -> size_t;
    pub fn gst_buffer_extract_dup(
        buffer: *mut GstBuffer,
        offset: size_t,
        size: size_t,
        dest: *mut u8,
        dest_size: *mut size_t,
    );
    pub fn gst_buffer_fill(
        buffer: *mut GstBuffer,
        offset: size_t,
        src: gconstpointer,
        size: size_t,
    ) -> size_t;
    pub fn gst_buffer_find_memory(
        buffer: *mut GstBuffer,
        offset: size_t,
        size: size_t,
        idx: *mut c_uint,
        length: *mut c_uint,
        skip: *mut size_t,
    ) -> gboolean;
    pub fn gst_buffer_foreach_meta(
        buffer: *mut GstBuffer,
        func: GstBufferForeachMetaFunc,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_buffer_get_all_memory(buffer: *mut GstBuffer) -> *mut GstMemory;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_buffer_get_custom_meta(
        buffer: *mut GstBuffer,
        name: *const c_char,
    ) -> *mut GstCustomMeta;
    pub fn gst_buffer_get_flags(buffer: *mut GstBuffer) -> GstBufferFlags;
    pub fn gst_buffer_get_memory(buffer: *mut GstBuffer, idx: c_uint) -> *mut GstMemory;
    pub fn gst_buffer_get_memory_range(
        buffer: *mut GstBuffer,
        idx: c_uint,
        length: c_int,
    ) -> *mut GstMemory;
    pub fn gst_buffer_get_meta(buffer: *mut GstBuffer, api: GType) -> *mut GstMeta;
    pub fn gst_buffer_get_n_meta(buffer: *mut GstBuffer, api_type: GType) -> c_uint;
    pub fn gst_buffer_get_reference_timestamp_meta(
        buffer: *mut GstBuffer,
        reference: *mut GstCaps,
    ) -> *mut GstReferenceTimestampMeta;
    pub fn gst_buffer_get_size(buffer: *mut GstBuffer) -> size_t;
    pub fn gst_buffer_get_sizes(
        buffer: *mut GstBuffer,
        offset: *mut size_t,
        maxsize: *mut size_t,
    ) -> size_t;
    pub fn gst_buffer_get_sizes_range(
        buffer: *mut GstBuffer,
        idx: c_uint,
        length: c_int,
        offset: *mut size_t,
        maxsize: *mut size_t,
    ) -> size_t;
    pub fn gst_buffer_has_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
    pub fn gst_buffer_insert_memory(buffer: *mut GstBuffer, idx: c_int, mem: *mut GstMemory);
    pub fn gst_buffer_is_all_memory_writable(buffer: *mut GstBuffer) -> gboolean;
    pub fn gst_buffer_is_memory_range_writable(
        buffer: *mut GstBuffer,
        idx: c_uint,
        length: c_int,
    ) -> gboolean;
    pub fn gst_buffer_iterate_meta(buffer: *mut GstBuffer, state: *mut gpointer) -> *mut GstMeta;
    pub fn gst_buffer_iterate_meta_filtered(
        buffer: *mut GstBuffer,
        state: *mut gpointer,
        meta_api_type: GType,
    ) -> *mut GstMeta;
    pub fn gst_buffer_map(
        buffer: *mut GstBuffer,
        info: *mut GstMapInfo,
        flags: GstMapFlags,
    ) -> gboolean;
    pub fn gst_buffer_map_range(
        buffer: *mut GstBuffer,
        idx: c_uint,
        length: c_int,
        info: *mut GstMapInfo,
        flags: GstMapFlags,
    ) -> gboolean;
    pub fn gst_buffer_memcmp(
        buffer: *mut GstBuffer,
        offset: size_t,
        mem: gconstpointer,
        size: size_t,
    ) -> c_int;
    pub fn gst_buffer_memset(
        buffer: *mut GstBuffer,
        offset: size_t,
        val: u8,
        size: size_t,
    ) -> size_t;
    pub fn gst_buffer_n_memory(buffer: *mut GstBuffer) -> c_uint;
    pub fn gst_buffer_peek_memory(buffer: *mut GstBuffer, idx: c_uint) -> *mut GstMemory;
    pub fn gst_buffer_prepend_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_buffer_ref(buf: *mut GstBuffer) -> *mut GstBuffer;
    pub fn gst_buffer_remove_all_memory(buffer: *mut GstBuffer);
    pub fn gst_buffer_remove_memory(buffer: *mut GstBuffer, idx: c_uint);
    pub fn gst_buffer_remove_memory_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int);
    pub fn gst_buffer_remove_meta(buffer: *mut GstBuffer, meta: *mut GstMeta) -> gboolean;
    pub fn gst_buffer_replace_all_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
    pub fn gst_buffer_replace_memory(buffer: *mut GstBuffer, idx: c_uint, mem: *mut GstMemory);
    pub fn gst_buffer_replace_memory_range(
        buffer: *mut GstBuffer,
        idx: c_uint,
        length: c_int,
        mem: *mut GstMemory,
    );
    pub fn gst_buffer_resize(buffer: *mut GstBuffer, offset: ssize_t, size: ssize_t);
    pub fn gst_buffer_resize_range(
        buffer: *mut GstBuffer,
        idx: c_uint,
        length: c_int,
        offset: ssize_t,
        size: ssize_t,
    ) -> gboolean;
    pub fn gst_buffer_set_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
    pub fn gst_buffer_set_size(buffer: *mut GstBuffer, size: ssize_t);
    pub fn gst_buffer_unmap(buffer: *mut GstBuffer, info: *mut GstMapInfo);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_buffer_unref(buf: *mut GstBuffer);
    pub fn gst_buffer_unset_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
    pub fn gst_buffer_get_max_memory() -> c_uint;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_buffer_replace(obuf: *mut *mut GstBuffer, nbuf: *mut GstBuffer) -> gboolean;

    //=========================================================================
    // GstBufferList
    //=========================================================================
    pub fn gst_buffer_list_get_type() -> GType;
    pub fn gst_buffer_list_new() -> *mut GstBufferList;
    pub fn gst_buffer_list_new_sized(size: c_uint) -> *mut GstBufferList;
    pub fn gst_buffer_list_calculate_size(list: *mut GstBufferList) -> size_t;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_buffer_list_copy(list: *const GstBufferList) -> *mut GstBufferList;
    pub fn gst_buffer_list_copy_deep(list: *const GstBufferList) -> *mut GstBufferList;
    pub fn gst_buffer_list_foreach(
        list: *mut GstBufferList,
        func: GstBufferListFunc,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_buffer_list_get(list: *mut GstBufferList, idx: c_uint) -> *mut GstBuffer;
    pub fn gst_buffer_list_get_writable(list: *mut GstBufferList, idx: c_uint) -> *mut GstBuffer;
    pub fn gst_buffer_list_insert(list: *mut GstBufferList, idx: c_int, buffer: *mut GstBuffer);
    pub fn gst_buffer_list_length(list: *mut GstBufferList) -> c_uint;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_buffer_list_ref(list: *mut GstBufferList) -> *mut GstBufferList;
    pub fn gst_buffer_list_remove(list: *mut GstBufferList, idx: c_uint, length: c_uint);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_buffer_list_unref(list: *mut GstBufferList);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_buffer_list_replace(
        old_list: *mut *mut GstBufferList,
        new_list: *mut GstBufferList,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_buffer_list_take(
        old_list: *mut *mut GstBufferList,
        new_list: *mut GstBufferList,
    ) -> gboolean;

    //=========================================================================
    // GstCaps
    //=========================================================================
    pub fn gst_caps_get_type() -> GType;
    pub fn gst_caps_new_any() -> *mut GstCaps;
    pub fn gst_caps_new_empty() -> *mut GstCaps;
    pub fn gst_caps_new_empty_simple(media_type: *const c_char) -> *mut GstCaps;
    pub fn gst_caps_new_full(struct1: *mut GstStructure, ...) -> *mut GstCaps;
    //pub fn gst_caps_new_full_valist(structure: *mut GstStructure, var_args: /*Unimplemented*/va_list) -> *mut GstCaps;
    pub fn gst_caps_new_simple(
        media_type: *const c_char,
        fieldname: *const c_char,
        ...
    ) -> *mut GstCaps;
    pub fn gst_caps_append(caps1: *mut GstCaps, caps2: *mut GstCaps);
    pub fn gst_caps_append_structure(caps: *mut GstCaps, structure: *mut GstStructure);
    pub fn gst_caps_append_structure_full(
        caps: *mut GstCaps,
        structure: *mut GstStructure,
        features: *mut GstCapsFeatures,
    );
    pub fn gst_caps_can_intersect(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_caps_copy(caps: *const GstCaps) -> *mut GstCaps;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_caps_copy_nth(caps: *const GstCaps, nth: c_uint) -> *mut GstCaps;
    pub fn gst_caps_filter_and_map_in_place(
        caps: *mut GstCaps,
        func: GstCapsFilterMapFunc,
        user_data: gpointer,
    );
    pub fn gst_caps_fixate(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_foreach(
        caps: *const GstCaps,
        func: GstCapsForeachFunc,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_caps_get_features(caps: *const GstCaps, index: c_uint) -> *mut GstCapsFeatures;
    pub fn gst_caps_get_size(caps: *const GstCaps) -> c_uint;
    pub fn gst_caps_get_structure(caps: *const GstCaps, index: c_uint) -> *mut GstStructure;
    pub fn gst_caps_intersect(caps1: *mut GstCaps, caps2: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_intersect_full(
        caps1: *mut GstCaps,
        caps2: *mut GstCaps,
        mode: GstCapsIntersectMode,
    ) -> *mut GstCaps;
    pub fn gst_caps_is_always_compatible(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_any(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_empty(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_equal(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_equal_fixed(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_fixed(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_strictly_equal(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_subset(subset: *const GstCaps, superset: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_subset_structure(
        caps: *const GstCaps,
        structure: *const GstStructure,
    ) -> gboolean;
    pub fn gst_caps_is_subset_structure_full(
        caps: *const GstCaps,
        structure: *const GstStructure,
        features: *const GstCapsFeatures,
    ) -> gboolean;
    pub fn gst_caps_map_in_place(
        caps: *mut GstCaps,
        func: GstCapsMapFunc,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_caps_merge(caps1: *mut GstCaps, caps2: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_merge_structure(
        caps: *mut GstCaps,
        structure: *mut GstStructure,
    ) -> *mut GstCaps;
    pub fn gst_caps_merge_structure_full(
        caps: *mut GstCaps,
        structure: *mut GstStructure,
        features: *mut GstCapsFeatures,
    ) -> *mut GstCaps;
    pub fn gst_caps_normalize(caps: *mut GstCaps) -> *mut GstCaps;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_caps_ref(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_remove_structure(caps: *mut GstCaps, idx: c_uint);
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_caps_serialize(caps: *const GstCaps, flags: GstSerializeFlags) -> *mut c_char;
    pub fn gst_caps_set_features(caps: *mut GstCaps, index: c_uint, features: *mut GstCapsFeatures);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_caps_set_features_simple(caps: *mut GstCaps, features: *mut GstCapsFeatures);
    pub fn gst_caps_set_simple(caps: *mut GstCaps, field: *const c_char, ...);
    //pub fn gst_caps_set_simple_valist(caps: *mut GstCaps, field: *const c_char, varargs: /*Unimplemented*/va_list);
    pub fn gst_caps_set_value(
        caps: *mut GstCaps,
        field: *const c_char,
        value: *const gobject::GValue,
    );
    pub fn gst_caps_simplify(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_steal_structure(caps: *mut GstCaps, index: c_uint) -> *mut GstStructure;
    pub fn gst_caps_subtract(minuend: *mut GstCaps, subtrahend: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_to_string(caps: *const GstCaps) -> *mut c_char;
    pub fn gst_caps_truncate(caps: *mut GstCaps) -> *mut GstCaps;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_caps_unref(caps: *mut GstCaps);
    pub fn gst_caps_from_string(string: *const c_char) -> *mut GstCaps;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_caps_replace(old_caps: *mut *mut GstCaps, new_caps: *mut GstCaps) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_caps_take(old_caps: *mut *mut GstCaps, new_caps: *mut GstCaps) -> gboolean;

    //=========================================================================
    // GstCapsFeatures
    //=========================================================================
    pub fn gst_caps_features_get_type() -> GType;
    pub fn gst_caps_features_new(feature1: *const c_char, ...) -> *mut GstCapsFeatures;
    pub fn gst_caps_features_new_any() -> *mut GstCapsFeatures;
    pub fn gst_caps_features_new_empty() -> *mut GstCapsFeatures;
    pub fn gst_caps_features_new_id(feature1: glib::GQuark, ...) -> *mut GstCapsFeatures;
    //pub fn gst_caps_features_new_id_valist(feature1: glib::GQuark, varargs: /*Unimplemented*/va_list) -> *mut GstCapsFeatures;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_caps_features_new_single(feature: *const c_char) -> *mut GstCapsFeatures;
    //pub fn gst_caps_features_new_valist(feature1: *const c_char, varargs: /*Unimplemented*/va_list) -> *mut GstCapsFeatures;
    pub fn gst_caps_features_add(features: *mut GstCapsFeatures, feature: *const c_char);
    pub fn gst_caps_features_add_id(features: *mut GstCapsFeatures, feature: glib::GQuark);
    pub fn gst_caps_features_contains(
        features: *const GstCapsFeatures,
        feature: *const c_char,
    ) -> gboolean;
    pub fn gst_caps_features_contains_id(
        features: *const GstCapsFeatures,
        feature: glib::GQuark,
    ) -> gboolean;
    pub fn gst_caps_features_copy(features: *const GstCapsFeatures) -> *mut GstCapsFeatures;
    pub fn gst_caps_features_free(features: *mut GstCapsFeatures);
    pub fn gst_caps_features_get_nth(features: *const GstCapsFeatures, i: c_uint) -> *const c_char;
    pub fn gst_caps_features_get_nth_id(
        features: *const GstCapsFeatures,
        i: c_uint,
    ) -> glib::GQuark;
    pub fn gst_caps_features_get_size(features: *const GstCapsFeatures) -> c_uint;
    pub fn gst_caps_features_is_any(features: *const GstCapsFeatures) -> gboolean;
    pub fn gst_caps_features_is_equal(
        features1: *const GstCapsFeatures,
        features2: *const GstCapsFeatures,
    ) -> gboolean;
    pub fn gst_caps_features_remove(features: *mut GstCapsFeatures, feature: *const c_char);
    pub fn gst_caps_features_remove_id(features: *mut GstCapsFeatures, feature: glib::GQuark);
    pub fn gst_caps_features_set_parent_refcount(
        features: *mut GstCapsFeatures,
        refcount: *mut c_int,
    ) -> gboolean;
    pub fn gst_caps_features_to_string(features: *const GstCapsFeatures) -> *mut c_char;
    pub fn gst_caps_features_from_string(features: *const c_char) -> *mut GstCapsFeatures;

    //=========================================================================
    // GstContext
    //=========================================================================
    pub fn gst_context_get_type() -> GType;
    pub fn gst_context_new(context_type: *const c_char, persistent: gboolean) -> *mut GstContext;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_context_copy(context: *const GstContext) -> *mut GstContext;
    pub fn gst_context_get_context_type(context: *const GstContext) -> *const c_char;
    pub fn gst_context_get_structure(context: *const GstContext) -> *const GstStructure;
    pub fn gst_context_has_context_type(
        context: *const GstContext,
        context_type: *const c_char,
    ) -> gboolean;
    pub fn gst_context_is_persistent(context: *const GstContext) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_context_ref(context: *mut GstContext) -> *mut GstContext;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_context_unref(context: *mut GstContext);
    pub fn gst_context_writable_structure(context: *mut GstContext) -> *mut GstStructure;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_context_replace(
        old_context: *mut *mut GstContext,
        new_context: *mut GstContext,
    ) -> gboolean;

    //=========================================================================
    // GstCustomMeta
    //=========================================================================
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_custom_meta_get_structure(meta: *mut GstCustomMeta) -> *mut GstStructure;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_custom_meta_has_name(meta: *mut GstCustomMeta, name: *const c_char) -> gboolean;

    //=========================================================================
    // GstDateTime
    //=========================================================================
    pub fn gst_date_time_get_type() -> GType;
    pub fn gst_date_time_new(
        tzoffset: c_float,
        year: c_int,
        month: c_int,
        day: c_int,
        hour: c_int,
        minute: c_int,
        seconds: c_double,
    ) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_g_date_time(dt: *mut glib::GDateTime) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_iso8601_string(string: *const c_char) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_unix_epoch_local_time(secs: i64) -> *mut GstDateTime;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_date_time_new_from_unix_epoch_local_time_usecs(usecs: i64) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_unix_epoch_utc(secs: i64) -> *mut GstDateTime;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_date_time_new_from_unix_epoch_utc_usecs(usecs: i64) -> *mut GstDateTime;
    pub fn gst_date_time_new_local_time(
        year: c_int,
        month: c_int,
        day: c_int,
        hour: c_int,
        minute: c_int,
        seconds: c_double,
    ) -> *mut GstDateTime;
    pub fn gst_date_time_new_now_local_time() -> *mut GstDateTime;
    pub fn gst_date_time_new_now_utc() -> *mut GstDateTime;
    pub fn gst_date_time_new_y(year: c_int) -> *mut GstDateTime;
    pub fn gst_date_time_new_ym(year: c_int, month: c_int) -> *mut GstDateTime;
    pub fn gst_date_time_new_ymd(year: c_int, month: c_int, day: c_int) -> *mut GstDateTime;
    pub fn gst_date_time_get_day(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_hour(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_microsecond(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_minute(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_month(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_second(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_time_zone_offset(datetime: *const GstDateTime) -> c_float;
    pub fn gst_date_time_get_year(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_has_day(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_month(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_second(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_time(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_year(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_ref(datetime: *mut GstDateTime) -> *mut GstDateTime;
    pub fn gst_date_time_to_g_date_time(datetime: *mut GstDateTime) -> *mut glib::GDateTime;
    pub fn gst_date_time_to_iso8601_string(datetime: *mut GstDateTime) -> *mut c_char;
    pub fn gst_date_time_unref(datetime: *mut GstDateTime);

    //=========================================================================
    // GstDebugCategory
    //=========================================================================
    pub fn gst_debug_category_free(category: *mut GstDebugCategory);
    pub fn gst_debug_category_get_color(category: *mut GstDebugCategory) -> c_uint;
    pub fn gst_debug_category_get_description(category: *mut GstDebugCategory) -> *const c_char;
    pub fn gst_debug_category_get_name(category: *mut GstDebugCategory) -> *const c_char;
    pub fn gst_debug_category_get_threshold(category: *mut GstDebugCategory) -> GstDebugLevel;
    pub fn gst_debug_category_reset_threshold(category: *mut GstDebugCategory);
    pub fn gst_debug_category_set_threshold(category: *mut GstDebugCategory, level: GstDebugLevel);

    //=========================================================================
    // GstDebugMessage
    //=========================================================================
    pub fn gst_debug_message_get(message: *mut GstDebugMessage) -> *const c_char;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    pub fn gst_debug_message_get_id(message: *mut GstDebugMessage) -> *const c_char;

    //=========================================================================
    // GstDeviceProviderClass
    //=========================================================================
    pub fn gst_device_provider_class_add_metadata(
        klass: *mut GstDeviceProviderClass,
        key: *const c_char,
        value: *const c_char,
    );
    pub fn gst_device_provider_class_add_static_metadata(
        klass: *mut GstDeviceProviderClass,
        key: *const c_char,
        value: *const c_char,
    );
    pub fn gst_device_provider_class_get_metadata(
        klass: *mut GstDeviceProviderClass,
        key: *const c_char,
    ) -> *const c_char;
    pub fn gst_device_provider_class_set_metadata(
        klass: *mut GstDeviceProviderClass,
        longname: *const c_char,
        classification: *const c_char,
        description: *const c_char,
        author: *const c_char,
    );
    pub fn gst_device_provider_class_set_static_metadata(
        klass: *mut GstDeviceProviderClass,
        longname: *const c_char,
        classification: *const c_char,
        description: *const c_char,
        author: *const c_char,
    );

    //=========================================================================
    // GstElementClass
    //=========================================================================
    pub fn gst_element_class_add_metadata(
        klass: *mut GstElementClass,
        key: *const c_char,
        value: *const c_char,
    );
    pub fn gst_element_class_add_pad_template(
        klass: *mut GstElementClass,
        templ: *mut GstPadTemplate,
    );
    pub fn gst_element_class_add_static_metadata(
        klass: *mut GstElementClass,
        key: *const c_char,
        value: *const c_char,
    );
    pub fn gst_element_class_add_static_pad_template(
        klass: *mut GstElementClass,
        static_templ: *mut GstStaticPadTemplate,
    );
    pub fn gst_element_class_add_static_pad_template_with_gtype(
        klass: *mut GstElementClass,
        static_templ: *mut GstStaticPadTemplate,
        pad_type: GType,
    );
    pub fn gst_element_class_get_metadata(
        klass: *mut GstElementClass,
        key: *const c_char,
    ) -> *const c_char;
    pub fn gst_element_class_get_pad_template(
        element_class: *mut GstElementClass,
        name: *const c_char,
    ) -> *mut GstPadTemplate;
    pub fn gst_element_class_get_pad_template_list(
        element_class: *mut GstElementClass,
    ) -> *mut glib::GList;
    pub fn gst_element_class_set_metadata(
        klass: *mut GstElementClass,
        longname: *const c_char,
        classification: *const c_char,
        description: *const c_char,
        author: *const c_char,
    );
    pub fn gst_element_class_set_static_metadata(
        klass: *mut GstElementClass,
        longname: *const c_char,
        classification: *const c_char,
        description: *const c_char,
        author: *const c_char,
    );

    //=========================================================================
    // GstEvent
    //=========================================================================
    pub fn gst_event_get_type() -> GType;
    pub fn gst_event_new_buffer_size(
        format: GstFormat,
        minsize: i64,
        maxsize: i64,
        async_: gboolean,
    ) -> *mut GstEvent;
    pub fn gst_event_new_caps(caps: *mut GstCaps) -> *mut GstEvent;
    pub fn gst_event_new_custom(type_: GstEventType, structure: *mut GstStructure)
        -> *mut GstEvent;
    pub fn gst_event_new_eos() -> *mut GstEvent;
    pub fn gst_event_new_flush_start() -> *mut GstEvent;
    pub fn gst_event_new_flush_stop(reset_time: gboolean) -> *mut GstEvent;
    pub fn gst_event_new_gap(timestamp: GstClockTime, duration: GstClockTime) -> *mut GstEvent;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_event_new_instant_rate_change(
        rate_multiplier: c_double,
        new_flags: GstSegmentFlags,
    ) -> *mut GstEvent;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_event_new_instant_rate_sync_time(
        rate_multiplier: c_double,
        running_time: GstClockTime,
        upstream_running_time: GstClockTime,
    ) -> *mut GstEvent;
    pub fn gst_event_new_latency(latency: GstClockTime) -> *mut GstEvent;
    pub fn gst_event_new_navigation(structure: *mut GstStructure) -> *mut GstEvent;
    pub fn gst_event_new_protection(
        system_id: *const c_char,
        data: *mut GstBuffer,
        origin: *const c_char,
    ) -> *mut GstEvent;
    pub fn gst_event_new_qos(
        type_: GstQOSType,
        proportion: c_double,
        diff: GstClockTimeDiff,
        timestamp: GstClockTime,
    ) -> *mut GstEvent;
    pub fn gst_event_new_reconfigure() -> *mut GstEvent;
    pub fn gst_event_new_seek(
        rate: c_double,
        format: GstFormat,
        flags: GstSeekFlags,
        start_type: GstSeekType,
        start: i64,
        stop_type: GstSeekType,
        stop: i64,
    ) -> *mut GstEvent;
    pub fn gst_event_new_segment(segment: *const GstSegment) -> *mut GstEvent;
    pub fn gst_event_new_segment_done(format: GstFormat, position: i64) -> *mut GstEvent;
    pub fn gst_event_new_select_streams(streams: *mut glib::GList) -> *mut GstEvent;
    pub fn gst_event_new_sink_message(name: *const c_char, msg: *mut GstMessage) -> *mut GstEvent;
    pub fn gst_event_new_step(
        format: GstFormat,
        amount: u64,
        rate: c_double,
        flush: gboolean,
        intermediate: gboolean,
    ) -> *mut GstEvent;
    pub fn gst_event_new_stream_collection(collection: *mut GstStreamCollection) -> *mut GstEvent;
    pub fn gst_event_new_stream_group_done(group_id: c_uint) -> *mut GstEvent;
    pub fn gst_event_new_stream_start(stream_id: *const c_char) -> *mut GstEvent;
    pub fn gst_event_new_tag(taglist: *mut GstTagList) -> *mut GstEvent;
    pub fn gst_event_new_toc(toc: *mut GstToc, updated: gboolean) -> *mut GstEvent;
    pub fn gst_event_new_toc_select(uid: *const c_char) -> *mut GstEvent;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_event_copy(event: *const GstEvent) -> *mut GstEvent;
    pub fn gst_event_copy_segment(event: *mut GstEvent, segment: *mut GstSegment);
    pub fn gst_event_get_running_time_offset(event: *mut GstEvent) -> i64;
    pub fn gst_event_get_seqnum(event: *mut GstEvent) -> u32;
    pub fn gst_event_get_structure(event: *mut GstEvent) -> *const GstStructure;
    pub fn gst_event_has_name(event: *mut GstEvent, name: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_event_has_name_id(event: *mut GstEvent, name: glib::GQuark) -> gboolean;
    pub fn gst_event_parse_buffer_size(
        event: *mut GstEvent,
        format: *mut GstFormat,
        minsize: *mut i64,
        maxsize: *mut i64,
        async_: *mut gboolean,
    );
    pub fn gst_event_parse_caps(event: *mut GstEvent, caps: *mut *mut GstCaps);
    pub fn gst_event_parse_flush_stop(event: *mut GstEvent, reset_time: *mut gboolean);
    pub fn gst_event_parse_gap(
        event: *mut GstEvent,
        timestamp: *mut GstClockTime,
        duration: *mut GstClockTime,
    );
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_event_parse_gap_flags(event: *mut GstEvent, flags: *mut GstGapFlags);
    pub fn gst_event_parse_group_id(event: *mut GstEvent, group_id: *mut c_uint) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_event_parse_instant_rate_change(
        event: *mut GstEvent,
        rate_multiplier: *mut c_double,
        new_flags: *mut GstSegmentFlags,
    );
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_event_parse_instant_rate_sync_time(
        event: *mut GstEvent,
        rate_multiplier: *mut c_double,
        running_time: *mut GstClockTime,
        upstream_running_time: *mut GstClockTime,
    );
    pub fn gst_event_parse_latency(event: *mut GstEvent, latency: *mut GstClockTime);
    pub fn gst_event_parse_protection(
        event: *mut GstEvent,
        system_id: *mut *const c_char,
        data: *mut *mut GstBuffer,
        origin: *mut *const c_char,
    );
    pub fn gst_event_parse_qos(
        event: *mut GstEvent,
        type_: *mut GstQOSType,
        proportion: *mut c_double,
        diff: *mut GstClockTimeDiff,
        timestamp: *mut GstClockTime,
    );
    pub fn gst_event_parse_seek(
        event: *mut GstEvent,
        rate: *mut c_double,
        format: *mut GstFormat,
        flags: *mut GstSeekFlags,
        start_type: *mut GstSeekType,
        start: *mut i64,
        stop_type: *mut GstSeekType,
        stop: *mut i64,
    );
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_event_parse_seek_trickmode_interval(
        event: *mut GstEvent,
        interval: *mut GstClockTime,
    );
    pub fn gst_event_parse_segment(event: *mut GstEvent, segment: *mut *const GstSegment);
    pub fn gst_event_parse_segment_done(
        event: *mut GstEvent,
        format: *mut GstFormat,
        position: *mut i64,
    );
    pub fn gst_event_parse_select_streams(event: *mut GstEvent, streams: *mut *mut glib::GList);
    pub fn gst_event_parse_sink_message(event: *mut GstEvent, msg: *mut *mut GstMessage);
    pub fn gst_event_parse_step(
        event: *mut GstEvent,
        format: *mut GstFormat,
        amount: *mut u64,
        rate: *mut c_double,
        flush: *mut gboolean,
        intermediate: *mut gboolean,
    );
    pub fn gst_event_parse_stream(event: *mut GstEvent, stream: *mut *mut GstStream);
    pub fn gst_event_parse_stream_collection(
        event: *mut GstEvent,
        collection: *mut *mut GstStreamCollection,
    );
    pub fn gst_event_parse_stream_flags(event: *mut GstEvent, flags: *mut GstStreamFlags);
    pub fn gst_event_parse_stream_group_done(event: *mut GstEvent, group_id: *mut c_uint);
    pub fn gst_event_parse_stream_start(event: *mut GstEvent, stream_id: *mut *const c_char);
    pub fn gst_event_parse_tag(event: *mut GstEvent, taglist: *mut *mut GstTagList);
    pub fn gst_event_parse_toc(event: *mut GstEvent, toc: *mut *mut GstToc, updated: *mut gboolean);
    pub fn gst_event_parse_toc_select(event: *mut GstEvent, uid: *mut *mut c_char);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_event_ref(event: *mut GstEvent) -> *mut GstEvent;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_event_set_gap_flags(event: *mut GstEvent, flags: GstGapFlags);
    pub fn gst_event_set_group_id(event: *mut GstEvent, group_id: c_uint);
    pub fn gst_event_set_running_time_offset(event: *mut GstEvent, offset: i64);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_event_set_seek_trickmode_interval(event: *mut GstEvent, interval: GstClockTime);
    pub fn gst_event_set_seqnum(event: *mut GstEvent, seqnum: u32);
    pub fn gst_event_set_stream(event: *mut GstEvent, stream: *mut GstStream);
    pub fn gst_event_set_stream_flags(event: *mut GstEvent, flags: GstStreamFlags);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_event_unref(event: *mut GstEvent);
    pub fn gst_event_writable_structure(event: *mut GstEvent) -> *mut GstStructure;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_event_replace(old_event: *mut *mut GstEvent, new_event: *mut GstEvent) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_event_steal(old_event: *mut *mut GstEvent) -> *mut GstEvent;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_event_take(old_event: *mut *mut GstEvent, new_event: *mut GstEvent) -> gboolean;

    //=========================================================================
    // GstIterator
    //=========================================================================
    pub fn gst_iterator_get_type() -> GType;
    pub fn gst_iterator_new(
        size: c_uint,
        type_: GType,
        lock: *mut glib::GMutex,
        master_cookie: *mut u32,
        copy: GstIteratorCopyFunction,
        next: GstIteratorNextFunction,
        item: GstIteratorItemFunction,
        resync: GstIteratorResyncFunction,
        free: GstIteratorFreeFunction,
    ) -> *mut GstIterator;
    pub fn gst_iterator_new_list(
        type_: GType,
        lock: *mut glib::GMutex,
        master_cookie: *mut u32,
        list: *mut *mut glib::GList,
        owner: *mut gobject::GObject,
        item: GstIteratorItemFunction,
    ) -> *mut GstIterator;
    pub fn gst_iterator_new_single(
        type_: GType,
        object: *const gobject::GValue,
    ) -> *mut GstIterator;
    pub fn gst_iterator_copy(it: *const GstIterator) -> *mut GstIterator;
    pub fn gst_iterator_filter(
        it: *mut GstIterator,
        func: glib::GCompareFunc,
        user_data: *const gobject::GValue,
    ) -> *mut GstIterator;
    pub fn gst_iterator_find_custom(
        it: *mut GstIterator,
        func: glib::GCompareFunc,
        elem: *mut gobject::GValue,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_iterator_fold(
        it: *mut GstIterator,
        func: GstIteratorFoldFunction,
        ret: *mut gobject::GValue,
        user_data: gpointer,
    ) -> GstIteratorResult;
    pub fn gst_iterator_foreach(
        it: *mut GstIterator,
        func: GstIteratorForeachFunction,
        user_data: gpointer,
    ) -> GstIteratorResult;
    pub fn gst_iterator_free(it: *mut GstIterator);
    pub fn gst_iterator_next(it: *mut GstIterator, elem: *mut gobject::GValue)
        -> GstIteratorResult;
    pub fn gst_iterator_push(it: *mut GstIterator, other: *mut GstIterator);
    pub fn gst_iterator_resync(it: *mut GstIterator);

    //=========================================================================
    // GstMemory
    //=========================================================================
    pub fn gst_memory_get_type() -> GType;
    pub fn gst_memory_new_wrapped(
        flags: GstMemoryFlags,
        data: gpointer,
        maxsize: size_t,
        offset: size_t,
        size: size_t,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    ) -> *mut GstMemory;
    pub fn gst_memory_copy(mem: *mut GstMemory, offset: ssize_t, size: ssize_t) -> *mut GstMemory;
    pub fn gst_memory_get_sizes(
        mem: *mut GstMemory,
        offset: *mut size_t,
        maxsize: *mut size_t,
    ) -> size_t;
    pub fn gst_memory_init(
        mem: *mut GstMemory,
        flags: GstMemoryFlags,
        allocator: *mut GstAllocator,
        parent: *mut GstMemory,
        maxsize: size_t,
        align: size_t,
        offset: size_t,
        size: size_t,
    );
    pub fn gst_memory_is_span(
        mem1: *mut GstMemory,
        mem2: *mut GstMemory,
        offset: *mut size_t,
    ) -> gboolean;
    pub fn gst_memory_is_type(mem: *mut GstMemory, mem_type: *const c_char) -> gboolean;
    pub fn gst_memory_make_mapped(
        mem: *mut GstMemory,
        info: *mut GstMapInfo,
        flags: GstMapFlags,
    ) -> *mut GstMemory;
    pub fn gst_memory_map(
        mem: *mut GstMemory,
        info: *mut GstMapInfo,
        flags: GstMapFlags,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_memory_ref(memory: *mut GstMemory) -> *mut GstMemory;
    pub fn gst_memory_resize(mem: *mut GstMemory, offset: ssize_t, size: size_t);
    pub fn gst_memory_share(mem: *mut GstMemory, offset: ssize_t, size: ssize_t) -> *mut GstMemory;
    pub fn gst_memory_unmap(mem: *mut GstMemory, info: *mut GstMapInfo);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_memory_unref(memory: *mut GstMemory);

    //=========================================================================
    // GstMessage
    //=========================================================================
    pub fn gst_message_get_type() -> GType;
    pub fn gst_message_new_application(
        src: *mut GstObject,
        structure: *mut GstStructure,
    ) -> *mut GstMessage;
    pub fn gst_message_new_async_done(
        src: *mut GstObject,
        running_time: GstClockTime,
    ) -> *mut GstMessage;
    pub fn gst_message_new_async_start(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_buffering(src: *mut GstObject, percent: c_int) -> *mut GstMessage;
    pub fn gst_message_new_clock_lost(src: *mut GstObject, clock: *mut GstClock)
        -> *mut GstMessage;
    pub fn gst_message_new_clock_provide(
        src: *mut GstObject,
        clock: *mut GstClock,
        ready: gboolean,
    ) -> *mut GstMessage;
    pub fn gst_message_new_custom(
        type_: GstMessageType,
        src: *mut GstObject,
        structure: *mut GstStructure,
    ) -> *mut GstMessage;
    pub fn gst_message_new_device_added(
        src: *mut GstObject,
        device: *mut GstDevice,
    ) -> *mut GstMessage;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_message_new_device_changed(
        src: *mut GstObject,
        device: *mut GstDevice,
        changed_device: *mut GstDevice,
    ) -> *mut GstMessage;
    pub fn gst_message_new_device_removed(
        src: *mut GstObject,
        device: *mut GstDevice,
    ) -> *mut GstMessage;
    pub fn gst_message_new_duration_changed(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_element(
        src: *mut GstObject,
        structure: *mut GstStructure,
    ) -> *mut GstMessage;
    pub fn gst_message_new_eos(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_error(
        src: *mut GstObject,
        error: *mut glib::GError,
        debug: *const c_char,
    ) -> *mut GstMessage;
    pub fn gst_message_new_error_with_details(
        src: *mut GstObject,
        error: *mut glib::GError,
        debug: *const c_char,
        details: *mut GstStructure,
    ) -> *mut GstMessage;
    pub fn gst_message_new_have_context(
        src: *mut GstObject,
        context: *mut GstContext,
    ) -> *mut GstMessage;
    pub fn gst_message_new_info(
        src: *mut GstObject,
        error: *mut glib::GError,
        debug: *const c_char,
    ) -> *mut GstMessage;
    pub fn gst_message_new_info_with_details(
        src: *mut GstObject,
        error: *mut glib::GError,
        debug: *const c_char,
        details: *mut GstStructure,
    ) -> *mut GstMessage;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_message_new_instant_rate_request(
        src: *mut GstObject,
        rate_multiplier: c_double,
    ) -> *mut GstMessage;
    pub fn gst_message_new_latency(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_need_context(
        src: *mut GstObject,
        context_type: *const c_char,
    ) -> *mut GstMessage;
    pub fn gst_message_new_new_clock(src: *mut GstObject, clock: *mut GstClock) -> *mut GstMessage;
    pub fn gst_message_new_progress(
        src: *mut GstObject,
        type_: GstProgressType,
        code: *const c_char,
        text: *const c_char,
    ) -> *mut GstMessage;
    pub fn gst_message_new_property_notify(
        src: *mut GstObject,
        property_name: *const c_char,
        val: *mut gobject::GValue,
    ) -> *mut GstMessage;
    pub fn gst_message_new_qos(
        src: *mut GstObject,
        live: gboolean,
        running_time: u64,
        stream_time: u64,
        timestamp: u64,
        duration: u64,
    ) -> *mut GstMessage;
    pub fn gst_message_new_redirect(
        src: *mut GstObject,
        location: *const c_char,
        tag_list: *mut GstTagList,
        entry_struct: *const GstStructure,
    ) -> *mut GstMessage;
    pub fn gst_message_new_request_state(src: *mut GstObject, state: GstState) -> *mut GstMessage;
    pub fn gst_message_new_reset_time(
        src: *mut GstObject,
        running_time: GstClockTime,
    ) -> *mut GstMessage;
    pub fn gst_message_new_segment_done(
        src: *mut GstObject,
        format: GstFormat,
        position: i64,
    ) -> *mut GstMessage;
    pub fn gst_message_new_segment_start(
        src: *mut GstObject,
        format: GstFormat,
        position: i64,
    ) -> *mut GstMessage;
    pub fn gst_message_new_state_changed(
        src: *mut GstObject,
        oldstate: GstState,
        newstate: GstState,
        pending: GstState,
    ) -> *mut GstMessage;
    pub fn gst_message_new_state_dirty(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_step_done(
        src: *mut GstObject,
        format: GstFormat,
        amount: u64,
        rate: c_double,
        flush: gboolean,
        intermediate: gboolean,
        duration: u64,
        eos: gboolean,
    ) -> *mut GstMessage;
    pub fn gst_message_new_step_start(
        src: *mut GstObject,
        active: gboolean,
        format: GstFormat,
        amount: u64,
        rate: c_double,
        flush: gboolean,
        intermediate: gboolean,
    ) -> *mut GstMessage;
    pub fn gst_message_new_stream_collection(
        src: *mut GstObject,
        collection: *mut GstStreamCollection,
    ) -> *mut GstMessage;
    pub fn gst_message_new_stream_start(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_stream_status(
        src: *mut GstObject,
        type_: GstStreamStatusType,
        owner: *mut GstElement,
    ) -> *mut GstMessage;
    pub fn gst_message_new_streams_selected(
        src: *mut GstObject,
        collection: *mut GstStreamCollection,
    ) -> *mut GstMessage;
    pub fn gst_message_new_structure_change(
        src: *mut GstObject,
        type_: GstStructureChangeType,
        owner: *mut GstElement,
        busy: gboolean,
    ) -> *mut GstMessage;
    pub fn gst_message_new_tag(src: *mut GstObject, tag_list: *mut GstTagList) -> *mut GstMessage;
    pub fn gst_message_new_toc(
        src: *mut GstObject,
        toc: *mut GstToc,
        updated: gboolean,
    ) -> *mut GstMessage;
    pub fn gst_message_new_warning(
        src: *mut GstObject,
        error: *mut glib::GError,
        debug: *const c_char,
    ) -> *mut GstMessage;
    pub fn gst_message_new_warning_with_details(
        src: *mut GstObject,
        error: *mut glib::GError,
        debug: *const c_char,
        details: *mut GstStructure,
    ) -> *mut GstMessage;
    pub fn gst_message_add_redirect_entry(
        message: *mut GstMessage,
        location: *const c_char,
        tag_list: *mut GstTagList,
        entry_struct: *const GstStructure,
    );
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_message_copy(msg: *const GstMessage) -> *mut GstMessage;
    pub fn gst_message_get_num_redirect_entries(message: *mut GstMessage) -> size_t;
    pub fn gst_message_get_seqnum(message: *mut GstMessage) -> u32;
    pub fn gst_message_get_stream_status_object(message: *mut GstMessage)
        -> *const gobject::GValue;
    pub fn gst_message_get_structure(message: *mut GstMessage) -> *const GstStructure;
    pub fn gst_message_has_name(message: *mut GstMessage, name: *const c_char) -> gboolean;
    pub fn gst_message_parse_async_done(message: *mut GstMessage, running_time: *mut GstClockTime);
    pub fn gst_message_parse_buffering(message: *mut GstMessage, percent: *mut c_int);
    pub fn gst_message_parse_buffering_stats(
        message: *mut GstMessage,
        mode: *mut GstBufferingMode,
        avg_in: *mut c_int,
        avg_out: *mut c_int,
        buffering_left: *mut i64,
    );
    pub fn gst_message_parse_clock_lost(message: *mut GstMessage, clock: *mut *mut GstClock);
    pub fn gst_message_parse_clock_provide(
        message: *mut GstMessage,
        clock: *mut *mut GstClock,
        ready: *mut gboolean,
    );
    pub fn gst_message_parse_context_type(
        message: *mut GstMessage,
        context_type: *mut *const c_char,
    ) -> gboolean;
    pub fn gst_message_parse_device_added(message: *mut GstMessage, device: *mut *mut GstDevice);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_message_parse_device_changed(
        message: *mut GstMessage,
        device: *mut *mut GstDevice,
        changed_device: *mut *mut GstDevice,
    );
    pub fn gst_message_parse_device_removed(message: *mut GstMessage, device: *mut *mut GstDevice);
    pub fn gst_message_parse_error(
        message: *mut GstMessage,
        gerror: *mut *mut glib::GError,
        debug: *mut *mut c_char,
    );
    pub fn gst_message_parse_error_details(
        message: *mut GstMessage,
        structure: *mut *const GstStructure,
    );
    pub fn gst_message_parse_group_id(message: *mut GstMessage, group_id: *mut c_uint) -> gboolean;
    pub fn gst_message_parse_have_context(message: *mut GstMessage, context: *mut *mut GstContext);
    pub fn gst_message_parse_info(
        message: *mut GstMessage,
        gerror: *mut *mut glib::GError,
        debug: *mut *mut c_char,
    );
    pub fn gst_message_parse_info_details(
        message: *mut GstMessage,
        structure: *mut *const GstStructure,
    );
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_message_parse_instant_rate_request(
        message: *mut GstMessage,
        rate_multiplier: *mut c_double,
    );
    pub fn gst_message_parse_new_clock(message: *mut GstMessage, clock: *mut *mut GstClock);
    pub fn gst_message_parse_progress(
        message: *mut GstMessage,
        type_: *mut GstProgressType,
        code: *mut *mut c_char,
        text: *mut *mut c_char,
    );
    pub fn gst_message_parse_property_notify(
        message: *mut GstMessage,
        object: *mut *mut GstObject,
        property_name: *mut *const c_char,
        property_value: *mut *const gobject::GValue,
    );
    pub fn gst_message_parse_qos(
        message: *mut GstMessage,
        live: *mut gboolean,
        running_time: *mut u64,
        stream_time: *mut u64,
        timestamp: *mut u64,
        duration: *mut u64,
    );
    pub fn gst_message_parse_qos_stats(
        message: *mut GstMessage,
        format: *mut GstFormat,
        processed: *mut u64,
        dropped: *mut u64,
    );
    pub fn gst_message_parse_qos_values(
        message: *mut GstMessage,
        jitter: *mut i64,
        proportion: *mut c_double,
        quality: *mut c_int,
    );
    pub fn gst_message_parse_redirect_entry(
        message: *mut GstMessage,
        entry_index: size_t,
        location: *mut *const c_char,
        tag_list: *mut *mut GstTagList,
        entry_struct: *mut *const GstStructure,
    );
    pub fn gst_message_parse_request_state(message: *mut GstMessage, state: *mut GstState);
    pub fn gst_message_parse_reset_time(message: *mut GstMessage, running_time: *mut GstClockTime);
    pub fn gst_message_parse_segment_done(
        message: *mut GstMessage,
        format: *mut GstFormat,
        position: *mut i64,
    );
    pub fn gst_message_parse_segment_start(
        message: *mut GstMessage,
        format: *mut GstFormat,
        position: *mut i64,
    );
    pub fn gst_message_parse_state_changed(
        message: *mut GstMessage,
        oldstate: *mut GstState,
        newstate: *mut GstState,
        pending: *mut GstState,
    );
    pub fn gst_message_parse_step_done(
        message: *mut GstMessage,
        format: *mut GstFormat,
        amount: *mut u64,
        rate: *mut c_double,
        flush: *mut gboolean,
        intermediate: *mut gboolean,
        duration: *mut u64,
        eos: *mut gboolean,
    );
    pub fn gst_message_parse_step_start(
        message: *mut GstMessage,
        active: *mut gboolean,
        format: *mut GstFormat,
        amount: *mut u64,
        rate: *mut c_double,
        flush: *mut gboolean,
        intermediate: *mut gboolean,
    );
    pub fn gst_message_parse_stream_collection(
        message: *mut GstMessage,
        collection: *mut *mut GstStreamCollection,
    );
    pub fn gst_message_parse_stream_status(
        message: *mut GstMessage,
        type_: *mut GstStreamStatusType,
        owner: *mut *mut GstElement,
    );
    pub fn gst_message_parse_streams_selected(
        message: *mut GstMessage,
        collection: *mut *mut GstStreamCollection,
    );
    pub fn gst_message_parse_structure_change(
        message: *mut GstMessage,
        type_: *mut GstStructureChangeType,
        owner: *mut *mut GstElement,
        busy: *mut gboolean,
    );
    pub fn gst_message_parse_tag(message: *mut GstMessage, tag_list: *mut *mut GstTagList);
    pub fn gst_message_parse_toc(
        message: *mut GstMessage,
        toc: *mut *mut GstToc,
        updated: *mut gboolean,
    );
    pub fn gst_message_parse_warning(
        message: *mut GstMessage,
        gerror: *mut *mut glib::GError,
        debug: *mut *mut c_char,
    );
    pub fn gst_message_parse_warning_details(
        message: *mut GstMessage,
        structure: *mut *const GstStructure,
    );
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_message_ref(msg: *mut GstMessage) -> *mut GstMessage;
    pub fn gst_message_set_buffering_stats(
        message: *mut GstMessage,
        mode: GstBufferingMode,
        avg_in: c_int,
        avg_out: c_int,
        buffering_left: i64,
    );
    pub fn gst_message_set_group_id(message: *mut GstMessage, group_id: c_uint);
    pub fn gst_message_set_qos_stats(
        message: *mut GstMessage,
        format: GstFormat,
        processed: u64,
        dropped: u64,
    );
    pub fn gst_message_set_qos_values(
        message: *mut GstMessage,
        jitter: i64,
        proportion: c_double,
        quality: c_int,
    );
    pub fn gst_message_set_seqnum(message: *mut GstMessage, seqnum: u32);
    pub fn gst_message_set_stream_status_object(
        message: *mut GstMessage,
        object: *const gobject::GValue,
    );
    pub fn gst_message_streams_selected_add(message: *mut GstMessage, stream: *mut GstStream);
    pub fn gst_message_streams_selected_get_size(message: *mut GstMessage) -> c_uint;
    pub fn gst_message_streams_selected_get_stream(
        message: *mut GstMessage,
        idx: c_uint,
    ) -> *mut GstStream;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_message_unref(msg: *mut GstMessage);
    pub fn gst_message_writable_structure(message: *mut GstMessage) -> *mut GstStructure;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_message_replace(
        old_message: *mut *mut GstMessage,
        new_message: *mut GstMessage,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_message_take(
        old_message: *mut *mut GstMessage,
        new_message: *mut GstMessage,
    ) -> gboolean;

    //=========================================================================
    // GstMeta
    //=========================================================================
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_meta_compare_seqnum(meta1: *const GstMeta, meta2: *const GstMeta) -> c_int;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_meta_get_seqnum(meta: *const GstMeta) -> u64;
    pub fn gst_meta_api_type_get_tags(api: GType) -> *const *const c_char;
    pub fn gst_meta_api_type_has_tag(api: GType, tag: glib::GQuark) -> gboolean;
    pub fn gst_meta_api_type_register(api: *const c_char, tags: *mut *const c_char) -> GType;
    pub fn gst_meta_get_info(impl_: *const c_char) -> *const GstMetaInfo;
    pub fn gst_meta_register(
        api: GType,
        impl_: *const c_char,
        size: size_t,
        init_func: GstMetaInitFunction,
        free_func: GstMetaFreeFunction,
        transform_func: GstMetaTransformFunction,
    ) -> *const GstMetaInfo;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_meta_register_custom(
        name: *const c_char,
        tags: *mut *const c_char,
        transform_func: GstCustomMetaTransformFunction,
        user_data: gpointer,
        destroy_data: glib::GDestroyNotify,
    ) -> *const GstMetaInfo;

    //=========================================================================
    // GstMetaInfo
    //=========================================================================
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_meta_info_is_custom(info: *const GstMetaInfo) -> gboolean;

    //=========================================================================
    // GstMiniObject
    //=========================================================================
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_mini_object_get_type() -> GType;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_mini_object_add_parent(object: *mut GstMiniObject, parent: *mut GstMiniObject);
    pub fn gst_mini_object_copy(mini_object: *const GstMiniObject) -> *mut GstMiniObject;
    pub fn gst_mini_object_get_qdata(object: *mut GstMiniObject, quark: glib::GQuark) -> gpointer;
    pub fn gst_mini_object_init(
        mini_object: *mut GstMiniObject,
        flags: c_uint,
        type_: GType,
        copy_func: GstMiniObjectCopyFunction,
        dispose_func: GstMiniObjectDisposeFunction,
        free_func: GstMiniObjectFreeFunction,
    );
    pub fn gst_mini_object_is_writable(mini_object: *const GstMiniObject) -> gboolean;
    pub fn gst_mini_object_lock(object: *mut GstMiniObject, flags: GstLockFlags) -> gboolean;
    pub fn gst_mini_object_make_writable(mini_object: *mut GstMiniObject) -> *mut GstMiniObject;
    pub fn gst_mini_object_ref(mini_object: *mut GstMiniObject) -> *mut GstMiniObject;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_mini_object_remove_parent(object: *mut GstMiniObject, parent: *mut GstMiniObject);
    pub fn gst_mini_object_set_qdata(
        object: *mut GstMiniObject,
        quark: glib::GQuark,
        data: gpointer,
        destroy: glib::GDestroyNotify,
    );
    pub fn gst_mini_object_steal_qdata(object: *mut GstMiniObject, quark: glib::GQuark)
        -> gpointer;
    pub fn gst_mini_object_unlock(object: *mut GstMiniObject, flags: GstLockFlags);
    pub fn gst_mini_object_unref(mini_object: *mut GstMiniObject);
    pub fn gst_mini_object_weak_ref(
        object: *mut GstMiniObject,
        notify: GstMiniObjectNotify,
        data: gpointer,
    );
    pub fn gst_mini_object_weak_unref(
        object: *mut GstMiniObject,
        notify: GstMiniObjectNotify,
        data: gpointer,
    );
    pub fn gst_mini_object_replace(
        olddata: *mut *mut GstMiniObject,
        newdata: *mut GstMiniObject,
    ) -> gboolean;
    pub fn gst_mini_object_steal(olddata: *mut *mut GstMiniObject) -> *mut GstMiniObject;
    pub fn gst_mini_object_take(
        olddata: *mut *mut GstMiniObject,
        newdata: *mut GstMiniObject,
    ) -> gboolean;

    //=========================================================================
    // GstPadProbeInfo
    //=========================================================================
    pub fn gst_pad_probe_info_get_buffer(info: *mut GstPadProbeInfo) -> *mut GstBuffer;
    pub fn gst_pad_probe_info_get_buffer_list(info: *mut GstPadProbeInfo) -> *mut GstBufferList;
    pub fn gst_pad_probe_info_get_event(info: *mut GstPadProbeInfo) -> *mut GstEvent;
    pub fn gst_pad_probe_info_get_query(info: *mut GstPadProbeInfo) -> *mut GstQuery;

    //=========================================================================
    // GstParentBufferMeta
    //=========================================================================
    pub fn gst_parent_buffer_meta_get_info() -> *const GstMetaInfo;

    //=========================================================================
    // GstParseContext
    //=========================================================================
    pub fn gst_parse_context_get_type() -> GType;
    pub fn gst_parse_context_new() -> *mut GstParseContext;
    pub fn gst_parse_context_copy(context: *const GstParseContext) -> *mut GstParseContext;
    pub fn gst_parse_context_free(context: *mut GstParseContext);
    pub fn gst_parse_context_get_missing_elements(
        context: *mut GstParseContext,
    ) -> *mut *mut c_char;

    //=========================================================================
    // GstPoll
    //=========================================================================
    pub fn gst_poll_add_fd(set: *mut GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_can_read(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_can_write(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_poll_fd_ctl_pri(set: *mut GstPoll, fd: *mut GstPollFD, active: gboolean)
        -> gboolean;
    pub fn gst_poll_fd_ctl_read(
        set: *mut GstPoll,
        fd: *mut GstPollFD,
        active: gboolean,
    ) -> gboolean;
    pub fn gst_poll_fd_ctl_write(
        set: *mut GstPoll,
        fd: *mut GstPollFD,
        active: gboolean,
    ) -> gboolean;
    pub fn gst_poll_fd_has_closed(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_has_error(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_poll_fd_has_pri(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_ignored(set: *mut GstPoll, fd: *mut GstPollFD);
    pub fn gst_poll_free(set: *mut GstPoll);
    pub fn gst_poll_get_read_gpollfd(set: *mut GstPoll, fd: *mut glib::GPollFD);
    pub fn gst_poll_read_control(set: *mut GstPoll) -> gboolean;
    pub fn gst_poll_remove_fd(set: *mut GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_restart(set: *mut GstPoll);
    pub fn gst_poll_set_controllable(set: *mut GstPoll, controllable: gboolean) -> gboolean;
    pub fn gst_poll_set_flushing(set: *mut GstPoll, flushing: gboolean);
    pub fn gst_poll_wait(set: *mut GstPoll, timeout: GstClockTime) -> c_int;
    pub fn gst_poll_write_control(set: *mut GstPoll) -> gboolean;
    pub fn gst_poll_new(controllable: gboolean) -> *mut GstPoll;
    pub fn gst_poll_new_timer() -> *mut GstPoll;

    //=========================================================================
    // GstPollFD
    //=========================================================================
    pub fn gst_poll_fd_init(fd: *mut GstPollFD);

    //=========================================================================
    // GstPromise
    //=========================================================================
    pub fn gst_promise_get_type() -> GType;
    pub fn gst_promise_new() -> *mut GstPromise;
    pub fn gst_promise_new_with_change_func(
        func: GstPromiseChangeFunc,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    ) -> *mut GstPromise;
    pub fn gst_promise_expire(promise: *mut GstPromise);
    pub fn gst_promise_get_reply(promise: *mut GstPromise) -> *const GstStructure;
    pub fn gst_promise_interrupt(promise: *mut GstPromise);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_promise_ref(promise: *mut GstPromise) -> *mut GstPromise;
    pub fn gst_promise_reply(promise: *mut GstPromise, s: *mut GstStructure);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_promise_unref(promise: *mut GstPromise);
    pub fn gst_promise_wait(promise: *mut GstPromise) -> GstPromiseResult;

    //=========================================================================
    // GstProtectionMeta
    //=========================================================================
    pub fn gst_protection_meta_get_info() -> *const GstMetaInfo;

    //=========================================================================
    // GstQuery
    //=========================================================================
    pub fn gst_query_get_type() -> GType;
    pub fn gst_query_new_accept_caps(caps: *mut GstCaps) -> *mut GstQuery;
    pub fn gst_query_new_allocation(caps: *mut GstCaps, need_pool: gboolean) -> *mut GstQuery;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_query_new_bitrate() -> *mut GstQuery;
    pub fn gst_query_new_buffering(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_caps(filter: *mut GstCaps) -> *mut GstQuery;
    pub fn gst_query_new_context(context_type: *const c_char) -> *mut GstQuery;
    pub fn gst_query_new_convert(
        src_format: GstFormat,
        value: i64,
        dest_format: GstFormat,
    ) -> *mut GstQuery;
    pub fn gst_query_new_custom(type_: GstQueryType, structure: *mut GstStructure)
        -> *mut GstQuery;
    pub fn gst_query_new_drain() -> *mut GstQuery;
    pub fn gst_query_new_duration(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_formats() -> *mut GstQuery;
    pub fn gst_query_new_latency() -> *mut GstQuery;
    pub fn gst_query_new_position(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_scheduling() -> *mut GstQuery;
    pub fn gst_query_new_seeking(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_segment(format: GstFormat) -> *mut GstQuery;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    pub fn gst_query_new_selectable() -> *mut GstQuery;
    pub fn gst_query_new_uri() -> *mut GstQuery;
    pub fn gst_query_add_allocation_meta(
        query: *mut GstQuery,
        api: GType,
        params: *const GstStructure,
    );
    pub fn gst_query_add_allocation_param(
        query: *mut GstQuery,
        allocator: *mut GstAllocator,
        params: *const GstAllocationParams,
    );
    pub fn gst_query_add_allocation_pool(
        query: *mut GstQuery,
        pool: *mut GstBufferPool,
        size: c_uint,
        min_buffers: c_uint,
        max_buffers: c_uint,
    );
    pub fn gst_query_add_buffering_range(query: *mut GstQuery, start: i64, stop: i64) -> gboolean;
    pub fn gst_query_add_scheduling_mode(query: *mut GstQuery, mode: GstPadMode);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_query_copy(q: *const GstQuery) -> *mut GstQuery;
    pub fn gst_query_find_allocation_meta(
        query: *mut GstQuery,
        api: GType,
        index: *mut c_uint,
    ) -> gboolean;
    pub fn gst_query_get_n_allocation_metas(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_allocation_params(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_allocation_pools(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_buffering_ranges(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_scheduling_modes(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_structure(query: *mut GstQuery) -> *const GstStructure;
    pub fn gst_query_has_scheduling_mode(query: *mut GstQuery, mode: GstPadMode) -> gboolean;
    pub fn gst_query_has_scheduling_mode_with_flags(
        query: *mut GstQuery,
        mode: GstPadMode,
        flags: GstSchedulingFlags,
    ) -> gboolean;
    pub fn gst_query_parse_accept_caps(query: *mut GstQuery, caps: *mut *mut GstCaps);
    pub fn gst_query_parse_accept_caps_result(query: *mut GstQuery, result: *mut gboolean);
    pub fn gst_query_parse_allocation(
        query: *mut GstQuery,
        caps: *mut *mut GstCaps,
        need_pool: *mut gboolean,
    );
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_query_parse_bitrate(query: *mut GstQuery, nominal_bitrate: *mut c_uint);
    pub fn gst_query_parse_buffering_percent(
        query: *mut GstQuery,
        busy: *mut gboolean,
        percent: *mut c_int,
    );
    pub fn gst_query_parse_buffering_range(
        query: *mut GstQuery,
        format: *mut GstFormat,
        start: *mut i64,
        stop: *mut i64,
        estimated_total: *mut i64,
    );
    pub fn gst_query_parse_buffering_stats(
        query: *mut GstQuery,
        mode: *mut GstBufferingMode,
        avg_in: *mut c_int,
        avg_out: *mut c_int,
        buffering_left: *mut i64,
    );
    pub fn gst_query_parse_caps(query: *mut GstQuery, filter: *mut *mut GstCaps);
    pub fn gst_query_parse_caps_result(query: *mut GstQuery, caps: *mut *mut GstCaps);
    pub fn gst_query_parse_context(query: *mut GstQuery, context: *mut *mut GstContext);
    pub fn gst_query_parse_context_type(
        query: *mut GstQuery,
        context_type: *mut *const c_char,
    ) -> gboolean;
    pub fn gst_query_parse_convert(
        query: *mut GstQuery,
        src_format: *mut GstFormat,
        src_value: *mut i64,
        dest_format: *mut GstFormat,
        dest_value: *mut i64,
    );
    pub fn gst_query_parse_duration(
        query: *mut GstQuery,
        format: *mut GstFormat,
        duration: *mut i64,
    );
    pub fn gst_query_parse_latency(
        query: *mut GstQuery,
        live: *mut gboolean,
        min_latency: *mut GstClockTime,
        max_latency: *mut GstClockTime,
    );
    pub fn gst_query_parse_n_formats(query: *mut GstQuery, n_formats: *mut c_uint);
    pub fn gst_query_parse_nth_allocation_meta(
        query: *mut GstQuery,
        index: c_uint,
        params: *mut *const GstStructure,
    ) -> GType;
    pub fn gst_query_parse_nth_allocation_param(
        query: *mut GstQuery,
        index: c_uint,
        allocator: *mut *mut GstAllocator,
        params: *mut GstAllocationParams,
    );
    pub fn gst_query_parse_nth_allocation_pool(
        query: *mut GstQuery,
        index: c_uint,
        pool: *mut *mut GstBufferPool,
        size: *mut c_uint,
        min_buffers: *mut c_uint,
        max_buffers: *mut c_uint,
    );
    pub fn gst_query_parse_nth_buffering_range(
        query: *mut GstQuery,
        index: c_uint,
        start: *mut i64,
        stop: *mut i64,
    ) -> gboolean;
    pub fn gst_query_parse_nth_format(query: *mut GstQuery, nth: c_uint, format: *mut GstFormat);
    pub fn gst_query_parse_nth_scheduling_mode(query: *mut GstQuery, index: c_uint) -> GstPadMode;
    pub fn gst_query_parse_position(query: *mut GstQuery, format: *mut GstFormat, cur: *mut i64);
    pub fn gst_query_parse_scheduling(
        query: *mut GstQuery,
        flags: *mut GstSchedulingFlags,
        minsize: *mut c_int,
        maxsize: *mut c_int,
        align: *mut c_int,
    );
    pub fn gst_query_parse_seeking(
        query: *mut GstQuery,
        format: *mut GstFormat,
        seekable: *mut gboolean,
        segment_start: *mut i64,
        segment_end: *mut i64,
    );
    pub fn gst_query_parse_segment(
        query: *mut GstQuery,
        rate: *mut c_double,
        format: *mut GstFormat,
        start_value: *mut i64,
        stop_value: *mut i64,
    );
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    pub fn gst_query_parse_selectable(query: *mut GstQuery, selectable: *mut gboolean);
    pub fn gst_query_parse_uri(query: *mut GstQuery, uri: *mut *mut c_char);
    pub fn gst_query_parse_uri_redirection(query: *mut GstQuery, uri: *mut *mut c_char);
    pub fn gst_query_parse_uri_redirection_permanent(
        query: *mut GstQuery,
        permanent: *mut gboolean,
    );
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_query_ref(q: *mut GstQuery) -> *mut GstQuery;
    pub fn gst_query_remove_nth_allocation_meta(query: *mut GstQuery, index: c_uint);
    pub fn gst_query_remove_nth_allocation_param(query: *mut GstQuery, index: c_uint);
    pub fn gst_query_remove_nth_allocation_pool(query: *mut GstQuery, index: c_uint);
    pub fn gst_query_set_accept_caps_result(query: *mut GstQuery, result: gboolean);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_query_set_bitrate(query: *mut GstQuery, nominal_bitrate: c_uint);
    pub fn gst_query_set_buffering_percent(query: *mut GstQuery, busy: gboolean, percent: c_int);
    pub fn gst_query_set_buffering_range(
        query: *mut GstQuery,
        format: GstFormat,
        start: i64,
        stop: i64,
        estimated_total: i64,
    );
    pub fn gst_query_set_buffering_stats(
        query: *mut GstQuery,
        mode: GstBufferingMode,
        avg_in: c_int,
        avg_out: c_int,
        buffering_left: i64,
    );
    pub fn gst_query_set_caps_result(query: *mut GstQuery, caps: *mut GstCaps);
    pub fn gst_query_set_context(query: *mut GstQuery, context: *mut GstContext);
    pub fn gst_query_set_convert(
        query: *mut GstQuery,
        src_format: GstFormat,
        src_value: i64,
        dest_format: GstFormat,
        dest_value: i64,
    );
    pub fn gst_query_set_duration(query: *mut GstQuery, format: GstFormat, duration: i64);
    pub fn gst_query_set_formats(query: *mut GstQuery, n_formats: c_int, ...);
    pub fn gst_query_set_formatsv(
        query: *mut GstQuery,
        n_formats: c_int,
        formats: *const GstFormat,
    );
    pub fn gst_query_set_latency(
        query: *mut GstQuery,
        live: gboolean,
        min_latency: GstClockTime,
        max_latency: GstClockTime,
    );
    pub fn gst_query_set_nth_allocation_param(
        query: *mut GstQuery,
        index: c_uint,
        allocator: *mut GstAllocator,
        params: *const GstAllocationParams,
    );
    pub fn gst_query_set_nth_allocation_pool(
        query: *mut GstQuery,
        index: c_uint,
        pool: *mut GstBufferPool,
        size: c_uint,
        min_buffers: c_uint,
        max_buffers: c_uint,
    );
    pub fn gst_query_set_position(query: *mut GstQuery, format: GstFormat, cur: i64);
    pub fn gst_query_set_scheduling(
        query: *mut GstQuery,
        flags: GstSchedulingFlags,
        minsize: c_int,
        maxsize: c_int,
        align: c_int,
    );
    pub fn gst_query_set_seeking(
        query: *mut GstQuery,
        format: GstFormat,
        seekable: gboolean,
        segment_start: i64,
        segment_end: i64,
    );
    pub fn gst_query_set_segment(
        query: *mut GstQuery,
        rate: c_double,
        format: GstFormat,
        start_value: i64,
        stop_value: i64,
    );
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    pub fn gst_query_set_selectable(query: *mut GstQuery, selectable: gboolean);
    pub fn gst_query_set_uri(query: *mut GstQuery, uri: *const c_char);
    pub fn gst_query_set_uri_redirection(query: *mut GstQuery, uri: *const c_char);
    pub fn gst_query_set_uri_redirection_permanent(query: *mut GstQuery, permanent: gboolean);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_query_unref(q: *mut GstQuery);
    pub fn gst_query_writable_structure(query: *mut GstQuery) -> *mut GstStructure;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_query_replace(old_query: *mut *mut GstQuery, new_query: *mut GstQuery) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_query_take(old_query: *mut *mut GstQuery, new_query: *mut GstQuery) -> gboolean;

    //=========================================================================
    // GstReferenceTimestampMeta
    //=========================================================================
    pub fn gst_reference_timestamp_meta_get_info() -> *const GstMetaInfo;

    //=========================================================================
    // GstSample
    //=========================================================================
    pub fn gst_sample_get_type() -> GType;
    pub fn gst_sample_new(
        buffer: *mut GstBuffer,
        caps: *mut GstCaps,
        segment: *const GstSegment,
        info: *mut GstStructure,
    ) -> *mut GstSample;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_sample_copy(buf: *const GstSample) -> *mut GstSample;
    pub fn gst_sample_get_buffer(sample: *mut GstSample) -> *mut GstBuffer;
    pub fn gst_sample_get_buffer_list(sample: *mut GstSample) -> *mut GstBufferList;
    pub fn gst_sample_get_caps(sample: *mut GstSample) -> *mut GstCaps;
    pub fn gst_sample_get_info(sample: *mut GstSample) -> *const GstStructure;
    pub fn gst_sample_get_segment(sample: *mut GstSample) -> *mut GstSegment;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_sample_ref(sample: *mut GstSample) -> *mut GstSample;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_sample_set_buffer(sample: *mut GstSample, buffer: *mut GstBuffer);
    pub fn gst_sample_set_buffer_list(sample: *mut GstSample, buffer_list: *mut GstBufferList);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_sample_set_caps(sample: *mut GstSample, caps: *mut GstCaps);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_sample_set_info(sample: *mut GstSample, info: *mut GstStructure) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_sample_set_segment(sample: *mut GstSample, segment: *const GstSegment);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_sample_unref(sample: *mut GstSample);

    //=========================================================================
    // GstSegment
    //=========================================================================
    pub fn gst_segment_get_type() -> GType;
    pub fn gst_segment_new() -> *mut GstSegment;
    pub fn gst_segment_clip(
        segment: *const GstSegment,
        format: GstFormat,
        start: u64,
        stop: u64,
        clip_start: *mut u64,
        clip_stop: *mut u64,
    ) -> gboolean;
    pub fn gst_segment_copy(segment: *const GstSegment) -> *mut GstSegment;
    pub fn gst_segment_copy_into(src: *const GstSegment, dest: *mut GstSegment);
    pub fn gst_segment_do_seek(
        segment: *mut GstSegment,
        rate: c_double,
        format: GstFormat,
        flags: GstSeekFlags,
        start_type: GstSeekType,
        start: u64,
        stop_type: GstSeekType,
        stop: u64,
        update: *mut gboolean,
    ) -> gboolean;
    pub fn gst_segment_free(segment: *mut GstSegment);
    pub fn gst_segment_init(segment: *mut GstSegment, format: GstFormat);
    pub fn gst_segment_is_equal(s0: *const GstSegment, s1: *const GstSegment) -> gboolean;
    pub fn gst_segment_offset_running_time(
        segment: *mut GstSegment,
        format: GstFormat,
        offset: i64,
    ) -> gboolean;
    pub fn gst_segment_position_from_running_time(
        segment: *const GstSegment,
        format: GstFormat,
        running_time: u64,
    ) -> u64;
    pub fn gst_segment_position_from_running_time_full(
        segment: *const GstSegment,
        format: GstFormat,
        running_time: u64,
        position: *mut u64,
    ) -> c_int;
    pub fn gst_segment_position_from_stream_time(
        segment: *const GstSegment,
        format: GstFormat,
        stream_time: u64,
    ) -> u64;
    pub fn gst_segment_position_from_stream_time_full(
        segment: *const GstSegment,
        format: GstFormat,
        stream_time: u64,
        position: *mut u64,
    ) -> c_int;
    pub fn gst_segment_set_running_time(
        segment: *mut GstSegment,
        format: GstFormat,
        running_time: u64,
    ) -> gboolean;
    pub fn gst_segment_to_position(
        segment: *const GstSegment,
        format: GstFormat,
        running_time: u64,
    ) -> u64;
    pub fn gst_segment_to_running_time(
        segment: *const GstSegment,
        format: GstFormat,
        position: u64,
    ) -> u64;
    pub fn gst_segment_to_running_time_full(
        segment: *const GstSegment,
        format: GstFormat,
        position: u64,
        running_time: *mut u64,
    ) -> c_int;
    pub fn gst_segment_to_stream_time(
        segment: *const GstSegment,
        format: GstFormat,
        position: u64,
    ) -> u64;
    pub fn gst_segment_to_stream_time_full(
        segment: *const GstSegment,
        format: GstFormat,
        position: u64,
        stream_time: *mut u64,
    ) -> c_int;

    //=========================================================================
    // GstStaticCaps
    //=========================================================================
    pub fn gst_static_caps_cleanup(static_caps: *mut GstStaticCaps);
    pub fn gst_static_caps_get(static_caps: *mut GstStaticCaps) -> *mut GstCaps;

    //=========================================================================
    // GstStaticPadTemplate
    //=========================================================================
    pub fn gst_static_pad_template_get(
        pad_template: *mut GstStaticPadTemplate,
    ) -> *mut GstPadTemplate;
    pub fn gst_static_pad_template_get_caps(templ: *mut GstStaticPadTemplate) -> *mut GstCaps;

    //=========================================================================
    // GstStructure
    //=========================================================================
    pub fn gst_structure_get_type() -> GType;
    pub fn gst_structure_from_string(
        string: *const c_char,
        end: *mut *mut c_char,
    ) -> *mut GstStructure;
    pub fn gst_structure_new(
        name: *const c_char,
        firstfield: *const c_char,
        ...
    ) -> *mut GstStructure;
    pub fn gst_structure_new_empty(name: *const c_char) -> *mut GstStructure;
    pub fn gst_structure_new_from_string(string: *const c_char) -> *mut GstStructure;
    pub fn gst_structure_new_id(
        name_quark: glib::GQuark,
        field_quark: glib::GQuark,
        ...
    ) -> *mut GstStructure;
    pub fn gst_structure_new_id_empty(quark: glib::GQuark) -> *mut GstStructure;
    //pub fn gst_structure_new_valist(name: *const c_char, firstfield: *const c_char, varargs: /*Unimplemented*/va_list) -> *mut GstStructure;
    pub fn gst_structure_can_intersect(
        struct1: *const GstStructure,
        struct2: *const GstStructure,
    ) -> gboolean;
    pub fn gst_structure_copy(structure: *const GstStructure) -> *mut GstStructure;
    pub fn gst_structure_filter_and_map_in_place(
        structure: *mut GstStructure,
        func: GstStructureFilterMapFunc,
        user_data: gpointer,
    );
    pub fn gst_structure_fixate(structure: *mut GstStructure);
    pub fn gst_structure_fixate_field(
        structure: *mut GstStructure,
        field_name: *const c_char,
    ) -> gboolean;
    pub fn gst_structure_fixate_field_boolean(
        structure: *mut GstStructure,
        field_name: *const c_char,
        target: gboolean,
    ) -> gboolean;
    pub fn gst_structure_fixate_field_nearest_double(
        structure: *mut GstStructure,
        field_name: *const c_char,
        target: c_double,
    ) -> gboolean;
    pub fn gst_structure_fixate_field_nearest_fraction(
        structure: *mut GstStructure,
        field_name: *const c_char,
        target_numerator: c_int,
        target_denominator: c_int,
    ) -> gboolean;
    pub fn gst_structure_fixate_field_nearest_int(
        structure: *mut GstStructure,
        field_name: *const c_char,
        target: c_int,
    ) -> gboolean;
    pub fn gst_structure_fixate_field_string(
        structure: *mut GstStructure,
        field_name: *const c_char,
        target: *const c_char,
    ) -> gboolean;
    pub fn gst_structure_foreach(
        structure: *const GstStructure,
        func: GstStructureForeachFunc,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_structure_free(structure: *mut GstStructure);
    pub fn gst_structure_get(
        structure: *const GstStructure,
        first_fieldname: *const c_char,
        ...
    ) -> gboolean;
    pub fn gst_structure_get_array(
        structure: *mut GstStructure,
        fieldname: *const c_char,
        array: *mut *mut gobject::GValueArray,
    ) -> gboolean;
    pub fn gst_structure_get_boolean(
        structure: *const GstStructure,
        fieldname: *const c_char,
        value: *mut gboolean,
    ) -> gboolean;
    pub fn gst_structure_get_clock_time(
        structure: *const GstStructure,
        fieldname: *const c_char,
        value: *mut GstClockTime,
    ) -> gboolean;
    pub fn gst_structure_get_date(
        structure: *const GstStructure,
        fieldname: *const c_char,
        value: *mut *mut glib::GDate,
    ) -> gboolean;
    pub fn gst_structure_get_date_time(
        structure: *const GstStructure,
        fieldname: *const c_char,
        value: *mut *mut GstDateTime,
    ) -> gboolean;
    pub fn gst_structure_get_double(
        structure: *const GstStructure,
        fieldname: *const c_char,
        value: *mut c_double,
    ) -> gboolean;
    pub fn gst_structure_get_enum(
        structure: *const GstStructure,
        fieldname: *const c_char,
        enumtype: GType,
        value: *mut c_int,
    ) -> gboolean;
    pub fn gst_structure_get_field_type(
        structure: *const GstStructure,
        fieldname: *const c_char,
    ) -> GType;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    pub fn gst_structure_get_flags(
        structure: *const GstStructure,
        fieldname: *const c_char,
        flags_type: GType,
        value: *mut c_uint,
    ) -> gboolean;
    pub fn gst_structure_get_flagset(
        structure: *const GstStructure,
        fieldname: *const c_char,
        value_flags: *mut c_uint,
        value_mask: *mut c_uint,
    ) -> gboolean;
    pub fn gst_structure_get_fraction(
        structure: *const GstStructure,
        fieldname: *const c_char,
        value_numerator: *mut c_int,
        value_denominator: *mut c_int,
    ) -> gboolean;
    pub fn gst_structure_get_int(
        structure: *const GstStructure,
        fieldname: *const c_char,
        value: *mut c_int,
    ) -> gboolean;
    pub fn gst_structure_get_int64(
        structure: *const GstStructure,
        fieldname: *const c_char,
        value: *mut i64,
    ) -> gboolean;
    pub fn gst_structure_get_list(
        structure: *mut GstStructure,
        fieldname: *const c_char,
        array: *mut *mut gobject::GValueArray,
    ) -> gboolean;
    pub fn gst_structure_get_name(structure: *const GstStructure) -> *const c_char;
    pub fn gst_structure_get_name_id(structure: *const GstStructure) -> glib::GQuark;
    pub fn gst_structure_get_string(
        structure: *const GstStructure,
        fieldname: *const c_char,
    ) -> *const c_char;
    pub fn gst_structure_get_uint(
        structure: *const GstStructure,
        fieldname: *const c_char,
        value: *mut c_uint,
    ) -> gboolean;
    pub fn gst_structure_get_uint64(
        structure: *const GstStructure,
        fieldname: *const c_char,
        value: *mut u64,
    ) -> gboolean;
    //pub fn gst_structure_get_valist(structure: *const GstStructure, first_fieldname: *const c_char, args: /*Unimplemented*/va_list) -> gboolean;
    pub fn gst_structure_get_value(
        structure: *const GstStructure,
        fieldname: *const c_char,
    ) -> *const gobject::GValue;
    pub fn gst_structure_has_field(
        structure: *const GstStructure,
        fieldname: *const c_char,
    ) -> gboolean;
    pub fn gst_structure_has_field_typed(
        structure: *const GstStructure,
        fieldname: *const c_char,
        type_: GType,
    ) -> gboolean;
    pub fn gst_structure_has_name(structure: *const GstStructure, name: *const c_char) -> gboolean;
    pub fn gst_structure_id_get(
        structure: *const GstStructure,
        first_field_id: glib::GQuark,
        ...
    ) -> gboolean;
    //pub fn gst_structure_id_get_valist(structure: *const GstStructure, first_field_id: glib::GQuark, args: /*Unimplemented*/va_list) -> gboolean;
    pub fn gst_structure_id_get_value(
        structure: *const GstStructure,
        field: glib::GQuark,
    ) -> *const gobject::GValue;
    pub fn gst_structure_id_has_field(
        structure: *const GstStructure,
        field: glib::GQuark,
    ) -> gboolean;
    pub fn gst_structure_id_has_field_typed(
        structure: *const GstStructure,
        field: glib::GQuark,
        type_: GType,
    ) -> gboolean;
    pub fn gst_structure_id_set(structure: *mut GstStructure, fieldname: glib::GQuark, ...);
    //pub fn gst_structure_id_set_valist(structure: *mut GstStructure, fieldname: glib::GQuark, varargs: /*Unimplemented*/va_list);
    pub fn gst_structure_id_set_value(
        structure: *mut GstStructure,
        field: glib::GQuark,
        value: *const gobject::GValue,
    );
    pub fn gst_structure_id_take_value(
        structure: *mut GstStructure,
        field: glib::GQuark,
        value: *mut gobject::GValue,
    );
    pub fn gst_structure_intersect(
        struct1: *const GstStructure,
        struct2: *const GstStructure,
    ) -> *mut GstStructure;
    pub fn gst_structure_is_equal(
        structure1: *const GstStructure,
        structure2: *const GstStructure,
    ) -> gboolean;
    pub fn gst_structure_is_subset(
        subset: *const GstStructure,
        superset: *const GstStructure,
    ) -> gboolean;
    pub fn gst_structure_map_in_place(
        structure: *mut GstStructure,
        func: GstStructureMapFunc,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_structure_n_fields(structure: *const GstStructure) -> c_int;
    pub fn gst_structure_nth_field_name(
        structure: *const GstStructure,
        index: c_uint,
    ) -> *const c_char;
    pub fn gst_structure_remove_all_fields(structure: *mut GstStructure);
    pub fn gst_structure_remove_field(structure: *mut GstStructure, fieldname: *const c_char);
    pub fn gst_structure_remove_fields(structure: *mut GstStructure, fieldname: *const c_char, ...);
    //pub fn gst_structure_remove_fields_valist(structure: *mut GstStructure, fieldname: *const c_char, varargs: /*Unimplemented*/va_list);
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_structure_serialize(
        structure: *const GstStructure,
        flags: GstSerializeFlags,
    ) -> *mut c_char;
    pub fn gst_structure_set(structure: *mut GstStructure, fieldname: *const c_char, ...);
    pub fn gst_structure_set_array(
        structure: *mut GstStructure,
        fieldname: *const c_char,
        array: *const gobject::GValueArray,
    );
    pub fn gst_structure_set_list(
        structure: *mut GstStructure,
        fieldname: *const c_char,
        array: *const gobject::GValueArray,
    );
    pub fn gst_structure_set_name(structure: *mut GstStructure, name: *const c_char);
    pub fn gst_structure_set_parent_refcount(
        structure: *mut GstStructure,
        refcount: *mut c_int,
    ) -> gboolean;
    //pub fn gst_structure_set_valist(structure: *mut GstStructure, fieldname: *const c_char, varargs: /*Unimplemented*/va_list);
    pub fn gst_structure_set_value(
        structure: *mut GstStructure,
        fieldname: *const c_char,
        value: *const gobject::GValue,
    );
    pub fn gst_structure_take_value(
        structure: *mut GstStructure,
        fieldname: *const c_char,
        value: *mut gobject::GValue,
    );
    pub fn gst_structure_to_string(structure: *const GstStructure) -> *mut c_char;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_structure_take(
        oldstr_ptr: *mut *mut GstStructure,
        newstr: *mut GstStructure,
    ) -> gboolean;

    //=========================================================================
    // GstTagList
    //=========================================================================
    pub fn gst_tag_list_get_type() -> GType;
    pub fn gst_tag_list_new(tag: *const c_char, ...) -> *mut GstTagList;
    pub fn gst_tag_list_new_empty() -> *mut GstTagList;
    pub fn gst_tag_list_new_from_string(str: *const c_char) -> *mut GstTagList;
    //pub fn gst_tag_list_new_valist(var_args: /*Unimplemented*/va_list) -> *mut GstTagList;
    pub fn gst_tag_list_add(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, ...);
    //pub fn gst_tag_list_add_valist(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    //pub fn gst_tag_list_add_valist_values(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn gst_tag_list_add_value(
        list: *mut GstTagList,
        mode: GstTagMergeMode,
        tag: *const c_char,
        value: *const gobject::GValue,
    );
    pub fn gst_tag_list_add_values(
        list: *mut GstTagList,
        mode: GstTagMergeMode,
        tag: *const c_char,
        ...
    );
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_tag_list_copy(taglist: *const GstTagList) -> *mut GstTagList;
    pub fn gst_tag_list_foreach(
        list: *const GstTagList,
        func: GstTagForeachFunc,
        user_data: gpointer,
    );
    pub fn gst_tag_list_get_boolean(
        list: *const GstTagList,
        tag: *const c_char,
        value: *mut gboolean,
    ) -> gboolean;
    pub fn gst_tag_list_get_boolean_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut gboolean,
    ) -> gboolean;
    pub fn gst_tag_list_get_date(
        list: *const GstTagList,
        tag: *const c_char,
        value: *mut *mut glib::GDate,
    ) -> gboolean;
    pub fn gst_tag_list_get_date_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut *mut glib::GDate,
    ) -> gboolean;
    pub fn gst_tag_list_get_date_time(
        list: *const GstTagList,
        tag: *const c_char,
        value: *mut *mut GstDateTime,
    ) -> gboolean;
    pub fn gst_tag_list_get_date_time_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut *mut GstDateTime,
    ) -> gboolean;
    pub fn gst_tag_list_get_double(
        list: *const GstTagList,
        tag: *const c_char,
        value: *mut c_double,
    ) -> gboolean;
    pub fn gst_tag_list_get_double_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut c_double,
    ) -> gboolean;
    pub fn gst_tag_list_get_float(
        list: *const GstTagList,
        tag: *const c_char,
        value: *mut c_float,
    ) -> gboolean;
    pub fn gst_tag_list_get_float_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut c_float,
    ) -> gboolean;
    pub fn gst_tag_list_get_int(
        list: *const GstTagList,
        tag: *const c_char,
        value: *mut c_int,
    ) -> gboolean;
    pub fn gst_tag_list_get_int64(
        list: *const GstTagList,
        tag: *const c_char,
        value: *mut i64,
    ) -> gboolean;
    pub fn gst_tag_list_get_int64_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut i64,
    ) -> gboolean;
    pub fn gst_tag_list_get_int_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut c_int,
    ) -> gboolean;
    pub fn gst_tag_list_get_pointer(
        list: *const GstTagList,
        tag: *const c_char,
        value: *mut gpointer,
    ) -> gboolean;
    pub fn gst_tag_list_get_pointer_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut gpointer,
    ) -> gboolean;
    pub fn gst_tag_list_get_sample(
        list: *const GstTagList,
        tag: *const c_char,
        sample: *mut *mut GstSample,
    ) -> gboolean;
    pub fn gst_tag_list_get_sample_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        sample: *mut *mut GstSample,
    ) -> gboolean;
    pub fn gst_tag_list_get_scope(list: *const GstTagList) -> GstTagScope;
    pub fn gst_tag_list_get_string(
        list: *const GstTagList,
        tag: *const c_char,
        value: *mut *mut c_char,
    ) -> gboolean;
    pub fn gst_tag_list_get_string_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut *mut c_char,
    ) -> gboolean;
    pub fn gst_tag_list_get_tag_size(list: *const GstTagList, tag: *const c_char) -> c_uint;
    pub fn gst_tag_list_get_uint(
        list: *const GstTagList,
        tag: *const c_char,
        value: *mut c_uint,
    ) -> gboolean;
    pub fn gst_tag_list_get_uint64(
        list: *const GstTagList,
        tag: *const c_char,
        value: *mut u64,
    ) -> gboolean;
    pub fn gst_tag_list_get_uint64_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut u64,
    ) -> gboolean;
    pub fn gst_tag_list_get_uint_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut c_uint,
    ) -> gboolean;
    pub fn gst_tag_list_get_value_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
    ) -> *const gobject::GValue;
    pub fn gst_tag_list_insert(
        into: *mut GstTagList,
        from: *const GstTagList,
        mode: GstTagMergeMode,
    );
    pub fn gst_tag_list_is_empty(list: *const GstTagList) -> gboolean;
    pub fn gst_tag_list_is_equal(list1: *const GstTagList, list2: *const GstTagList) -> gboolean;
    pub fn gst_tag_list_merge(
        list1: *const GstTagList,
        list2: *const GstTagList,
        mode: GstTagMergeMode,
    ) -> *mut GstTagList;
    pub fn gst_tag_list_n_tags(list: *const GstTagList) -> c_int;
    pub fn gst_tag_list_nth_tag_name(list: *const GstTagList, index: c_uint) -> *const c_char;
    pub fn gst_tag_list_peek_string_index(
        list: *const GstTagList,
        tag: *const c_char,
        index: c_uint,
        value: *mut *const c_char,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_tag_list_ref(taglist: *mut GstTagList) -> *mut GstTagList;
    pub fn gst_tag_list_remove_tag(list: *mut GstTagList, tag: *const c_char);
    pub fn gst_tag_list_set_scope(list: *mut GstTagList, scope: GstTagScope);
    pub fn gst_tag_list_to_string(list: *const GstTagList) -> *mut c_char;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_tag_list_unref(taglist: *mut GstTagList);
    pub fn gst_tag_list_copy_value(
        dest: *mut gobject::GValue,
        list: *const GstTagList,
        tag: *const c_char,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_tag_list_replace(
        old_taglist: *mut *mut GstTagList,
        new_taglist: *mut GstTagList,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_tag_list_take(
        old_taglist: *mut *mut GstTagList,
        new_taglist: *mut GstTagList,
    ) -> gboolean;

    //=========================================================================
    // GstToc
    //=========================================================================
    pub fn gst_toc_get_type() -> GType;
    pub fn gst_toc_new(scope: GstTocScope) -> *mut GstToc;
    pub fn gst_toc_append_entry(toc: *mut GstToc, entry: *mut GstTocEntry);
    pub fn gst_toc_dump(toc: *mut GstToc);
    pub fn gst_toc_find_entry(toc: *const GstToc, uid: *const c_char) -> *mut GstTocEntry;
    pub fn gst_toc_get_entries(toc: *const GstToc) -> *mut glib::GList;
    pub fn gst_toc_get_scope(toc: *const GstToc) -> GstTocScope;
    pub fn gst_toc_get_tags(toc: *const GstToc) -> *mut GstTagList;
    pub fn gst_toc_merge_tags(toc: *mut GstToc, tags: *mut GstTagList, mode: GstTagMergeMode);
    pub fn gst_toc_set_tags(toc: *mut GstToc, tags: *mut GstTagList);

    //=========================================================================
    // GstTocEntry
    //=========================================================================
    pub fn gst_toc_entry_get_type() -> GType;
    pub fn gst_toc_entry_new(type_: GstTocEntryType, uid: *const c_char) -> *mut GstTocEntry;
    pub fn gst_toc_entry_append_sub_entry(entry: *mut GstTocEntry, subentry: *mut GstTocEntry);
    pub fn gst_toc_entry_get_entry_type(entry: *const GstTocEntry) -> GstTocEntryType;
    pub fn gst_toc_entry_get_loop(
        entry: *const GstTocEntry,
        loop_type: *mut GstTocLoopType,
        repeat_count: *mut c_int,
    ) -> gboolean;
    pub fn gst_toc_entry_get_parent(entry: *mut GstTocEntry) -> *mut GstTocEntry;
    pub fn gst_toc_entry_get_start_stop_times(
        entry: *const GstTocEntry,
        start: *mut i64,
        stop: *mut i64,
    ) -> gboolean;
    pub fn gst_toc_entry_get_sub_entries(entry: *const GstTocEntry) -> *mut glib::GList;
    pub fn gst_toc_entry_get_tags(entry: *const GstTocEntry) -> *mut GstTagList;
    pub fn gst_toc_entry_get_toc(entry: *mut GstTocEntry) -> *mut GstToc;
    pub fn gst_toc_entry_get_uid(entry: *const GstTocEntry) -> *const c_char;
    pub fn gst_toc_entry_is_alternative(entry: *const GstTocEntry) -> gboolean;
    pub fn gst_toc_entry_is_sequence(entry: *const GstTocEntry) -> gboolean;
    pub fn gst_toc_entry_merge_tags(
        entry: *mut GstTocEntry,
        tags: *mut GstTagList,
        mode: GstTagMergeMode,
    );
    pub fn gst_toc_entry_set_loop(
        entry: *mut GstTocEntry,
        loop_type: GstTocLoopType,
        repeat_count: c_int,
    );
    pub fn gst_toc_entry_set_start_stop_times(entry: *mut GstTocEntry, start: i64, stop: i64);
    pub fn gst_toc_entry_set_tags(entry: *mut GstTocEntry, tags: *mut GstTagList);

    //=========================================================================
    // GstTypeFind
    //=========================================================================
    pub fn gst_type_find_get_length(find: *mut GstTypeFind) -> u64;
    pub fn gst_type_find_peek(find: *mut GstTypeFind, offset: i64, size: c_uint) -> *const u8;
    pub fn gst_type_find_suggest(find: *mut GstTypeFind, probability: c_uint, caps: *mut GstCaps);
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_type_find_suggest_empty_simple(
        find: *mut GstTypeFind,
        probability: c_uint,
        media_type: *const c_char,
    );
    pub fn gst_type_find_suggest_simple(
        find: *mut GstTypeFind,
        probability: c_uint,
        media_type: *const c_char,
        fieldname: *const c_char,
        ...
    );
    pub fn gst_type_find_register(
        plugin: *mut GstPlugin,
        name: *const c_char,
        rank: c_uint,
        func: GstTypeFindFunction,
        extensions: *const c_char,
        possible_caps: *mut GstCaps,
        data: gpointer,
        data_notify: glib::GDestroyNotify,
    ) -> gboolean;

    //=========================================================================
    // GstUri
    //=========================================================================
    pub fn gst_uri_get_type() -> GType;
    pub fn gst_uri_new(
        scheme: *const c_char,
        userinfo: *const c_char,
        host: *const c_char,
        port: c_uint,
        path: *const c_char,
        query: *const c_char,
        fragment: *const c_char,
    ) -> *mut GstUri;
    pub fn gst_uri_append_path(uri: *mut GstUri, relative_path: *const c_char) -> gboolean;
    pub fn gst_uri_append_path_segment(uri: *mut GstUri, path_segment: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_uri_copy(uri: *const GstUri) -> *mut GstUri;
    pub fn gst_uri_equal(first: *const GstUri, second: *const GstUri) -> gboolean;
    pub fn gst_uri_from_string_with_base(base: *mut GstUri, uri: *const c_char) -> *mut GstUri;
    pub fn gst_uri_get_fragment(uri: *const GstUri) -> *const c_char;
    pub fn gst_uri_get_host(uri: *const GstUri) -> *const c_char;
    pub fn gst_uri_get_media_fragment_table(uri: *const GstUri) -> *mut glib::GHashTable;
    pub fn gst_uri_get_path(uri: *const GstUri) -> *mut c_char;
    pub fn gst_uri_get_path_segments(uri: *const GstUri) -> *mut glib::GList;
    pub fn gst_uri_get_path_string(uri: *const GstUri) -> *mut c_char;
    pub fn gst_uri_get_port(uri: *const GstUri) -> c_uint;
    pub fn gst_uri_get_query_keys(uri: *const GstUri) -> *mut glib::GList;
    pub fn gst_uri_get_query_string(uri: *const GstUri) -> *mut c_char;
    pub fn gst_uri_get_query_table(uri: *const GstUri) -> *mut glib::GHashTable;
    pub fn gst_uri_get_query_value(uri: *const GstUri, query_key: *const c_char) -> *const c_char;
    pub fn gst_uri_get_scheme(uri: *const GstUri) -> *const c_char;
    pub fn gst_uri_get_userinfo(uri: *const GstUri) -> *const c_char;
    pub fn gst_uri_is_normalized(uri: *const GstUri) -> gboolean;
    pub fn gst_uri_is_writable(uri: *const GstUri) -> gboolean;
    pub fn gst_uri_join(base_uri: *mut GstUri, ref_uri: *mut GstUri) -> *mut GstUri;
    pub fn gst_uri_make_writable(uri: *mut GstUri) -> *mut GstUri;
    pub fn gst_uri_new_with_base(
        base: *mut GstUri,
        scheme: *const c_char,
        userinfo: *const c_char,
        host: *const c_char,
        port: c_uint,
        path: *const c_char,
        query: *const c_char,
        fragment: *const c_char,
    ) -> *mut GstUri;
    pub fn gst_uri_normalize(uri: *mut GstUri) -> gboolean;
    pub fn gst_uri_query_has_key(uri: *const GstUri, query_key: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_uri_ref(uri: *mut GstUri) -> *mut GstUri;
    pub fn gst_uri_remove_query_key(uri: *mut GstUri, query_key: *const c_char) -> gboolean;
    pub fn gst_uri_set_fragment(uri: *mut GstUri, fragment: *const c_char) -> gboolean;
    pub fn gst_uri_set_host(uri: *mut GstUri, host: *const c_char) -> gboolean;
    pub fn gst_uri_set_path(uri: *mut GstUri, path: *const c_char) -> gboolean;
    pub fn gst_uri_set_path_segments(uri: *mut GstUri, path_segments: *mut glib::GList)
        -> gboolean;
    pub fn gst_uri_set_path_string(uri: *mut GstUri, path: *const c_char) -> gboolean;
    pub fn gst_uri_set_port(uri: *mut GstUri, port: c_uint) -> gboolean;
    pub fn gst_uri_set_query_string(uri: *mut GstUri, query: *const c_char) -> gboolean;
    pub fn gst_uri_set_query_table(
        uri: *mut GstUri,
        query_table: *mut glib::GHashTable,
    ) -> gboolean;
    pub fn gst_uri_set_query_value(
        uri: *mut GstUri,
        query_key: *const c_char,
        query_value: *const c_char,
    ) -> gboolean;
    pub fn gst_uri_set_scheme(uri: *mut GstUri, scheme: *const c_char) -> gboolean;
    pub fn gst_uri_set_userinfo(uri: *mut GstUri, userinfo: *const c_char) -> gboolean;
    pub fn gst_uri_to_string(uri: *const GstUri) -> *mut c_char;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_uri_unref(uri: *mut GstUri);
    pub fn gst_uri_construct(protocol: *const c_char, location: *const c_char) -> *mut c_char;
    pub fn gst_uri_from_string(uri: *const c_char) -> *mut GstUri;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_uri_from_string_escaped(uri: *const c_char) -> *mut GstUri;
    pub fn gst_uri_get_location(uri: *const c_char) -> *mut c_char;
    pub fn gst_uri_get_protocol(uri: *const c_char) -> *mut c_char;
    pub fn gst_uri_has_protocol(uri: *const c_char, protocol: *const c_char) -> gboolean;
    pub fn gst_uri_is_valid(uri: *const c_char) -> gboolean;
    pub fn gst_uri_join_strings(base_uri: *const c_char, ref_uri: *const c_char) -> *mut c_char;
    pub fn gst_uri_protocol_is_supported(type_: GstURIType, protocol: *const c_char) -> gboolean;
    pub fn gst_uri_protocol_is_valid(protocol: *const c_char) -> gboolean;

    //=========================================================================
    // GstAllocator
    //=========================================================================
    pub fn gst_allocator_get_type() -> GType;
    pub fn gst_allocator_find(name: *const c_char) -> *mut GstAllocator;
    pub fn gst_allocator_register(name: *const c_char, allocator: *mut GstAllocator);
    pub fn gst_allocator_alloc(
        allocator: *mut GstAllocator,
        size: size_t,
        params: *mut GstAllocationParams,
    ) -> *mut GstMemory;
    pub fn gst_allocator_free(allocator: *mut GstAllocator, memory: *mut GstMemory);
    pub fn gst_allocator_set_default(allocator: *mut GstAllocator);

    //=========================================================================
    // GstBin
    //=========================================================================
    pub fn gst_bin_get_type() -> GType;
    pub fn gst_bin_new(name: *const c_char) -> *mut GstElement;
    pub fn gst_bin_add(bin: *mut GstBin, element: *mut GstElement) -> gboolean;
    pub fn gst_bin_add_many(bin: *mut GstBin, element_1: *mut GstElement, ...);
    pub fn gst_bin_find_unlinked_pad(bin: *mut GstBin, direction: GstPadDirection) -> *mut GstPad;
    pub fn gst_bin_get_by_interface(bin: *mut GstBin, iface: GType) -> *mut GstElement;
    pub fn gst_bin_get_by_name(bin: *mut GstBin, name: *const c_char) -> *mut GstElement;
    pub fn gst_bin_get_by_name_recurse_up(bin: *mut GstBin, name: *const c_char)
        -> *mut GstElement;
    pub fn gst_bin_get_suppressed_flags(bin: *mut GstBin) -> GstElementFlags;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_bin_iterate_all_by_element_factory_name(
        bin: *mut GstBin,
        factory_name: *const c_char,
    ) -> *mut GstIterator;
    pub fn gst_bin_iterate_all_by_interface(bin: *mut GstBin, iface: GType) -> *mut GstIterator;
    pub fn gst_bin_iterate_elements(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_recurse(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sinks(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sorted(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sources(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_recalculate_latency(bin: *mut GstBin) -> gboolean;
    pub fn gst_bin_remove(bin: *mut GstBin, element: *mut GstElement) -> gboolean;
    pub fn gst_bin_remove_many(bin: *mut GstBin, element_1: *mut GstElement, ...);
    pub fn gst_bin_set_suppressed_flags(bin: *mut GstBin, flags: GstElementFlags);
    pub fn gst_bin_sync_children_states(bin: *mut GstBin) -> gboolean;

    //=========================================================================
    // GstBitmask
    //=========================================================================
    pub fn gst_bitmask_get_type() -> GType;

    //=========================================================================
    // GstBufferPool
    //=========================================================================
    pub fn gst_buffer_pool_get_type() -> GType;
    pub fn gst_buffer_pool_new() -> *mut GstBufferPool;
    pub fn gst_buffer_pool_config_add_option(config: *mut GstStructure, option: *const c_char);
    pub fn gst_buffer_pool_config_get_allocator(
        config: *mut GstStructure,
        allocator: *mut *mut GstAllocator,
        params: *mut GstAllocationParams,
    ) -> gboolean;
    pub fn gst_buffer_pool_config_get_option(
        config: *mut GstStructure,
        index: c_uint,
    ) -> *const c_char;
    pub fn gst_buffer_pool_config_get_params(
        config: *mut GstStructure,
        caps: *mut *mut GstCaps,
        size: *mut c_uint,
        min_buffers: *mut c_uint,
        max_buffers: *mut c_uint,
    ) -> gboolean;
    pub fn gst_buffer_pool_config_has_option(
        config: *mut GstStructure,
        option: *const c_char,
    ) -> gboolean;
    pub fn gst_buffer_pool_config_n_options(config: *mut GstStructure) -> c_uint;
    pub fn gst_buffer_pool_config_set_allocator(
        config: *mut GstStructure,
        allocator: *mut GstAllocator,
        params: *const GstAllocationParams,
    );
    pub fn gst_buffer_pool_config_set_params(
        config: *mut GstStructure,
        caps: *mut GstCaps,
        size: c_uint,
        min_buffers: c_uint,
        max_buffers: c_uint,
    );
    pub fn gst_buffer_pool_config_validate_params(
        config: *mut GstStructure,
        caps: *mut GstCaps,
        size: c_uint,
        min_buffers: c_uint,
        max_buffers: c_uint,
    ) -> gboolean;
    pub fn gst_buffer_pool_acquire_buffer(
        pool: *mut GstBufferPool,
        buffer: *mut *mut GstBuffer,
        params: *mut GstBufferPoolAcquireParams,
    ) -> GstFlowReturn;
    pub fn gst_buffer_pool_get_config(pool: *mut GstBufferPool) -> *mut GstStructure;
    pub fn gst_buffer_pool_get_options(pool: *mut GstBufferPool) -> *mut *const c_char;
    pub fn gst_buffer_pool_has_option(pool: *mut GstBufferPool, option: *const c_char) -> gboolean;
    pub fn gst_buffer_pool_is_active(pool: *mut GstBufferPool) -> gboolean;
    pub fn gst_buffer_pool_release_buffer(pool: *mut GstBufferPool, buffer: *mut GstBuffer);
    pub fn gst_buffer_pool_set_active(pool: *mut GstBufferPool, active: gboolean) -> gboolean;
    pub fn gst_buffer_pool_set_config(
        pool: *mut GstBufferPool,
        config: *mut GstStructure,
    ) -> gboolean;
    pub fn gst_buffer_pool_set_flushing(pool: *mut GstBufferPool, flushing: gboolean);

    //=========================================================================
    // GstBus
    //=========================================================================
    pub fn gst_bus_get_type() -> GType;
    pub fn gst_bus_new() -> *mut GstBus;
    pub fn gst_bus_add_signal_watch(bus: *mut GstBus);
    pub fn gst_bus_add_signal_watch_full(bus: *mut GstBus, priority: c_int);
    pub fn gst_bus_add_watch(bus: *mut GstBus, func: GstBusFunc, user_data: gpointer) -> c_uint;
    pub fn gst_bus_add_watch_full(
        bus: *mut GstBus,
        priority: c_int,
        func: GstBusFunc,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    ) -> c_uint;
    pub fn gst_bus_async_signal_func(
        bus: *mut GstBus,
        message: *mut GstMessage,
        data: gpointer,
    ) -> gboolean;
    pub fn gst_bus_create_watch(bus: *mut GstBus) -> *mut glib::GSource;
    pub fn gst_bus_disable_sync_message_emission(bus: *mut GstBus);
    pub fn gst_bus_enable_sync_message_emission(bus: *mut GstBus);
    pub fn gst_bus_get_pollfd(bus: *mut GstBus, fd: *mut glib::GPollFD);
    pub fn gst_bus_have_pending(bus: *mut GstBus) -> gboolean;
    pub fn gst_bus_peek(bus: *mut GstBus) -> *mut GstMessage;
    pub fn gst_bus_poll(
        bus: *mut GstBus,
        events: GstMessageType,
        timeout: GstClockTime,
    ) -> *mut GstMessage;
    pub fn gst_bus_pop(bus: *mut GstBus) -> *mut GstMessage;
    pub fn gst_bus_pop_filtered(bus: *mut GstBus, types: GstMessageType) -> *mut GstMessage;
    pub fn gst_bus_post(bus: *mut GstBus, message: *mut GstMessage) -> gboolean;
    pub fn gst_bus_remove_signal_watch(bus: *mut GstBus);
    pub fn gst_bus_remove_watch(bus: *mut GstBus) -> gboolean;
    pub fn gst_bus_set_flushing(bus: *mut GstBus, flushing: gboolean);
    pub fn gst_bus_set_sync_handler(
        bus: *mut GstBus,
        func: GstBusSyncHandler,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_bus_sync_signal_handler(
        bus: *mut GstBus,
        message: *mut GstMessage,
        data: gpointer,
    ) -> GstBusSyncReply;
    pub fn gst_bus_timed_pop(bus: *mut GstBus, timeout: GstClockTime) -> *mut GstMessage;
    pub fn gst_bus_timed_pop_filtered(
        bus: *mut GstBus,
        timeout: GstClockTime,
        types: GstMessageType,
    ) -> *mut GstMessage;

    //=========================================================================
    // GstClock
    //=========================================================================
    pub fn gst_clock_get_type() -> GType;
    pub fn gst_clock_id_compare_func(id1: gconstpointer, id2: gconstpointer) -> c_int;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_clock_id_get_clock(id: GstClockID) -> *mut GstClock;
    pub fn gst_clock_id_get_time(id: GstClockID) -> GstClockTime;
    pub fn gst_clock_id_ref(id: GstClockID) -> GstClockID;
    pub fn gst_clock_id_unref(id: GstClockID);
    pub fn gst_clock_id_unschedule(id: GstClockID);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_clock_id_uses_clock(id: GstClockID, clock: *mut GstClock) -> gboolean;
    pub fn gst_clock_id_wait(id: GstClockID, jitter: *mut GstClockTimeDiff) -> GstClockReturn;
    pub fn gst_clock_id_wait_async(
        id: GstClockID,
        func: GstClockCallback,
        user_data: gpointer,
        destroy_data: glib::GDestroyNotify,
    ) -> GstClockReturn;
    pub fn gst_clock_add_observation(
        clock: *mut GstClock,
        slave: GstClockTime,
        master: GstClockTime,
        r_squared: *mut c_double,
    ) -> gboolean;
    pub fn gst_clock_add_observation_unapplied(
        clock: *mut GstClock,
        slave: GstClockTime,
        master: GstClockTime,
        r_squared: *mut c_double,
        internal: *mut GstClockTime,
        external: *mut GstClockTime,
        rate_num: *mut GstClockTime,
        rate_denom: *mut GstClockTime,
    ) -> gboolean;
    pub fn gst_clock_adjust_unlocked(clock: *mut GstClock, internal: GstClockTime) -> GstClockTime;
    pub fn gst_clock_adjust_with_calibration(
        clock: *mut GstClock,
        internal_target: GstClockTime,
        cinternal: GstClockTime,
        cexternal: GstClockTime,
        cnum: GstClockTime,
        cdenom: GstClockTime,
    ) -> GstClockTime;
    pub fn gst_clock_get_calibration(
        clock: *mut GstClock,
        internal: *mut GstClockTime,
        external: *mut GstClockTime,
        rate_num: *mut GstClockTime,
        rate_denom: *mut GstClockTime,
    );
    pub fn gst_clock_get_internal_time(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_get_master(clock: *mut GstClock) -> *mut GstClock;
    pub fn gst_clock_get_resolution(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_get_time(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_get_timeout(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_is_synced(clock: *mut GstClock) -> gboolean;
    pub fn gst_clock_new_periodic_id(
        clock: *mut GstClock,
        start_time: GstClockTime,
        interval: GstClockTime,
    ) -> GstClockID;
    pub fn gst_clock_new_single_shot_id(clock: *mut GstClock, time: GstClockTime) -> GstClockID;
    pub fn gst_clock_periodic_id_reinit(
        clock: *mut GstClock,
        id: GstClockID,
        start_time: GstClockTime,
        interval: GstClockTime,
    ) -> gboolean;
    pub fn gst_clock_set_calibration(
        clock: *mut GstClock,
        internal: GstClockTime,
        external: GstClockTime,
        rate_num: GstClockTime,
        rate_denom: GstClockTime,
    );
    pub fn gst_clock_set_master(clock: *mut GstClock, master: *mut GstClock) -> gboolean;
    pub fn gst_clock_set_resolution(clock: *mut GstClock, resolution: GstClockTime)
        -> GstClockTime;
    pub fn gst_clock_set_synced(clock: *mut GstClock, synced: gboolean);
    pub fn gst_clock_set_timeout(clock: *mut GstClock, timeout: GstClockTime);
    pub fn gst_clock_single_shot_id_reinit(
        clock: *mut GstClock,
        id: GstClockID,
        time: GstClockTime,
    ) -> gboolean;
    pub fn gst_clock_unadjust_unlocked(
        clock: *mut GstClock,
        external: GstClockTime,
    ) -> GstClockTime;
    pub fn gst_clock_unadjust_with_calibration(
        clock: *mut GstClock,
        external_target: GstClockTime,
        cinternal: GstClockTime,
        cexternal: GstClockTime,
        cnum: GstClockTime,
        cdenom: GstClockTime,
    ) -> GstClockTime;
    pub fn gst_clock_wait_for_sync(clock: *mut GstClock, timeout: GstClockTime) -> gboolean;

    //=========================================================================
    // GstControlBinding
    //=========================================================================
    pub fn gst_control_binding_get_type() -> GType;
    pub fn gst_control_binding_get_g_value_array(
        binding: *mut GstControlBinding,
        timestamp: GstClockTime,
        interval: GstClockTime,
        n_values: c_uint,
        values: *mut gobject::GValue,
    ) -> gboolean;
    pub fn gst_control_binding_get_value(
        binding: *mut GstControlBinding,
        timestamp: GstClockTime,
    ) -> *mut gobject::GValue;
    pub fn gst_control_binding_get_value_array(
        binding: *mut GstControlBinding,
        timestamp: GstClockTime,
        interval: GstClockTime,
        n_values: c_uint,
        values: gpointer,
    ) -> gboolean;
    pub fn gst_control_binding_is_disabled(binding: *mut GstControlBinding) -> gboolean;
    pub fn gst_control_binding_set_disabled(binding: *mut GstControlBinding, disabled: gboolean);
    pub fn gst_control_binding_sync_values(
        binding: *mut GstControlBinding,
        object: *mut GstObject,
        timestamp: GstClockTime,
        last_sync: GstClockTime,
    ) -> gboolean;

    //=========================================================================
    // GstControlSource
    //=========================================================================
    pub fn gst_control_source_get_type() -> GType;
    pub fn gst_control_source_get_value(
        self_: *mut GstControlSource,
        timestamp: GstClockTime,
        value: *mut c_double,
    ) -> gboolean;
    pub fn gst_control_source_get_value_array(
        self_: *mut GstControlSource,
        timestamp: GstClockTime,
        interval: GstClockTime,
        n_values: c_uint,
        values: *mut c_double,
    ) -> gboolean;

    //=========================================================================
    // GstDevice
    //=========================================================================
    pub fn gst_device_get_type() -> GType;
    pub fn gst_device_create_element(
        device: *mut GstDevice,
        name: *const c_char,
    ) -> *mut GstElement;
    pub fn gst_device_get_caps(device: *mut GstDevice) -> *mut GstCaps;
    pub fn gst_device_get_device_class(device: *mut GstDevice) -> *mut c_char;
    pub fn gst_device_get_display_name(device: *mut GstDevice) -> *mut c_char;
    pub fn gst_device_get_properties(device: *mut GstDevice) -> *mut GstStructure;
    pub fn gst_device_has_classes(device: *mut GstDevice, classes: *const c_char) -> gboolean;
    pub fn gst_device_has_classesv(device: *mut GstDevice, classes: *mut *mut c_char) -> gboolean;
    pub fn gst_device_reconfigure_element(
        device: *mut GstDevice,
        element: *mut GstElement,
    ) -> gboolean;

    //=========================================================================
    // GstDeviceMonitor
    //=========================================================================
    pub fn gst_device_monitor_get_type() -> GType;
    pub fn gst_device_monitor_new() -> *mut GstDeviceMonitor;
    pub fn gst_device_monitor_add_filter(
        monitor: *mut GstDeviceMonitor,
        classes: *const c_char,
        caps: *mut GstCaps,
    ) -> c_uint;
    pub fn gst_device_monitor_get_bus(monitor: *mut GstDeviceMonitor) -> *mut GstBus;
    pub fn gst_device_monitor_get_devices(monitor: *mut GstDeviceMonitor) -> *mut glib::GList;
    pub fn gst_device_monitor_get_providers(monitor: *mut GstDeviceMonitor) -> *mut *mut c_char;
    pub fn gst_device_monitor_get_show_all_devices(monitor: *mut GstDeviceMonitor) -> gboolean;
    pub fn gst_device_monitor_remove_filter(
        monitor: *mut GstDeviceMonitor,
        filter_id: c_uint,
    ) -> gboolean;
    pub fn gst_device_monitor_set_show_all_devices(
        monitor: *mut GstDeviceMonitor,
        show_all: gboolean,
    );
    pub fn gst_device_monitor_start(monitor: *mut GstDeviceMonitor) -> gboolean;
    pub fn gst_device_monitor_stop(monitor: *mut GstDeviceMonitor);

    //=========================================================================
    // GstDeviceProvider
    //=========================================================================
    pub fn gst_device_provider_get_type() -> GType;
    pub fn gst_device_provider_register(
        plugin: *mut GstPlugin,
        name: *const c_char,
        rank: c_uint,
        type_: GType,
    ) -> gboolean;
    pub fn gst_device_provider_can_monitor(provider: *mut GstDeviceProvider) -> gboolean;
    pub fn gst_device_provider_device_add(provider: *mut GstDeviceProvider, device: *mut GstDevice);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_device_provider_device_changed(
        provider: *mut GstDeviceProvider,
        device: *mut GstDevice,
        changed_device: *mut GstDevice,
    );
    pub fn gst_device_provider_device_remove(
        provider: *mut GstDeviceProvider,
        device: *mut GstDevice,
    );
    pub fn gst_device_provider_get_bus(provider: *mut GstDeviceProvider) -> *mut GstBus;
    pub fn gst_device_provider_get_devices(provider: *mut GstDeviceProvider) -> *mut glib::GList;
    pub fn gst_device_provider_get_factory(
        provider: *mut GstDeviceProvider,
    ) -> *mut GstDeviceProviderFactory;
    pub fn gst_device_provider_get_hidden_providers(
        provider: *mut GstDeviceProvider,
    ) -> *mut *mut c_char;
    pub fn gst_device_provider_get_metadata(
        provider: *mut GstDeviceProvider,
        key: *const c_char,
    ) -> *const c_char;
    pub fn gst_device_provider_hide_provider(provider: *mut GstDeviceProvider, name: *const c_char);
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_device_provider_is_started(provider: *mut GstDeviceProvider) -> gboolean;
    pub fn gst_device_provider_start(provider: *mut GstDeviceProvider) -> gboolean;
    pub fn gst_device_provider_stop(provider: *mut GstDeviceProvider);
    pub fn gst_device_provider_unhide_provider(
        provider: *mut GstDeviceProvider,
        name: *const c_char,
    );

    //=========================================================================
    // GstDeviceProviderFactory
    //=========================================================================
    pub fn gst_device_provider_factory_get_type() -> GType;
    pub fn gst_device_provider_factory_find(name: *const c_char) -> *mut GstDeviceProviderFactory;
    pub fn gst_device_provider_factory_get_by_name(
        factoryname: *const c_char,
    ) -> *mut GstDeviceProvider;
    pub fn gst_device_provider_factory_list_get_device_providers(
        minrank: GstRank,
    ) -> *mut glib::GList;
    pub fn gst_device_provider_factory_get(
        factory: *mut GstDeviceProviderFactory,
    ) -> *mut GstDeviceProvider;
    pub fn gst_device_provider_factory_get_device_provider_type(
        factory: *mut GstDeviceProviderFactory,
    ) -> GType;
    pub fn gst_device_provider_factory_get_metadata(
        factory: *mut GstDeviceProviderFactory,
        key: *const c_char,
    ) -> *const c_char;
    pub fn gst_device_provider_factory_get_metadata_keys(
        factory: *mut GstDeviceProviderFactory,
    ) -> *mut *mut c_char;
    pub fn gst_device_provider_factory_has_classes(
        factory: *mut GstDeviceProviderFactory,
        classes: *const c_char,
    ) -> gboolean;
    pub fn gst_device_provider_factory_has_classesv(
        factory: *mut GstDeviceProviderFactory,
        classes: *mut *mut c_char,
    ) -> gboolean;

    //=========================================================================
    // GstDoubleRange
    //=========================================================================
    pub fn gst_double_range_get_type() -> GType;

    //=========================================================================
    // GstDynamicTypeFactory
    //=========================================================================
    pub fn gst_dynamic_type_factory_get_type() -> GType;
    pub fn gst_dynamic_type_factory_load(factoryname: *const c_char) -> GType;

    //=========================================================================
    // GstElement
    //=========================================================================
    pub fn gst_element_get_type() -> GType;
    pub fn gst_element_make_from_uri(
        type_: GstURIType,
        uri: *const c_char,
        elementname: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut GstElement;
    pub fn gst_element_register(
        plugin: *mut GstPlugin,
        name: *const c_char,
        rank: c_uint,
        type_: GType,
    ) -> gboolean;
    pub fn gst_element_state_change_return_get_name(
        state_ret: GstStateChangeReturn,
    ) -> *const c_char;
    pub fn gst_element_state_get_name(state: GstState) -> *const c_char;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_element_type_set_skip_documentation(type_: GType);
    pub fn gst_element_abort_state(element: *mut GstElement);
    pub fn gst_element_add_pad(element: *mut GstElement, pad: *mut GstPad) -> gboolean;
    pub fn gst_element_add_property_deep_notify_watch(
        element: *mut GstElement,
        property_name: *const c_char,
        include_value: gboolean,
    ) -> c_ulong;
    pub fn gst_element_add_property_notify_watch(
        element: *mut GstElement,
        property_name: *const c_char,
        include_value: gboolean,
    ) -> c_ulong;
    pub fn gst_element_call_async(
        element: *mut GstElement,
        func: GstElementCallAsyncFunc,
        user_data: gpointer,
        destroy_notify: glib::GDestroyNotify,
    );
    pub fn gst_element_change_state(
        element: *mut GstElement,
        transition: GstStateChange,
    ) -> GstStateChangeReturn;
    pub fn gst_element_continue_state(
        element: *mut GstElement,
        ret: GstStateChangeReturn,
    ) -> GstStateChangeReturn;
    pub fn gst_element_create_all_pads(element: *mut GstElement);
    pub fn gst_element_foreach_pad(
        element: *mut GstElement,
        func: GstElementForeachPadFunc,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_element_foreach_sink_pad(
        element: *mut GstElement,
        func: GstElementForeachPadFunc,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_element_foreach_src_pad(
        element: *mut GstElement,
        func: GstElementForeachPadFunc,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_element_get_base_time(element: *mut GstElement) -> GstClockTime;
    pub fn gst_element_get_bus(element: *mut GstElement) -> *mut GstBus;
    pub fn gst_element_get_clock(element: *mut GstElement) -> *mut GstClock;
    pub fn gst_element_get_compatible_pad(
        element: *mut GstElement,
        pad: *mut GstPad,
        caps: *mut GstCaps,
    ) -> *mut GstPad;
    pub fn gst_element_get_compatible_pad_template(
        element: *mut GstElement,
        compattempl: *mut GstPadTemplate,
    ) -> *mut GstPadTemplate;
    pub fn gst_element_get_context(
        element: *mut GstElement,
        context_type: *const c_char,
    ) -> *mut GstContext;
    pub fn gst_element_get_context_unlocked(
        element: *mut GstElement,
        context_type: *const c_char,
    ) -> *mut GstContext;
    pub fn gst_element_get_contexts(element: *mut GstElement) -> *mut glib::GList;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_element_get_current_clock_time(element: *mut GstElement) -> GstClockTime;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_element_get_current_running_time(element: *mut GstElement) -> GstClockTime;
    pub fn gst_element_get_factory(element: *mut GstElement) -> *mut GstElementFactory;
    pub fn gst_element_get_metadata(element: *mut GstElement, key: *const c_char) -> *const c_char;
    pub fn gst_element_get_pad_template(
        element: *mut GstElement,
        name: *const c_char,
    ) -> *mut GstPadTemplate;
    pub fn gst_element_get_pad_template_list(element: *mut GstElement) -> *mut glib::GList;
    pub fn gst_element_get_request_pad(
        element: *mut GstElement,
        name: *const c_char,
    ) -> *mut GstPad;
    pub fn gst_element_get_start_time(element: *mut GstElement) -> GstClockTime;
    pub fn gst_element_get_state(
        element: *mut GstElement,
        state: *mut GstState,
        pending: *mut GstState,
        timeout: GstClockTime,
    ) -> GstStateChangeReturn;
    pub fn gst_element_get_static_pad(element: *mut GstElement, name: *const c_char)
        -> *mut GstPad;
    pub fn gst_element_is_locked_state(element: *mut GstElement) -> gboolean;
    pub fn gst_element_iterate_pads(element: *mut GstElement) -> *mut GstIterator;
    pub fn gst_element_iterate_sink_pads(element: *mut GstElement) -> *mut GstIterator;
    pub fn gst_element_iterate_src_pads(element: *mut GstElement) -> *mut GstIterator;
    pub fn gst_element_link(src: *mut GstElement, dest: *mut GstElement) -> gboolean;
    pub fn gst_element_link_filtered(
        src: *mut GstElement,
        dest: *mut GstElement,
        filter: *mut GstCaps,
    ) -> gboolean;
    pub fn gst_element_link_many(
        element_1: *mut GstElement,
        element_2: *mut GstElement,
        ...
    ) -> gboolean;
    pub fn gst_element_link_pads(
        src: *mut GstElement,
        srcpadname: *const c_char,
        dest: *mut GstElement,
        destpadname: *const c_char,
    ) -> gboolean;
    pub fn gst_element_link_pads_filtered(
        src: *mut GstElement,
        srcpadname: *const c_char,
        dest: *mut GstElement,
        destpadname: *const c_char,
        filter: *mut GstCaps,
    ) -> gboolean;
    pub fn gst_element_link_pads_full(
        src: *mut GstElement,
        srcpadname: *const c_char,
        dest: *mut GstElement,
        destpadname: *const c_char,
        flags: GstPadLinkCheck,
    ) -> gboolean;
    pub fn gst_element_lost_state(element: *mut GstElement);
    pub fn gst_element_message_full(
        element: *mut GstElement,
        type_: GstMessageType,
        domain: glib::GQuark,
        code: c_int,
        text: *mut c_char,
        debug: *mut c_char,
        file: *const c_char,
        function: *const c_char,
        line: c_int,
    );
    pub fn gst_element_message_full_with_details(
        element: *mut GstElement,
        type_: GstMessageType,
        domain: glib::GQuark,
        code: c_int,
        text: *mut c_char,
        debug: *mut c_char,
        file: *const c_char,
        function: *const c_char,
        line: c_int,
        structure: *mut GstStructure,
    );
    pub fn gst_element_no_more_pads(element: *mut GstElement);
    pub fn gst_element_post_message(element: *mut GstElement, message: *mut GstMessage)
        -> gboolean;
    pub fn gst_element_provide_clock(element: *mut GstElement) -> *mut GstClock;
    pub fn gst_element_query(element: *mut GstElement, query: *mut GstQuery) -> gboolean;
    pub fn gst_element_query_convert(
        element: *mut GstElement,
        src_format: GstFormat,
        src_val: i64,
        dest_format: GstFormat,
        dest_val: *mut i64,
    ) -> gboolean;
    pub fn gst_element_query_duration(
        element: *mut GstElement,
        format: GstFormat,
        duration: *mut i64,
    ) -> gboolean;
    pub fn gst_element_query_position(
        element: *mut GstElement,
        format: GstFormat,
        cur: *mut i64,
    ) -> gboolean;
    pub fn gst_element_release_request_pad(element: *mut GstElement, pad: *mut GstPad);
    pub fn gst_element_remove_pad(element: *mut GstElement, pad: *mut GstPad) -> gboolean;
    pub fn gst_element_remove_property_notify_watch(element: *mut GstElement, watch_id: c_ulong);
    pub fn gst_element_request_pad(
        element: *mut GstElement,
        templ: *mut GstPadTemplate,
        name: *const c_char,
        caps: *const GstCaps,
    ) -> *mut GstPad;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_element_request_pad_simple(
        element: *mut GstElement,
        name: *const c_char,
    ) -> *mut GstPad;
    pub fn gst_element_seek(
        element: *mut GstElement,
        rate: c_double,
        format: GstFormat,
        flags: GstSeekFlags,
        start_type: GstSeekType,
        start: i64,
        stop_type: GstSeekType,
        stop: i64,
    ) -> gboolean;
    pub fn gst_element_seek_simple(
        element: *mut GstElement,
        format: GstFormat,
        seek_flags: GstSeekFlags,
        seek_pos: i64,
    ) -> gboolean;
    pub fn gst_element_send_event(element: *mut GstElement, event: *mut GstEvent) -> gboolean;
    pub fn gst_element_set_base_time(element: *mut GstElement, time: GstClockTime);
    pub fn gst_element_set_bus(element: *mut GstElement, bus: *mut GstBus);
    pub fn gst_element_set_clock(element: *mut GstElement, clock: *mut GstClock) -> gboolean;
    pub fn gst_element_set_context(element: *mut GstElement, context: *mut GstContext);
    pub fn gst_element_set_locked_state(
        element: *mut GstElement,
        locked_state: gboolean,
    ) -> gboolean;
    pub fn gst_element_set_start_time(element: *mut GstElement, time: GstClockTime);
    pub fn gst_element_set_state(element: *mut GstElement, state: GstState)
        -> GstStateChangeReturn;
    pub fn gst_element_sync_state_with_parent(element: *mut GstElement) -> gboolean;
    pub fn gst_element_unlink(src: *mut GstElement, dest: *mut GstElement);
    pub fn gst_element_unlink_many(element_1: *mut GstElement, element_2: *mut GstElement, ...);
    pub fn gst_element_unlink_pads(
        src: *mut GstElement,
        srcpadname: *const c_char,
        dest: *mut GstElement,
        destpadname: *const c_char,
    );

    //=========================================================================
    // GstElementFactory
    //=========================================================================
    pub fn gst_element_factory_get_type() -> GType;
    pub fn gst_element_factory_find(name: *const c_char) -> *mut GstElementFactory;
    pub fn gst_element_factory_list_filter(
        list: *mut glib::GList,
        caps: *const GstCaps,
        direction: GstPadDirection,
        subsetonly: gboolean,
    ) -> *mut glib::GList;
    pub fn gst_element_factory_list_get_elements(
        type_: GstElementFactoryListType,
        minrank: GstRank,
    ) -> *mut glib::GList;
    pub fn gst_element_factory_make(
        factoryname: *const c_char,
        name: *const c_char,
    ) -> *mut GstElement;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_element_factory_make_full(
        factoryname: *const c_char,
        first: *const c_char,
        ...
    ) -> *mut GstElement;
    //#[cfg(any(feature = "v1_20", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    //pub fn gst_element_factory_make_valist(factoryname: *const c_char, first: *const c_char, properties: /*Unimplemented*/va_list) -> *mut GstElement;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_element_factory_make_with_properties(
        factoryname: *const c_char,
        n: c_uint,
        names: *mut *const c_char,
        values: *const gobject::GValue,
    ) -> *mut GstElement;
    pub fn gst_element_factory_can_sink_all_caps(
        factory: *mut GstElementFactory,
        caps: *const GstCaps,
    ) -> gboolean;
    pub fn gst_element_factory_can_sink_any_caps(
        factory: *mut GstElementFactory,
        caps: *const GstCaps,
    ) -> gboolean;
    pub fn gst_element_factory_can_src_all_caps(
        factory: *mut GstElementFactory,
        caps: *const GstCaps,
    ) -> gboolean;
    pub fn gst_element_factory_can_src_any_caps(
        factory: *mut GstElementFactory,
        caps: *const GstCaps,
    ) -> gboolean;
    pub fn gst_element_factory_create(
        factory: *mut GstElementFactory,
        name: *const c_char,
    ) -> *mut GstElement;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_element_factory_create_full(
        factory: *mut GstElementFactory,
        first: *const c_char,
        ...
    ) -> *mut GstElement;
    //#[cfg(any(feature = "v1_20", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    //pub fn gst_element_factory_create_valist(factory: *mut GstElementFactory, first: *const c_char, properties: /*Unimplemented*/va_list) -> *mut GstElement;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_element_factory_create_with_properties(
        factory: *mut GstElementFactory,
        n: c_uint,
        names: *mut *const c_char,
        values: *const gobject::GValue,
    ) -> *mut GstElement;
    pub fn gst_element_factory_get_element_type(factory: *mut GstElementFactory) -> GType;
    pub fn gst_element_factory_get_metadata(
        factory: *mut GstElementFactory,
        key: *const c_char,
    ) -> *const c_char;
    pub fn gst_element_factory_get_metadata_keys(
        factory: *mut GstElementFactory,
    ) -> *mut *mut c_char;
    pub fn gst_element_factory_get_num_pad_templates(factory: *mut GstElementFactory) -> c_uint;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_element_factory_get_skip_documentation(factory: *mut GstElementFactory) -> gboolean;
    pub fn gst_element_factory_get_static_pad_templates(
        factory: *mut GstElementFactory,
    ) -> *const glib::GList;
    pub fn gst_element_factory_get_uri_protocols(
        factory: *mut GstElementFactory,
    ) -> *const *const c_char;
    pub fn gst_element_factory_get_uri_type(factory: *mut GstElementFactory) -> GstURIType;
    pub fn gst_element_factory_has_interface(
        factory: *mut GstElementFactory,
        interfacename: *const c_char,
    ) -> gboolean;
    pub fn gst_element_factory_list_is_type(
        factory: *mut GstElementFactory,
        type_: GstElementFactoryListType,
    ) -> gboolean;

    //=========================================================================
    // GstFlagSet
    //=========================================================================
    pub fn gst_flagset_get_type() -> GType;
    pub fn gst_flagset_register(flags_type: GType) -> GType;

    //=========================================================================
    // GstFraction
    //=========================================================================
    pub fn gst_fraction_get_type() -> GType;

    //=========================================================================
    // GstFractionRange
    //=========================================================================
    pub fn gst_fraction_range_get_type() -> GType;

    //=========================================================================
    // GstGhostPad
    //=========================================================================
    pub fn gst_ghost_pad_get_type() -> GType;
    pub fn gst_ghost_pad_new(name: *const c_char, target: *mut GstPad) -> *mut GstPad;
    pub fn gst_ghost_pad_new_from_template(
        name: *const c_char,
        target: *mut GstPad,
        templ: *mut GstPadTemplate,
    ) -> *mut GstPad;
    pub fn gst_ghost_pad_new_no_target(name: *const c_char, dir: GstPadDirection) -> *mut GstPad;
    pub fn gst_ghost_pad_new_no_target_from_template(
        name: *const c_char,
        templ: *mut GstPadTemplate,
    ) -> *mut GstPad;
    pub fn gst_ghost_pad_activate_mode_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        mode: GstPadMode,
        active: gboolean,
    ) -> gboolean;
    pub fn gst_ghost_pad_internal_activate_mode_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        mode: GstPadMode,
        active: gboolean,
    ) -> gboolean;
    pub fn gst_ghost_pad_construct(gpad: *mut GstGhostPad) -> gboolean;
    pub fn gst_ghost_pad_get_target(gpad: *mut GstGhostPad) -> *mut GstPad;
    pub fn gst_ghost_pad_set_target(gpad: *mut GstGhostPad, newtarget: *mut GstPad) -> gboolean;

    //=========================================================================
    // GstInt64Range
    //=========================================================================
    pub fn gst_int64_range_get_type() -> GType;

    //=========================================================================
    // GstIntRange
    //=========================================================================
    pub fn gst_int_range_get_type() -> GType;

    //=========================================================================
    // GstObject
    //=========================================================================
    pub fn gst_object_get_type() -> GType;
    pub fn gst_object_check_uniqueness(list: *mut glib::GList, name: *const c_char) -> gboolean;
    pub fn gst_object_default_deep_notify(
        object: *mut gobject::GObject,
        orig: *mut GstObject,
        pspec: *mut gobject::GParamSpec,
        excluded_props: *mut *mut c_char,
    );
    pub fn gst_object_ref_sink(object: gpointer) -> gpointer;
    pub fn gst_object_replace(oldobj: *mut *mut GstObject, newobj: *mut GstObject) -> gboolean;
    pub fn gst_object_add_control_binding(
        object: *mut GstObject,
        binding: *mut GstControlBinding,
    ) -> gboolean;
    pub fn gst_object_default_error(
        source: *mut GstObject,
        error: *const glib::GError,
        debug: *const c_char,
    );
    pub fn gst_object_get_control_binding(
        object: *mut GstObject,
        property_name: *const c_char,
    ) -> *mut GstControlBinding;
    pub fn gst_object_get_control_rate(object: *mut GstObject) -> GstClockTime;
    pub fn gst_object_get_g_value_array(
        object: *mut GstObject,
        property_name: *const c_char,
        timestamp: GstClockTime,
        interval: GstClockTime,
        n_values: c_uint,
        values: *mut gobject::GValue,
    ) -> gboolean;
    pub fn gst_object_get_name(object: *mut GstObject) -> *mut c_char;
    pub fn gst_object_get_parent(object: *mut GstObject) -> *mut GstObject;
    pub fn gst_object_get_path_string(object: *mut GstObject) -> *mut c_char;
    pub fn gst_object_get_value(
        object: *mut GstObject,
        property_name: *const c_char,
        timestamp: GstClockTime,
    ) -> *mut gobject::GValue;
    pub fn gst_object_get_value_array(
        object: *mut GstObject,
        property_name: *const c_char,
        timestamp: GstClockTime,
        interval: GstClockTime,
        n_values: c_uint,
        values: gpointer,
    ) -> gboolean;
    pub fn gst_object_has_active_control_bindings(object: *mut GstObject) -> gboolean;
    pub fn gst_object_has_ancestor(object: *mut GstObject, ancestor: *mut GstObject) -> gboolean;
    pub fn gst_object_has_as_ancestor(object: *mut GstObject, ancestor: *mut GstObject)
        -> gboolean;
    pub fn gst_object_has_as_parent(object: *mut GstObject, parent: *mut GstObject) -> gboolean;
    pub fn gst_object_ref(object: *mut GstObject) -> *mut GstObject;
    pub fn gst_object_remove_control_binding(
        object: *mut GstObject,
        binding: *mut GstControlBinding,
    ) -> gboolean;
    pub fn gst_object_set_control_binding_disabled(
        object: *mut GstObject,
        property_name: *const c_char,
        disabled: gboolean,
    );
    pub fn gst_object_set_control_bindings_disabled(object: *mut GstObject, disabled: gboolean);
    pub fn gst_object_set_control_rate(object: *mut GstObject, control_rate: GstClockTime);
    pub fn gst_object_set_name(object: *mut GstObject, name: *const c_char) -> gboolean;
    pub fn gst_object_set_parent(object: *mut GstObject, parent: *mut GstObject) -> gboolean;
    pub fn gst_object_suggest_next_sync(object: *mut GstObject) -> GstClockTime;
    pub fn gst_object_sync_values(object: *mut GstObject, timestamp: GstClockTime) -> gboolean;
    pub fn gst_object_unparent(object: *mut GstObject);
    pub fn gst_object_unref(object: *mut GstObject);

    //=========================================================================
    // GstPad
    //=========================================================================
    pub fn gst_pad_get_type() -> GType;
    pub fn gst_pad_new(name: *const c_char, direction: GstPadDirection) -> *mut GstPad;
    pub fn gst_pad_new_from_static_template(
        templ: *mut GstStaticPadTemplate,
        name: *const c_char,
    ) -> *mut GstPad;
    pub fn gst_pad_new_from_template(
        templ: *mut GstPadTemplate,
        name: *const c_char,
    ) -> *mut GstPad;
    pub fn gst_pad_link_get_name(ret: GstPadLinkReturn) -> *const c_char;
    pub fn gst_pad_activate_mode(pad: *mut GstPad, mode: GstPadMode, active: gboolean) -> gboolean;
    pub fn gst_pad_add_probe(
        pad: *mut GstPad,
        mask: GstPadProbeType,
        callback: GstPadProbeCallback,
        user_data: gpointer,
        destroy_data: glib::GDestroyNotify,
    ) -> c_ulong;
    pub fn gst_pad_can_link(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> gboolean;
    pub fn gst_pad_chain(pad: *mut GstPad, buffer: *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_chain_list(pad: *mut GstPad, list: *mut GstBufferList) -> GstFlowReturn;
    pub fn gst_pad_check_reconfigure(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_create_stream_id(
        pad: *mut GstPad,
        parent: *mut GstElement,
        stream_id: *const c_char,
    ) -> *mut c_char;
    pub fn gst_pad_create_stream_id_printf(
        pad: *mut GstPad,
        parent: *mut GstElement,
        stream_id: *const c_char,
        ...
    ) -> *mut c_char;
    //pub fn gst_pad_create_stream_id_printf_valist(pad: *mut GstPad, parent: *mut GstElement, stream_id: *const c_char, var_args: /*Unimplemented*/va_list) -> *mut c_char;
    pub fn gst_pad_event_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        event: *mut GstEvent,
    ) -> gboolean;
    pub fn gst_pad_forward(
        pad: *mut GstPad,
        forward: GstPadForwardFunction,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_pad_get_allowed_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_get_current_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_get_direction(pad: *mut GstPad) -> GstPadDirection;
    pub fn gst_pad_get_element_private(pad: *mut GstPad) -> gpointer;
    pub fn gst_pad_get_last_flow_return(pad: *mut GstPad) -> GstFlowReturn;
    pub fn gst_pad_get_offset(pad: *mut GstPad) -> i64;
    pub fn gst_pad_get_pad_template(pad: *mut GstPad) -> *mut GstPadTemplate;
    pub fn gst_pad_get_pad_template_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_get_parent_element(pad: *mut GstPad) -> *mut GstElement;
    pub fn gst_pad_get_peer(pad: *mut GstPad) -> *mut GstPad;
    pub fn gst_pad_get_range(
        pad: *mut GstPad,
        offset: u64,
        size: c_uint,
        buffer: *mut *mut GstBuffer,
    ) -> GstFlowReturn;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_pad_get_single_internal_link(pad: *mut GstPad) -> *mut GstPad;
    pub fn gst_pad_get_sticky_event(
        pad: *mut GstPad,
        event_type: GstEventType,
        idx: c_uint,
    ) -> *mut GstEvent;
    pub fn gst_pad_get_stream(pad: *mut GstPad) -> *mut GstStream;
    pub fn gst_pad_get_stream_id(pad: *mut GstPad) -> *mut c_char;
    pub fn gst_pad_get_task_state(pad: *mut GstPad) -> GstTaskState;
    pub fn gst_pad_has_current_caps(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_active(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_blocked(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_blocking(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_linked(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_iterate_internal_links(pad: *mut GstPad) -> *mut GstIterator;
    pub fn gst_pad_iterate_internal_links_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
    ) -> *mut GstIterator;
    pub fn gst_pad_link(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> GstPadLinkReturn;
    pub fn gst_pad_link_full(
        srcpad: *mut GstPad,
        sinkpad: *mut GstPad,
        flags: GstPadLinkCheck,
    ) -> GstPadLinkReturn;
    pub fn gst_pad_link_maybe_ghosting(src: *mut GstPad, sink: *mut GstPad) -> gboolean;
    pub fn gst_pad_link_maybe_ghosting_full(
        src: *mut GstPad,
        sink: *mut GstPad,
        flags: GstPadLinkCheck,
    ) -> gboolean;
    pub fn gst_pad_mark_reconfigure(pad: *mut GstPad);
    pub fn gst_pad_needs_reconfigure(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_pause_task(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_peer_query(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_peer_query_accept_caps(pad: *mut GstPad, caps: *mut GstCaps) -> gboolean;
    pub fn gst_pad_peer_query_caps(pad: *mut GstPad, filter: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_pad_peer_query_convert(
        pad: *mut GstPad,
        src_format: GstFormat,
        src_val: i64,
        dest_format: GstFormat,
        dest_val: *mut i64,
    ) -> gboolean;
    pub fn gst_pad_peer_query_duration(
        pad: *mut GstPad,
        format: GstFormat,
        duration: *mut i64,
    ) -> gboolean;
    pub fn gst_pad_peer_query_position(
        pad: *mut GstPad,
        format: GstFormat,
        cur: *mut i64,
    ) -> gboolean;
    pub fn gst_pad_proxy_query_accept_caps(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_proxy_query_caps(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_pull_range(
        pad: *mut GstPad,
        offset: u64,
        size: c_uint,
        buffer: *mut *mut GstBuffer,
    ) -> GstFlowReturn;
    pub fn gst_pad_push(pad: *mut GstPad, buffer: *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_push_event(pad: *mut GstPad, event: *mut GstEvent) -> gboolean;
    pub fn gst_pad_push_list(pad: *mut GstPad, list: *mut GstBufferList) -> GstFlowReturn;
    pub fn gst_pad_query(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_query_accept_caps(pad: *mut GstPad, caps: *mut GstCaps) -> gboolean;
    pub fn gst_pad_query_caps(pad: *mut GstPad, filter: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_pad_query_convert(
        pad: *mut GstPad,
        src_format: GstFormat,
        src_val: i64,
        dest_format: GstFormat,
        dest_val: *mut i64,
    ) -> gboolean;
    pub fn gst_pad_query_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        query: *mut GstQuery,
    ) -> gboolean;
    pub fn gst_pad_query_duration(
        pad: *mut GstPad,
        format: GstFormat,
        duration: *mut i64,
    ) -> gboolean;
    pub fn gst_pad_query_position(pad: *mut GstPad, format: GstFormat, cur: *mut i64) -> gboolean;
    pub fn gst_pad_remove_probe(pad: *mut GstPad, id: c_ulong);
    pub fn gst_pad_send_event(pad: *mut GstPad, event: *mut GstEvent) -> gboolean;
    pub fn gst_pad_set_activate_function_full(
        pad: *mut GstPad,
        activate: GstPadActivateFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_pad_set_activatemode_function_full(
        pad: *mut GstPad,
        activatemode: GstPadActivateModeFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_pad_set_active(pad: *mut GstPad, active: gboolean) -> gboolean;
    pub fn gst_pad_set_chain_function_full(
        pad: *mut GstPad,
        chain: GstPadChainFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_pad_set_chain_list_function_full(
        pad: *mut GstPad,
        chainlist: GstPadChainListFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_pad_set_element_private(pad: *mut GstPad, priv_: gpointer);
    pub fn gst_pad_set_event_full_function_full(
        pad: *mut GstPad,
        event: GstPadEventFullFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_pad_set_event_function_full(
        pad: *mut GstPad,
        event: GstPadEventFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_pad_set_getrange_function_full(
        pad: *mut GstPad,
        get: GstPadGetRangeFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_pad_set_iterate_internal_links_function_full(
        pad: *mut GstPad,
        iterintlink: GstPadIterIntLinkFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_pad_set_link_function_full(
        pad: *mut GstPad,
        link: GstPadLinkFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_pad_set_offset(pad: *mut GstPad, offset: i64);
    pub fn gst_pad_set_query_function_full(
        pad: *mut GstPad,
        query: GstPadQueryFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_pad_set_unlink_function_full(
        pad: *mut GstPad,
        unlink: GstPadUnlinkFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_pad_start_task(
        pad: *mut GstPad,
        func: GstTaskFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    ) -> gboolean;
    pub fn gst_pad_sticky_events_foreach(
        pad: *mut GstPad,
        foreach_func: GstPadStickyEventsForeachFunction,
        user_data: gpointer,
    );
    pub fn gst_pad_stop_task(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_store_sticky_event(pad: *mut GstPad, event: *mut GstEvent) -> GstFlowReturn;
    pub fn gst_pad_unlink(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> gboolean;
    pub fn gst_pad_use_fixed_caps(pad: *mut GstPad);

    //=========================================================================
    // GstPadTemplate
    //=========================================================================
    pub fn gst_pad_template_get_type() -> GType;
    pub fn gst_pad_template_new(
        name_template: *const c_char,
        direction: GstPadDirection,
        presence: GstPadPresence,
        caps: *mut GstCaps,
    ) -> *mut GstPadTemplate;
    pub fn gst_pad_template_new_from_static_pad_template_with_gtype(
        pad_template: *mut GstStaticPadTemplate,
        pad_type: GType,
    ) -> *mut GstPadTemplate;
    pub fn gst_pad_template_new_with_gtype(
        name_template: *const c_char,
        direction: GstPadDirection,
        presence: GstPadPresence,
        caps: *mut GstCaps,
        pad_type: GType,
    ) -> *mut GstPadTemplate;
    pub fn gst_pad_template_get_caps(templ: *mut GstPadTemplate) -> *mut GstCaps;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_pad_template_get_documentation_caps(templ: *mut GstPadTemplate) -> *mut GstCaps;
    pub fn gst_pad_template_pad_created(templ: *mut GstPadTemplate, pad: *mut GstPad);
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_pad_template_set_documentation_caps(templ: *mut GstPadTemplate, caps: *mut GstCaps);

    //=========================================================================
    // GstParamArray
    //=========================================================================
    pub fn gst_param_spec_array_get_type() -> GType;

    //=========================================================================
    // GstParamFraction
    //=========================================================================
    pub fn gst_param_spec_fraction_get_type() -> GType;

    //=========================================================================
    // GstPipeline
    //=========================================================================
    pub fn gst_pipeline_get_type() -> GType;
    pub fn gst_pipeline_new(name: *const c_char) -> *mut GstElement;
    pub fn gst_pipeline_auto_clock(pipeline: *mut GstPipeline);
    pub fn gst_pipeline_get_auto_flush_bus(pipeline: *mut GstPipeline) -> gboolean;
    pub fn gst_pipeline_get_bus(pipeline: *mut GstPipeline) -> *mut GstBus;
    pub fn gst_pipeline_get_clock(pipeline: *mut GstPipeline) -> *mut GstClock;
    pub fn gst_pipeline_get_delay(pipeline: *mut GstPipeline) -> GstClockTime;
    pub fn gst_pipeline_get_latency(pipeline: *mut GstPipeline) -> GstClockTime;
    pub fn gst_pipeline_get_pipeline_clock(pipeline: *mut GstPipeline) -> *mut GstClock;
    pub fn gst_pipeline_set_auto_flush_bus(pipeline: *mut GstPipeline, auto_flush: gboolean);
    pub fn gst_pipeline_set_clock(pipeline: *mut GstPipeline, clock: *mut GstClock) -> gboolean;
    pub fn gst_pipeline_set_delay(pipeline: *mut GstPipeline, delay: GstClockTime);
    pub fn gst_pipeline_set_latency(pipeline: *mut GstPipeline, latency: GstClockTime);
    pub fn gst_pipeline_use_clock(pipeline: *mut GstPipeline, clock: *mut GstClock);

    //=========================================================================
    // GstPlugin
    //=========================================================================
    pub fn gst_plugin_get_type() -> GType;
    pub fn gst_plugin_list_free(list: *mut glib::GList);
    pub fn gst_plugin_load_by_name(name: *const c_char) -> *mut GstPlugin;
    pub fn gst_plugin_load_file(
        filename: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut GstPlugin;
    pub fn gst_plugin_register_static(
        major_version: c_int,
        minor_version: c_int,
        name: *const c_char,
        description: *const c_char,
        init_func: GstPluginInitFunc,
        version: *const c_char,
        license: *const c_char,
        source: *const c_char,
        package: *const c_char,
        origin: *const c_char,
    ) -> gboolean;
    pub fn gst_plugin_register_static_full(
        major_version: c_int,
        minor_version: c_int,
        name: *const c_char,
        description: *const c_char,
        init_full_func: GstPluginInitFullFunc,
        version: *const c_char,
        license: *const c_char,
        source: *const c_char,
        package: *const c_char,
        origin: *const c_char,
        user_data: gpointer,
    ) -> gboolean;
    pub fn gst_plugin_add_dependency(
        plugin: *mut GstPlugin,
        env_vars: *mut *const c_char,
        paths: *mut *const c_char,
        names: *mut *const c_char,
        flags: GstPluginDependencyFlags,
    );
    pub fn gst_plugin_add_dependency_simple(
        plugin: *mut GstPlugin,
        env_vars: *const c_char,
        paths: *const c_char,
        names: *const c_char,
        flags: GstPluginDependencyFlags,
    );
    pub fn gst_plugin_get_cache_data(plugin: *mut GstPlugin) -> *const GstStructure;
    pub fn gst_plugin_get_description(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_filename(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_license(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_name(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_origin(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_package(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_release_date_string(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_source(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_version(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_is_loaded(plugin: *mut GstPlugin) -> gboolean;
    pub fn gst_plugin_load(plugin: *mut GstPlugin) -> *mut GstPlugin;
    pub fn gst_plugin_set_cache_data(plugin: *mut GstPlugin, cache_data: *mut GstStructure);

    //=========================================================================
    // GstPluginFeature
    //=========================================================================
    pub fn gst_plugin_feature_get_type() -> GType;
    pub fn gst_plugin_feature_list_copy(list: *mut glib::GList) -> *mut glib::GList;
    pub fn gst_plugin_feature_list_debug(list: *mut glib::GList);
    pub fn gst_plugin_feature_list_free(list: *mut glib::GList);
    pub fn gst_plugin_feature_rank_compare_func(p1: gconstpointer, p2: gconstpointer) -> c_int;
    pub fn gst_plugin_feature_check_version(
        feature: *mut GstPluginFeature,
        min_major: c_uint,
        min_minor: c_uint,
        min_micro: c_uint,
    ) -> gboolean;
    pub fn gst_plugin_feature_get_plugin(feature: *mut GstPluginFeature) -> *mut GstPlugin;
    pub fn gst_plugin_feature_get_plugin_name(feature: *mut GstPluginFeature) -> *const c_char;
    pub fn gst_plugin_feature_get_rank(feature: *mut GstPluginFeature) -> c_uint;
    pub fn gst_plugin_feature_load(feature: *mut GstPluginFeature) -> *mut GstPluginFeature;
    pub fn gst_plugin_feature_set_rank(feature: *mut GstPluginFeature, rank: c_uint);

    //=========================================================================
    // GstProxyPad
    //=========================================================================
    pub fn gst_proxy_pad_get_type() -> GType;
    pub fn gst_proxy_pad_chain_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        buffer: *mut GstBuffer,
    ) -> GstFlowReturn;
    pub fn gst_proxy_pad_chain_list_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        list: *mut GstBufferList,
    ) -> GstFlowReturn;
    pub fn gst_proxy_pad_getrange_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
        offset: u64,
        size: c_uint,
        buffer: *mut *mut GstBuffer,
    ) -> GstFlowReturn;
    pub fn gst_proxy_pad_iterate_internal_links_default(
        pad: *mut GstPad,
        parent: *mut GstObject,
    ) -> *mut GstIterator;
    pub fn gst_proxy_pad_get_internal(pad: *mut GstProxyPad) -> *mut GstProxyPad;

    //=========================================================================
    // GstRegistry
    //=========================================================================
    pub fn gst_registry_get_type() -> GType;
    pub fn gst_registry_fork_is_enabled() -> gboolean;
    pub fn gst_registry_fork_set_enabled(enabled: gboolean);
    pub fn gst_registry_get() -> *mut GstRegistry;
    pub fn gst_registry_add_feature(
        registry: *mut GstRegistry,
        feature: *mut GstPluginFeature,
    ) -> gboolean;
    pub fn gst_registry_add_plugin(registry: *mut GstRegistry, plugin: *mut GstPlugin) -> gboolean;
    pub fn gst_registry_check_feature_version(
        registry: *mut GstRegistry,
        feature_name: *const c_char,
        min_major: c_uint,
        min_minor: c_uint,
        min_micro: c_uint,
    ) -> gboolean;
    pub fn gst_registry_feature_filter(
        registry: *mut GstRegistry,
        filter: GstPluginFeatureFilter,
        first: gboolean,
        user_data: gpointer,
    ) -> *mut glib::GList;
    pub fn gst_registry_find_feature(
        registry: *mut GstRegistry,
        name: *const c_char,
        type_: GType,
    ) -> *mut GstPluginFeature;
    pub fn gst_registry_find_plugin(
        registry: *mut GstRegistry,
        name: *const c_char,
    ) -> *mut GstPlugin;
    pub fn gst_registry_get_feature_list(
        registry: *mut GstRegistry,
        type_: GType,
    ) -> *mut glib::GList;
    pub fn gst_registry_get_feature_list_by_plugin(
        registry: *mut GstRegistry,
        name: *const c_char,
    ) -> *mut glib::GList;
    pub fn gst_registry_get_feature_list_cookie(registry: *mut GstRegistry) -> u32;
    pub fn gst_registry_get_plugin_list(registry: *mut GstRegistry) -> *mut glib::GList;
    pub fn gst_registry_lookup(
        registry: *mut GstRegistry,
        filename: *const c_char,
    ) -> *mut GstPlugin;
    pub fn gst_registry_lookup_feature(
        registry: *mut GstRegistry,
        name: *const c_char,
    ) -> *mut GstPluginFeature;
    pub fn gst_registry_plugin_filter(
        registry: *mut GstRegistry,
        filter: GstPluginFilter,
        first: gboolean,
        user_data: gpointer,
    ) -> *mut glib::GList;
    pub fn gst_registry_remove_feature(registry: *mut GstRegistry, feature: *mut GstPluginFeature);
    pub fn gst_registry_remove_plugin(registry: *mut GstRegistry, plugin: *mut GstPlugin);
    pub fn gst_registry_scan_path(registry: *mut GstRegistry, path: *const c_char) -> gboolean;

    //=========================================================================
    // GstSharedTaskPool
    //=========================================================================
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_shared_task_pool_get_type() -> GType;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_shared_task_pool_new() -> *mut GstTaskPool;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_shared_task_pool_get_max_threads(pool: *mut GstSharedTaskPool) -> c_uint;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_shared_task_pool_set_max_threads(pool: *mut GstSharedTaskPool, max_threads: c_uint);

    //=========================================================================
    // GstStream
    //=========================================================================
    pub fn gst_stream_get_type() -> GType;
    pub fn gst_stream_new(
        stream_id: *const c_char,
        caps: *mut GstCaps,
        type_: GstStreamType,
        flags: GstStreamFlags,
    ) -> *mut GstStream;
    pub fn gst_stream_get_caps(stream: *mut GstStream) -> *mut GstCaps;
    pub fn gst_stream_get_stream_flags(stream: *mut GstStream) -> GstStreamFlags;
    pub fn gst_stream_get_stream_id(stream: *mut GstStream) -> *const c_char;
    pub fn gst_stream_get_stream_type(stream: *mut GstStream) -> GstStreamType;
    pub fn gst_stream_get_tags(stream: *mut GstStream) -> *mut GstTagList;
    pub fn gst_stream_set_caps(stream: *mut GstStream, caps: *mut GstCaps);
    pub fn gst_stream_set_stream_flags(stream: *mut GstStream, flags: GstStreamFlags);
    pub fn gst_stream_set_stream_type(stream: *mut GstStream, stream_type: GstStreamType);
    pub fn gst_stream_set_tags(stream: *mut GstStream, tags: *mut GstTagList);

    //=========================================================================
    // GstStreamCollection
    //=========================================================================
    pub fn gst_stream_collection_get_type() -> GType;
    pub fn gst_stream_collection_new(upstream_id: *const c_char) -> *mut GstStreamCollection;
    pub fn gst_stream_collection_add_stream(
        collection: *mut GstStreamCollection,
        stream: *mut GstStream,
    ) -> gboolean;
    pub fn gst_stream_collection_get_size(collection: *mut GstStreamCollection) -> c_uint;
    pub fn gst_stream_collection_get_stream(
        collection: *mut GstStreamCollection,
        index: c_uint,
    ) -> *mut GstStream;
    pub fn gst_stream_collection_get_upstream_id(
        collection: *mut GstStreamCollection,
    ) -> *const c_char;

    //=========================================================================
    // GstSystemClock
    //=========================================================================
    pub fn gst_system_clock_get_type() -> GType;
    pub fn gst_system_clock_obtain() -> *mut GstClock;
    pub fn gst_system_clock_set_default(new_clock: *mut GstClock);

    //=========================================================================
    // GstTask
    //=========================================================================
    pub fn gst_task_get_type() -> GType;
    pub fn gst_task_new(
        func: GstTaskFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    ) -> *mut GstTask;
    pub fn gst_task_cleanup_all();
    pub fn gst_task_get_pool(task: *mut GstTask) -> *mut GstTaskPool;
    pub fn gst_task_get_state(task: *mut GstTask) -> GstTaskState;
    pub fn gst_task_join(task: *mut GstTask) -> gboolean;
    pub fn gst_task_pause(task: *mut GstTask) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_task_resume(task: *mut GstTask) -> gboolean;
    pub fn gst_task_set_enter_callback(
        task: *mut GstTask,
        enter_func: GstTaskThreadFunc,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_task_set_leave_callback(
        task: *mut GstTask,
        leave_func: GstTaskThreadFunc,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_task_set_lock(task: *mut GstTask, mutex: *mut glib::GRecMutex);
    pub fn gst_task_set_pool(task: *mut GstTask, pool: *mut GstTaskPool);
    pub fn gst_task_set_state(task: *mut GstTask, state: GstTaskState) -> gboolean;
    pub fn gst_task_start(task: *mut GstTask) -> gboolean;
    pub fn gst_task_stop(task: *mut GstTask) -> gboolean;

    //=========================================================================
    // GstTaskPool
    //=========================================================================
    pub fn gst_task_pool_get_type() -> GType;
    pub fn gst_task_pool_new() -> *mut GstTaskPool;
    pub fn gst_task_pool_cleanup(pool: *mut GstTaskPool);
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_task_pool_dispose_handle(pool: *mut GstTaskPool, id: gpointer);
    pub fn gst_task_pool_join(pool: *mut GstTaskPool, id: gpointer);
    pub fn gst_task_pool_prepare(pool: *mut GstTaskPool, error: *mut *mut glib::GError);
    pub fn gst_task_pool_push(
        pool: *mut GstTaskPool,
        func: GstTaskPoolFunction,
        user_data: gpointer,
        error: *mut *mut glib::GError,
    ) -> gpointer;

    //=========================================================================
    // GstTracer
    //=========================================================================
    pub fn gst_tracer_get_type() -> GType;
    pub fn gst_tracer_register(
        plugin: *mut GstPlugin,
        name: *const c_char,
        type_: GType,
    ) -> gboolean;

    //=========================================================================
    // GstTracerFactory
    //=========================================================================
    pub fn gst_tracer_factory_get_type() -> GType;
    pub fn gst_tracer_factory_get_list() -> *mut glib::GList;
    pub fn gst_tracer_factory_get_tracer_type(factory: *mut GstTracerFactory) -> GType;

    //=========================================================================
    // GstTracerRecord
    //=========================================================================
    pub fn gst_tracer_record_get_type() -> GType;
    pub fn gst_tracer_record_new(
        name: *const c_char,
        firstfield: *const c_char,
        ...
    ) -> *mut GstTracerRecord;
    pub fn gst_tracer_record_log(self_: *mut GstTracerRecord, ...);

    //=========================================================================
    // GstTypeFindFactory
    //=========================================================================
    pub fn gst_type_find_factory_get_type() -> GType;
    pub fn gst_type_find_factory_get_list() -> *mut glib::GList;
    pub fn gst_type_find_factory_call_function(
        factory: *mut GstTypeFindFactory,
        find: *mut GstTypeFind,
    );
    pub fn gst_type_find_factory_get_caps(factory: *mut GstTypeFindFactory) -> *mut GstCaps;
    pub fn gst_type_find_factory_get_extensions(
        factory: *mut GstTypeFindFactory,
    ) -> *const *const c_char;
    pub fn gst_type_find_factory_has_function(factory: *mut GstTypeFindFactory) -> gboolean;

    //=========================================================================
    // GstValueArray
    //=========================================================================
    pub fn gst_value_array_get_type() -> GType;
    pub fn gst_value_array_append_and_take_value(
        value: *mut gobject::GValue,
        append_value: *mut gobject::GValue,
    );
    pub fn gst_value_array_append_value(
        value: *mut gobject::GValue,
        append_value: *const gobject::GValue,
    );
    pub fn gst_value_array_get_size(value: *const gobject::GValue) -> c_uint;
    pub fn gst_value_array_get_value(
        value: *const gobject::GValue,
        index: c_uint,
    ) -> *const gobject::GValue;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_value_array_init(
        value: *mut gobject::GValue,
        prealloc: c_uint,
    ) -> *mut gobject::GValue;
    pub fn gst_value_array_prepend_value(
        value: *mut gobject::GValue,
        prepend_value: *const gobject::GValue,
    );

    //=========================================================================
    // GstValueList
    //=========================================================================
    pub fn gst_value_list_get_type() -> GType;
    pub fn gst_value_list_append_and_take_value(
        value: *mut gobject::GValue,
        append_value: *mut gobject::GValue,
    );
    pub fn gst_value_list_append_value(
        value: *mut gobject::GValue,
        append_value: *const gobject::GValue,
    );
    pub fn gst_value_list_concat(
        dest: *mut gobject::GValue,
        value1: *const gobject::GValue,
        value2: *const gobject::GValue,
    );
    pub fn gst_value_list_get_size(value: *const gobject::GValue) -> c_uint;
    pub fn gst_value_list_get_value(
        value: *const gobject::GValue,
        index: c_uint,
    ) -> *const gobject::GValue;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_value_list_init(
        value: *mut gobject::GValue,
        prealloc: c_uint,
    ) -> *mut gobject::GValue;
    pub fn gst_value_list_merge(
        dest: *mut gobject::GValue,
        value1: *const gobject::GValue,
        value2: *const gobject::GValue,
    );
    pub fn gst_value_list_prepend_value(
        value: *mut gobject::GValue,
        prepend_value: *const gobject::GValue,
    );

    //=========================================================================
    // GstChildProxy
    //=========================================================================
    pub fn gst_child_proxy_get_type() -> GType;
    pub fn gst_child_proxy_child_added(
        parent: *mut GstChildProxy,
        child: *mut gobject::GObject,
        name: *const c_char,
    );
    pub fn gst_child_proxy_child_removed(
        parent: *mut GstChildProxy,
        child: *mut gobject::GObject,
        name: *const c_char,
    );
    pub fn gst_child_proxy_get(object: *mut GstChildProxy, first_property_name: *const c_char, ...);
    pub fn gst_child_proxy_get_child_by_index(
        parent: *mut GstChildProxy,
        index: c_uint,
    ) -> *mut gobject::GObject;
    pub fn gst_child_proxy_get_child_by_name(
        parent: *mut GstChildProxy,
        name: *const c_char,
    ) -> *mut gobject::GObject;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    pub fn gst_child_proxy_get_child_by_name_recurse(
        child_proxy: *mut GstChildProxy,
        name: *const c_char,
    ) -> *mut gobject::GObject;
    pub fn gst_child_proxy_get_children_count(parent: *mut GstChildProxy) -> c_uint;
    pub fn gst_child_proxy_get_property(
        object: *mut GstChildProxy,
        name: *const c_char,
        value: *mut gobject::GValue,
    );
    //pub fn gst_child_proxy_get_valist(object: *mut GstChildProxy, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn gst_child_proxy_lookup(
        object: *mut GstChildProxy,
        name: *const c_char,
        target: *mut *mut gobject::GObject,
        pspec: *mut *mut gobject::GParamSpec,
    ) -> gboolean;
    pub fn gst_child_proxy_set(object: *mut GstChildProxy, first_property_name: *const c_char, ...);
    pub fn gst_child_proxy_set_property(
        object: *mut GstChildProxy,
        name: *const c_char,
        value: *const gobject::GValue,
    );
    //pub fn gst_child_proxy_set_valist(object: *mut GstChildProxy, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);

    //=========================================================================
    // GstPreset
    //=========================================================================
    pub fn gst_preset_get_type() -> GType;
    pub fn gst_preset_get_app_dir() -> *const c_char;
    pub fn gst_preset_set_app_dir(app_dir: *const c_char) -> gboolean;
    pub fn gst_preset_delete_preset(preset: *mut GstPreset, name: *const c_char) -> gboolean;
    pub fn gst_preset_get_meta(
        preset: *mut GstPreset,
        name: *const c_char,
        tag: *const c_char,
        value: *mut *mut c_char,
    ) -> gboolean;
    pub fn gst_preset_get_preset_names(preset: *mut GstPreset) -> *mut *mut c_char;
    pub fn gst_preset_get_property_names(preset: *mut GstPreset) -> *mut *mut c_char;
    pub fn gst_preset_is_editable(preset: *mut GstPreset) -> gboolean;
    pub fn gst_preset_load_preset(preset: *mut GstPreset, name: *const c_char) -> gboolean;
    pub fn gst_preset_rename_preset(
        preset: *mut GstPreset,
        old_name: *const c_char,
        new_name: *const c_char,
    ) -> gboolean;
    pub fn gst_preset_save_preset(preset: *mut GstPreset, name: *const c_char) -> gboolean;
    pub fn gst_preset_set_meta(
        preset: *mut GstPreset,
        name: *const c_char,
        tag: *const c_char,
        value: *const c_char,
    ) -> gboolean;

    //=========================================================================
    // GstTagSetter
    //=========================================================================
    pub fn gst_tag_setter_get_type() -> GType;
    //pub fn gst_tag_setter_add_tag_valist(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    //pub fn gst_tag_setter_add_tag_valist_values(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn gst_tag_setter_add_tag_value(
        setter: *mut GstTagSetter,
        mode: GstTagMergeMode,
        tag: *const c_char,
        value: *const gobject::GValue,
    );
    pub fn gst_tag_setter_add_tag_values(
        setter: *mut GstTagSetter,
        mode: GstTagMergeMode,
        tag: *const c_char,
        ...
    );
    pub fn gst_tag_setter_add_tags(
        setter: *mut GstTagSetter,
        mode: GstTagMergeMode,
        tag: *const c_char,
        ...
    );
    pub fn gst_tag_setter_get_tag_list(setter: *mut GstTagSetter) -> *const GstTagList;
    pub fn gst_tag_setter_get_tag_merge_mode(setter: *mut GstTagSetter) -> GstTagMergeMode;
    pub fn gst_tag_setter_merge_tags(
        setter: *mut GstTagSetter,
        list: *const GstTagList,
        mode: GstTagMergeMode,
    );
    pub fn gst_tag_setter_reset_tags(setter: *mut GstTagSetter);
    pub fn gst_tag_setter_set_tag_merge_mode(setter: *mut GstTagSetter, mode: GstTagMergeMode);

    //=========================================================================
    // GstTocSetter
    //=========================================================================
    pub fn gst_toc_setter_get_type() -> GType;
    pub fn gst_toc_setter_get_toc(setter: *mut GstTocSetter) -> *mut GstToc;
    pub fn gst_toc_setter_reset(setter: *mut GstTocSetter);
    pub fn gst_toc_setter_set_toc(setter: *mut GstTocSetter, toc: *mut GstToc);

    //=========================================================================
    // GstURIHandler
    //=========================================================================
    pub fn gst_uri_handler_get_type() -> GType;
    pub fn gst_uri_handler_get_protocols(handler: *mut GstURIHandler) -> *const *const c_char;
    pub fn gst_uri_handler_get_uri(handler: *mut GstURIHandler) -> *mut c_char;
    pub fn gst_uri_handler_get_uri_type(handler: *mut GstURIHandler) -> GstURIType;
    pub fn gst_uri_handler_set_uri(
        handler: *mut GstURIHandler,
        uri: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gst_calculate_linear_regression(
        xy: *const GstClockTime,
        temp: *mut GstClockTime,
        n: c_uint,
        m_num: *mut GstClockTime,
        m_denom: *mut GstClockTime,
        b: *mut GstClockTime,
        xbase: *mut GstClockTime,
        r_squared: *mut c_double,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_clear_buffer(buf_ptr: *mut *mut GstBuffer);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_clear_buffer_list(list_ptr: *mut *mut GstBufferList);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_clear_caps(caps_ptr: *mut *mut GstCaps);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_clear_event(event_ptr: *mut *mut GstEvent);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_clear_message(msg_ptr: *mut *mut GstMessage);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_clear_mini_object(object_ptr: *mut *mut GstMiniObject);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_clear_object(object_ptr: *mut *mut GstObject);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_clear_query(query_ptr: *mut *mut GstQuery);
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn gst_clear_structure(structure_ptr: *mut *mut GstStructure);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_clear_tag_list(taglist_ptr: *mut *mut GstTagList);
    #[cfg(any(feature = "v1_18_3", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18_3")))]
    pub fn gst_clear_uri(uri_ptr: *mut *mut GstUri);
    pub fn gst_debug_add_log_function(
        func: GstLogFunction,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_debug_add_ring_buffer_logger(max_size_per_thread: c_uint, thread_timeout: c_uint);
    pub fn gst_debug_bin_to_dot_data(
        bin: *mut GstBin,
        details: GstDebugGraphDetails,
    ) -> *mut c_char;
    pub fn gst_debug_bin_to_dot_file(
        bin: *mut GstBin,
        details: GstDebugGraphDetails,
        file_name: *const c_char,
    );
    pub fn gst_debug_bin_to_dot_file_with_ts(
        bin: *mut GstBin,
        details: GstDebugGraphDetails,
        file_name: *const c_char,
    );
    pub fn gst_debug_construct_term_color(colorinfo: c_uint) -> *mut c_char;
    pub fn gst_debug_construct_win_color(colorinfo: c_uint) -> c_int;
    pub fn gst_debug_get_all_categories() -> *mut glib::GSList;
    pub fn gst_debug_get_color_mode() -> GstDebugColorMode;
    pub fn gst_debug_get_default_threshold() -> GstDebugLevel;
    pub fn gst_debug_get_stack_trace(flags: GstStackTraceFlags) -> *mut c_char;
    pub fn gst_debug_is_active() -> gboolean;
    pub fn gst_debug_is_colored() -> gboolean;
    pub fn gst_debug_log(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const c_char,
        function: *const c_char,
        line: c_int,
        object: *mut gobject::GObject,
        format: *const c_char,
        ...
    );
    pub fn gst_debug_log_default(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const c_char,
        function: *const c_char,
        line: c_int,
        object: *mut gobject::GObject,
        message: *mut GstDebugMessage,
        user_data: gpointer,
    );
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_debug_log_get_line(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const c_char,
        function: *const c_char,
        line: c_int,
        object: *mut gobject::GObject,
        message: *mut GstDebugMessage,
    ) -> *mut c_char;
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    pub fn gst_debug_log_id(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const c_char,
        function: *const c_char,
        line: c_int,
        id: *const c_char,
        format: *const c_char,
        ...
    );
    #[cfg(any(feature = "v1_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    pub fn gst_debug_log_id_literal(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const c_char,
        function: *const c_char,
        line: c_int,
        id: *const c_char,
        message_string: *const c_char,
    );
    //#[cfg(any(feature = "v1_22", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_22")))]
    //pub fn gst_debug_log_id_valist(category: *mut GstDebugCategory, level: GstDebugLevel, file: *const c_char, function: *const c_char, line: c_int, id: *const c_char, format: *const c_char, args: /*Unimplemented*/va_list);
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_debug_log_literal(
        category: *mut GstDebugCategory,
        level: GstDebugLevel,
        file: *const c_char,
        function: *const c_char,
        line: c_int,
        object: *mut gobject::GObject,
        message_string: *const c_char,
    );
    //pub fn gst_debug_log_valist(category: *mut GstDebugCategory, level: GstDebugLevel, file: *const c_char, function: *const c_char, line: c_int, object: *mut gobject::GObject, format: *const c_char, args: /*Unimplemented*/va_list);
    pub fn gst_debug_print_stack_trace();
    pub fn gst_debug_remove_log_function(func: GstLogFunction) -> c_uint;
    pub fn gst_debug_remove_log_function_by_data(data: gpointer) -> c_uint;
    pub fn gst_debug_remove_ring_buffer_logger();
    pub fn gst_debug_ring_buffer_logger_get_logs() -> *mut *mut c_char;
    pub fn gst_debug_set_active(active: gboolean);
    pub fn gst_debug_set_color_mode(mode: GstDebugColorMode);
    pub fn gst_debug_set_color_mode_from_string(mode: *const c_char);
    pub fn gst_debug_set_colored(colored: gboolean);
    pub fn gst_debug_set_default_threshold(level: GstDebugLevel);
    pub fn gst_debug_set_threshold_for_name(name: *const c_char, level: GstDebugLevel);
    pub fn gst_debug_set_threshold_from_string(list: *const c_char, reset: gboolean);
    pub fn gst_debug_unset_threshold_for_name(name: *const c_char);
    pub fn gst_deinit();
    pub fn gst_dynamic_type_register(plugin: *mut GstPlugin, type_: GType) -> gboolean;
    pub fn gst_error_get_message(domain: glib::GQuark, code: c_int) -> *mut c_char;
    pub fn gst_filename_to_uri(
        filename: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut c_char;
    pub fn gst_flow_get_name(ret: GstFlowReturn) -> *const c_char;
    pub fn gst_flow_to_quark(ret: GstFlowReturn) -> glib::GQuark;
    pub fn gst_formats_contains(formats: *const GstFormat, format: GstFormat) -> gboolean;
    pub fn gst_get_main_executable_path() -> *const c_char;
    pub fn gst_info_strdup_printf(format: *const c_char, ...) -> *mut c_char;
    //pub fn gst_info_strdup_vprintf(format: *const c_char, args: /*Unimplemented*/va_list) -> *mut c_char;
    //pub fn gst_info_vasprintf(result: *mut *mut c_char, format: *const c_char, args: /*Unimplemented*/va_list) -> c_int;
    pub fn gst_init(argc: *mut c_int, argv: *mut *mut *mut c_char);
    pub fn gst_init_check(
        argc: *mut c_int,
        argv: *mut *mut *mut c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn gst_init_get_option_group() -> *mut glib::GOptionGroup;
    pub fn gst_is_caps_features(obj: gconstpointer) -> gboolean;
    pub fn gst_is_initialized() -> gboolean;
    pub fn gst_make_element_message_details(name: *const c_char, ...) -> *mut GstStructure;
    pub fn gst_param_spec_array(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        element_spec: *mut gobject::GParamSpec,
        flags: gobject::GParamFlags,
    ) -> *mut gobject::GParamSpec;
    pub fn gst_param_spec_fraction(
        name: *const c_char,
        nick: *const c_char,
        blurb: *const c_char,
        min_num: c_int,
        min_denom: c_int,
        max_num: c_int,
        max_denom: c_int,
        default_num: c_int,
        default_denom: c_int,
        flags: gobject::GParamFlags,
    ) -> *mut gobject::GParamSpec;
    pub fn gst_parent_buffer_meta_api_get_type() -> GType;
    pub fn gst_parse_bin_from_description(
        bin_description: *const c_char,
        ghost_unlinked_pads: gboolean,
        error: *mut *mut glib::GError,
    ) -> *mut GstBin;
    pub fn gst_parse_bin_from_description_full(
        bin_description: *const c_char,
        ghost_unlinked_pads: gboolean,
        context: *mut GstParseContext,
        flags: GstParseFlags,
        error: *mut *mut glib::GError,
    ) -> *mut GstElement;
    pub fn gst_parse_launch(
        pipeline_description: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut GstElement;
    pub fn gst_parse_launch_full(
        pipeline_description: *const c_char,
        context: *mut GstParseContext,
        flags: GstParseFlags,
        error: *mut *mut glib::GError,
    ) -> *mut GstElement;
    pub fn gst_parse_launchv(
        argv: *mut *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut GstElement;
    pub fn gst_parse_launchv_full(
        argv: *mut *const c_char,
        context: *mut GstParseContext,
        flags: GstParseFlags,
        error: *mut *mut glib::GError,
    ) -> *mut GstElement;
    pub fn gst_print(format: *const c_char, ...);
    pub fn gst_printerr(format: *const c_char, ...);
    pub fn gst_printerrln(format: *const c_char, ...);
    pub fn gst_println(format: *const c_char, ...);
    pub fn gst_protection_filter_systems_by_available_decryptors(
        system_identifiers: *mut *const c_char,
    ) -> *mut *mut c_char;
    pub fn gst_protection_meta_api_get_type() -> GType;
    pub fn gst_protection_select_system(system_identifiers: *mut *const c_char) -> *const c_char;
    pub fn gst_reference_timestamp_meta_api_get_type() -> GType;
    pub fn gst_segtrap_is_enabled() -> gboolean;
    pub fn gst_segtrap_set_enabled(enabled: gboolean);
    pub fn gst_static_caps_get_type() -> GType;
    pub fn gst_static_pad_template_get_type() -> GType;
    pub fn gst_tag_exists(tag: *const c_char) -> gboolean;
    pub fn gst_tag_get_description(tag: *const c_char) -> *const c_char;
    pub fn gst_tag_get_flag(tag: *const c_char) -> GstTagFlag;
    pub fn gst_tag_get_nick(tag: *const c_char) -> *const c_char;
    pub fn gst_tag_get_type(tag: *const c_char) -> GType;
    pub fn gst_tag_is_fixed(tag: *const c_char) -> gboolean;
    pub fn gst_tag_merge_strings_with_comma(
        dest: *mut gobject::GValue,
        src: *const gobject::GValue,
    );
    pub fn gst_tag_merge_use_first(dest: *mut gobject::GValue, src: *const gobject::GValue);
    pub fn gst_tag_register(
        name: *const c_char,
        flag: GstTagFlag,
        type_: GType,
        nick: *const c_char,
        blurb: *const c_char,
        func: GstTagMergeFunc,
    );
    pub fn gst_tag_register_static(
        name: *const c_char,
        flag: GstTagFlag,
        type_: GType,
        nick: *const c_char,
        blurb: *const c_char,
        func: GstTagMergeFunc,
    );
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_tracing_get_active_tracers() -> *mut glib::GList;
    pub fn gst_tracing_register_hook(
        tracer: *mut GstTracer,
        detail: *const c_char,
        func: gobject::GCallback,
    );
    pub fn gst_type_find_get_type() -> GType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_type_is_plugin_api(type_: GType, flags: *mut GstPluginAPIFlags) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn gst_type_mark_as_plugin_api(type_: GType, flags: GstPluginAPIFlags);
    pub fn gst_update_registry() -> gboolean;
    pub fn gst_util_array_binary_search(
        array: gpointer,
        num_elements: c_uint,
        element_size: size_t,
        search_func: glib::GCompareDataFunc,
        mode: GstSearchMode,
        search_data: gconstpointer,
        user_data: gpointer,
    ) -> gpointer;
    pub fn gst_util_double_to_fraction(src: c_double, dest_n: *mut c_int, dest_d: *mut c_int);
    pub fn gst_util_dump_buffer(buf: *mut GstBuffer);
    pub fn gst_util_dump_mem(mem: *const u8, size: c_uint);
    pub fn gst_util_fraction_add(
        a_n: c_int,
        a_d: c_int,
        b_n: c_int,
        b_d: c_int,
        res_n: *mut c_int,
        res_d: *mut c_int,
    ) -> gboolean;
    pub fn gst_util_fraction_compare(a_n: c_int, a_d: c_int, b_n: c_int, b_d: c_int) -> c_int;
    pub fn gst_util_fraction_multiply(
        a_n: c_int,
        a_d: c_int,
        b_n: c_int,
        b_d: c_int,
        res_n: *mut c_int,
        res_d: *mut c_int,
    ) -> gboolean;
    pub fn gst_util_fraction_to_double(src_n: c_int, src_d: c_int, dest: *mut c_double);
    pub fn gst_util_gdouble_to_guint64(value: c_double) -> u64;
    pub fn gst_util_get_object_array(
        object: *mut gobject::GObject,
        name: *const c_char,
        array: *mut *mut gobject::GValueArray,
    ) -> gboolean;
    pub fn gst_util_get_timestamp() -> GstClockTime;
    pub fn gst_util_greatest_common_divisor(a: c_int, b: c_int) -> c_int;
    pub fn gst_util_greatest_common_divisor_int64(a: i64, b: i64) -> i64;
    pub fn gst_util_group_id_next() -> c_uint;
    pub fn gst_util_guint64_to_gdouble(value: u64) -> c_double;
    pub fn gst_util_seqnum_compare(s1: u32, s2: u32) -> i32;
    pub fn gst_util_seqnum_next() -> u32;
    pub fn gst_util_set_object_arg(
        object: *mut gobject::GObject,
        name: *const c_char,
        value: *const c_char,
    );
    pub fn gst_util_set_object_array(
        object: *mut gobject::GObject,
        name: *const c_char,
        array: *const gobject::GValueArray,
    ) -> gboolean;
    pub fn gst_util_set_value_from_string(value: *mut gobject::GValue, value_str: *const c_char);
    pub fn gst_util_uint64_scale(val: u64, num: u64, denom: u64) -> u64;
    pub fn gst_util_uint64_scale_ceil(val: u64, num: u64, denom: u64) -> u64;
    pub fn gst_util_uint64_scale_int(val: u64, num: c_int, denom: c_int) -> u64;
    pub fn gst_util_uint64_scale_int_ceil(val: u64, num: c_int, denom: c_int) -> u64;
    pub fn gst_util_uint64_scale_int_round(val: u64, num: c_int, denom: c_int) -> u64;
    pub fn gst_util_uint64_scale_round(val: u64, num: u64, denom: u64) -> u64;
    pub fn gst_value_can_compare(
        value1: *const gobject::GValue,
        value2: *const gobject::GValue,
    ) -> gboolean;
    pub fn gst_value_can_intersect(
        value1: *const gobject::GValue,
        value2: *const gobject::GValue,
    ) -> gboolean;
    pub fn gst_value_can_subtract(
        minuend: *const gobject::GValue,
        subtrahend: *const gobject::GValue,
    ) -> gboolean;
    pub fn gst_value_can_union(
        value1: *const gobject::GValue,
        value2: *const gobject::GValue,
    ) -> gboolean;
    pub fn gst_value_compare(
        value1: *const gobject::GValue,
        value2: *const gobject::GValue,
    ) -> c_int;
    pub fn gst_value_deserialize(dest: *mut gobject::GValue, src: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn gst_value_deserialize_with_pspec(
        dest: *mut gobject::GValue,
        src: *const c_char,
        pspec: *mut gobject::GParamSpec,
    ) -> gboolean;
    pub fn gst_value_fixate(dest: *mut gobject::GValue, src: *const gobject::GValue) -> gboolean;
    pub fn gst_value_fraction_multiply(
        product: *mut gobject::GValue,
        factor1: *const gobject::GValue,
        factor2: *const gobject::GValue,
    ) -> gboolean;
    pub fn gst_value_fraction_subtract(
        dest: *mut gobject::GValue,
        minuend: *const gobject::GValue,
        subtrahend: *const gobject::GValue,
    ) -> gboolean;
    pub fn gst_value_get_bitmask(value: *const gobject::GValue) -> u64;
    pub fn gst_value_get_caps(value: *const gobject::GValue) -> *const GstCaps;
    pub fn gst_value_get_caps_features(value: *const gobject::GValue) -> *const GstCapsFeatures;
    pub fn gst_value_get_double_range_max(value: *const gobject::GValue) -> c_double;
    pub fn gst_value_get_double_range_min(value: *const gobject::GValue) -> c_double;
    pub fn gst_value_get_flagset_flags(value: *const gobject::GValue) -> c_uint;
    pub fn gst_value_get_flagset_mask(value: *const gobject::GValue) -> c_uint;
    pub fn gst_value_get_fraction_denominator(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_fraction_numerator(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_fraction_range_max(
        value: *const gobject::GValue,
    ) -> *const gobject::GValue;
    pub fn gst_value_get_fraction_range_min(
        value: *const gobject::GValue,
    ) -> *const gobject::GValue;
    pub fn gst_value_get_int64_range_max(value: *const gobject::GValue) -> i64;
    pub fn gst_value_get_int64_range_min(value: *const gobject::GValue) -> i64;
    pub fn gst_value_get_int64_range_step(value: *const gobject::GValue) -> i64;
    pub fn gst_value_get_int_range_max(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_int_range_min(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_int_range_step(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_structure(value: *const gobject::GValue) -> *const GstStructure;
    pub fn gst_value_init_and_copy(dest: *mut gobject::GValue, src: *const gobject::GValue);
    pub fn gst_value_intersect(
        dest: *mut gobject::GValue,
        value1: *const gobject::GValue,
        value2: *const gobject::GValue,
    ) -> gboolean;
    pub fn gst_value_is_fixed(value: *const gobject::GValue) -> gboolean;
    pub fn gst_value_is_subset(
        value1: *const gobject::GValue,
        value2: *const gobject::GValue,
    ) -> gboolean;
    pub fn gst_value_register(table: *const GstValueTable);
    pub fn gst_value_serialize(value: *const gobject::GValue) -> *mut c_char;
    pub fn gst_value_set_bitmask(value: *mut gobject::GValue, bitmask: u64);
    pub fn gst_value_set_caps(value: *mut gobject::GValue, caps: *const GstCaps);
    pub fn gst_value_set_caps_features(
        value: *mut gobject::GValue,
        features: *const GstCapsFeatures,
    );
    pub fn gst_value_set_double_range(value: *mut gobject::GValue, start: c_double, end: c_double);
    pub fn gst_value_set_flagset(value: *mut gobject::GValue, flags: c_uint, mask: c_uint);
    pub fn gst_value_set_fraction(
        value: *mut gobject::GValue,
        numerator: c_int,
        denominator: c_int,
    );
    pub fn gst_value_set_fraction_range(
        value: *mut gobject::GValue,
        start: *const gobject::GValue,
        end: *const gobject::GValue,
    );
    pub fn gst_value_set_fraction_range_full(
        value: *mut gobject::GValue,
        numerator_start: c_int,
        denominator_start: c_int,
        numerator_end: c_int,
        denominator_end: c_int,
    );
    pub fn gst_value_set_int64_range(value: *mut gobject::GValue, start: i64, end: i64);
    pub fn gst_value_set_int64_range_step(
        value: *mut gobject::GValue,
        start: i64,
        end: i64,
        step: i64,
    );
    pub fn gst_value_set_int_range(value: *mut gobject::GValue, start: c_int, end: c_int);
    pub fn gst_value_set_int_range_step(
        value: *mut gobject::GValue,
        start: c_int,
        end: c_int,
        step: c_int,
    );
    pub fn gst_value_set_structure(value: *mut gobject::GValue, structure: *const GstStructure);
    pub fn gst_value_subtract(
        dest: *mut gobject::GValue,
        minuend: *const gobject::GValue,
        subtrahend: *const gobject::GValue,
    ) -> gboolean;
    pub fn gst_value_union(
        dest: *mut gobject::GValue,
        value1: *const gobject::GValue,
        value2: *const gobject::GValue,
    ) -> gboolean;
    pub fn gst_version(
        major: *mut c_uint,
        minor: *mut c_uint,
        micro: *mut c_uint,
        nano: *mut c_uint,
    );
    pub fn gst_version_string() -> *mut c_char;

}
