// This file was generated by gir (d121f7e+) from gir-files (???)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;
extern crate gstreamer_sys as gst;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType, Volatile};

// Constants
pub const GST_BASE_PARSE_FLAG_DRAINING: c_int = 2;
pub const GST_BASE_PARSE_FLAG_LOST_SYNC: c_int = 1;
pub const GST_BASE_TRANSFORM_SINK_NAME: *const c_char = b"sink\0" as *const u8 as *const c_char;
pub const GST_BASE_TRANSFORM_SRC_NAME: *const c_char = b"src\0" as *const u8 as *const c_char;

// Flags
bitflags! {
    #[repr(C)]
    pub struct GstBaseParseFrameFlags: c_uint {
        const GST_BASE_PARSE_FRAME_FLAG_NONE = 0;
        const GST_BASE_PARSE_FRAME_FLAG_NEW_FRAME = 1;
        const GST_BASE_PARSE_FRAME_FLAG_NO_FRAME = 2;
        const GST_BASE_PARSE_FRAME_FLAG_CLIP = 4;
        const GST_BASE_PARSE_FRAME_FLAG_DROP = 8;
        const GST_BASE_PARSE_FRAME_FLAG_QUEUE = 16;
    }
}

bitflags! {
    #[repr(C)]
    pub struct GstBaseSrcFlags: c_uint {
        const GST_BASE_SRC_FLAG_STARTING = 16384;
        const GST_BASE_SRC_FLAG_STARTED = 32768;
        const GST_BASE_SRC_FLAG_LAST = 1048576;
    }
}

bitflags! {
    #[repr(C)]
    pub struct GstCollectPadsStateFlags: c_uint {
        const GST_COLLECT_PADS_STATE_EOS = 1;
        const GST_COLLECT_PADS_STATE_FLUSHING = 2;
        const GST_COLLECT_PADS_STATE_NEW_SEGMENT = 4;
        const GST_COLLECT_PADS_STATE_WAITING = 8;
        const GST_COLLECT_PADS_STATE_LOCKED = 16;
    }
}

// Callbacks
pub type GstCollectDataDestroyNotify = Option<unsafe extern "C" fn(*mut GstCollectData)>;
pub type GstCollectPadsBufferFunction = Option<unsafe extern "C" fn(*mut GstCollectPads, *mut GstCollectData, *mut gst::GstBuffer, gpointer) -> gst::GstFlowReturn>;
pub type GstCollectPadsClipFunction = Option<unsafe extern "C" fn(*mut GstCollectPads, *mut GstCollectData, *mut gst::GstBuffer, *mut *mut gst::GstBuffer, gpointer) -> gst::GstFlowReturn>;
pub type GstCollectPadsCompareFunction = Option<unsafe extern "C" fn(*mut GstCollectPads, *mut GstCollectData, gst::GstClockTime, *mut GstCollectData, gst::GstClockTime, gpointer) -> c_int>;
pub type GstCollectPadsEventFunction = Option<unsafe extern "C" fn(*mut GstCollectPads, *mut GstCollectData, *mut gst::GstEvent, gpointer) -> gboolean>;
pub type GstCollectPadsFlushFunction = Option<unsafe extern "C" fn(*mut GstCollectPads, gpointer)>;
pub type GstCollectPadsFunction = Option<unsafe extern "C" fn(*mut GstCollectPads, gpointer) -> gst::GstFlowReturn>;
pub type GstCollectPadsQueryFunction = Option<unsafe extern "C" fn(*mut GstCollectPads, *mut GstCollectData, *mut gst::GstQuery, gpointer) -> gboolean>;
pub type GstDataQueueCheckFullFunction = Option<unsafe extern "C" fn(*mut GstDataQueue, c_uint, c_uint, u64, gpointer) -> gboolean>;
pub type GstDataQueueEmptyCallback = Option<unsafe extern "C" fn(*mut GstDataQueue, gpointer)>;
pub type GstDataQueueFullCallback = Option<unsafe extern "C" fn(*mut GstDataQueue, gpointer)>;
pub type GstTypeFindHelperGetRangeFunction = Option<unsafe extern "C" fn(*mut gst::GstObject, *mut gst::GstObject, u64, c_uint, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn>;

// Records
#[repr(C)]
pub struct GstAdapterClass(c_void);

#[repr(C)]
pub struct GstBaseParseClass {
    pub parent_class: gst::GstElementClass,
    pub start: Option<unsafe extern "C" fn(*mut GstBaseParse) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstBaseParse) -> gboolean>,
    pub set_sink_caps: Option<unsafe extern "C" fn(*mut GstBaseParse, *mut gst::GstCaps) -> gboolean>,
    pub handle_frame: Option<unsafe extern "C" fn(*mut GstBaseParse, *mut GstBaseParseFrame, *mut c_int) -> gst::GstFlowReturn>,
    pub pre_push_frame: Option<unsafe extern "C" fn(*mut GstBaseParse, *mut GstBaseParseFrame) -> gst::GstFlowReturn>,
    pub convert: Option<unsafe extern "C" fn(*mut GstBaseParse, gst::GstFormat, i64, gst::GstFormat, *mut i64) -> gboolean>,
    pub sink_event: Option<unsafe extern "C" fn(*mut GstBaseParse, *mut gst::GstEvent) -> gboolean>,
    pub src_event: Option<unsafe extern "C" fn(*mut GstBaseParse, *mut gst::GstEvent) -> gboolean>,
    pub get_sink_caps: Option<unsafe extern "C" fn(*mut GstBaseParse, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub detect: Option<unsafe extern "C" fn(*mut GstBaseParse, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub sink_query: Option<unsafe extern "C" fn(*mut GstBaseParse, *mut gst::GstQuery) -> gboolean>,
    pub src_query: Option<unsafe extern "C" fn(*mut GstBaseParse, *mut gst::GstQuery) -> gboolean>,
    pub _gst_reserved: [gpointer; 18],
}

#[repr(C)]
pub struct GstBaseParseFrame {
    pub buffer: *mut gst::GstBuffer,
    pub out_buffer: *mut gst::GstBuffer,
    pub flags: c_uint,
    pub offset: u64,
    pub overhead: c_int,
    pub size: c_int,
    pub _gst_reserved_i: [c_uint; 2],
    pub _gst_reserved_p: [gpointer; 2],
    pub _private_flags: c_uint,
}

#[repr(C)]
pub struct GstBaseParsePrivate(c_void);

#[repr(C)]
pub struct GstBaseSinkClass {
    pub parent_class: gst::GstElementClass,
    pub get_caps: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub set_caps: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstCaps) -> gboolean>,
    pub fixate: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub activate_pull: Option<unsafe extern "C" fn(*mut GstBaseSink, gboolean) -> gboolean>,
    pub get_times: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstBuffer, *mut gst::GstClockTime, *mut gst::GstClockTime)>,
    pub propose_allocation: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstQuery) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GstBaseSink) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstBaseSink) -> gboolean>,
    pub unlock: Option<unsafe extern "C" fn(*mut GstBaseSink) -> gboolean>,
    pub unlock_stop: Option<unsafe extern "C" fn(*mut GstBaseSink) -> gboolean>,
    pub query: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstQuery) -> gboolean>,
    pub event: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstEvent) -> gboolean>,
    pub wait_event: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstEvent) -> gst::GstFlowReturn>,
    pub prepare: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub prepare_list: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstBufferList) -> gst::GstFlowReturn>,
    pub preroll: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub render: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub render_list: Option<unsafe extern "C" fn(*mut GstBaseSink, *mut gst::GstBufferList) -> gst::GstFlowReturn>,
    pub _gst_reserved: [gpointer; 20],
}

#[repr(C)]
pub struct GstBaseSinkPrivate(c_void);

#[repr(C)]
pub struct GstBaseSrcClass {
    pub parent_class: gst::GstElementClass,
    pub get_caps: Option<unsafe extern "C" fn(*mut GstBaseSrc, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub negotiate: Option<unsafe extern "C" fn(*mut GstBaseSrc) -> gboolean>,
    pub fixate: Option<unsafe extern "C" fn(*mut GstBaseSrc, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub set_caps: Option<unsafe extern "C" fn(*mut GstBaseSrc, *mut gst::GstCaps) -> gboolean>,
    pub decide_allocation: Option<unsafe extern "C" fn(*mut GstBaseSrc, *mut gst::GstQuery) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GstBaseSrc) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstBaseSrc) -> gboolean>,
    pub get_times: Option<unsafe extern "C" fn(*mut GstBaseSrc, *mut gst::GstBuffer, *mut gst::GstClockTime, *mut gst::GstClockTime)>,
    pub get_size: Option<unsafe extern "C" fn(*mut GstBaseSrc, *mut u64) -> gboolean>,
    pub is_seekable: Option<unsafe extern "C" fn(*mut GstBaseSrc) -> gboolean>,
    pub prepare_seek_segment: Option<unsafe extern "C" fn(*mut GstBaseSrc, *mut gst::GstEvent, *mut gst::GstSegment) -> gboolean>,
    pub do_seek: Option<unsafe extern "C" fn(*mut GstBaseSrc, *mut gst::GstSegment) -> gboolean>,
    pub unlock: Option<unsafe extern "C" fn(*mut GstBaseSrc) -> gboolean>,
    pub unlock_stop: Option<unsafe extern "C" fn(*mut GstBaseSrc) -> gboolean>,
    pub query: Option<unsafe extern "C" fn(*mut GstBaseSrc, *mut gst::GstQuery) -> gboolean>,
    pub event: Option<unsafe extern "C" fn(*mut GstBaseSrc, *mut gst::GstEvent) -> gboolean>,
    pub create: Option<unsafe extern "C" fn(*mut GstBaseSrc, u64, c_uint, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub alloc: Option<unsafe extern "C" fn(*mut GstBaseSrc, u64, c_uint, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub fill: Option<unsafe extern "C" fn(*mut GstBaseSrc, u64, c_uint, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub _gst_reserved: [gpointer; 20],
}

#[repr(C)]
pub struct GstBaseSrcPrivate(c_void);

#[repr(C)]
pub struct GstBaseTransformClass {
    pub parent_class: gst::GstElementClass,
    pub passthrough_on_same_caps: gboolean,
    pub transform_ip_on_passthrough: gboolean,
    pub transform_caps: Option<unsafe extern "C" fn(*mut GstBaseTransform, gst::GstPadDirection, *mut gst::GstCaps, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub fixate_caps: Option<unsafe extern "C" fn(*mut GstBaseTransform, gst::GstPadDirection, *mut gst::GstCaps, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub accept_caps: Option<unsafe extern "C" fn(*mut GstBaseTransform, gst::GstPadDirection, *mut gst::GstCaps) -> gboolean>,
    pub set_caps: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstCaps, *mut gst::GstCaps) -> gboolean>,
    pub query: Option<unsafe extern "C" fn(*mut GstBaseTransform, gst::GstPadDirection, *mut gst::GstQuery) -> gboolean>,
    pub decide_allocation: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstQuery) -> gboolean>,
    pub filter_meta: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstQuery, GType, *const gst::GstStructure) -> gboolean>,
    pub propose_allocation: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstQuery, *mut gst::GstQuery) -> gboolean>,
    pub transform_size: Option<unsafe extern "C" fn(*mut GstBaseTransform, gst::GstPadDirection, *mut gst::GstCaps, size_t, *mut gst::GstCaps, *mut size_t) -> gboolean>,
    pub get_unit_size: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstCaps, *mut size_t) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GstBaseTransform) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstBaseTransform) -> gboolean>,
    pub sink_event: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstEvent) -> gboolean>,
    pub src_event: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstEvent) -> gboolean>,
    pub prepare_output_buffer: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstBuffer, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub copy_metadata: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstBuffer, *mut gst::GstBuffer) -> gboolean>,
    pub transform_meta: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstBuffer, *mut gst::GstMeta, *mut gst::GstBuffer) -> gboolean>,
    pub before_transform: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstBuffer)>,
    pub transform: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut gst::GstBuffer, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub transform_ip: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub submit_input_buffer: Option<unsafe extern "C" fn(*mut GstBaseTransform, gboolean, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub generate_output: Option<unsafe extern "C" fn(*mut GstBaseTransform, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub _gst_reserved: [gpointer; 18],
}

#[repr(C)]
pub struct GstBaseTransformPrivate(c_void);

#[repr(C)]
pub struct GstBitReader {
    pub data: *mut u8,
    pub size: c_uint,
    pub byte: c_uint,
    pub bit: c_uint,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstByteReader {
    pub data: *mut u8,
    pub size: c_uint,
    pub byte: c_uint,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstByteWriter {
    pub parent: GstByteReader,
    pub alloc_size: c_uint,
    pub fixed: gboolean,
    pub owned: gboolean,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstCollectData {
    pub collect: *mut GstCollectPads,
    pub pad: *mut gst::GstPad,
    pub buffer: *mut gst::GstBuffer,
    pub pos: c_uint,
    pub segment: gst::GstSegment,
    pub state: GstCollectPadsStateFlags,
    pub priv_: *mut GstCollectDataPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstCollectDataPrivate(c_void);

#[repr(C)]
pub struct GstCollectPadsClass {
    pub parent_class: gst::GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstCollectPadsPrivate(c_void);

#[repr(C)]
pub struct GstDataQueueClass {
    pub parent_class: gobject::GObjectClass,
    pub empty: Option<unsafe extern "C" fn(*mut GstDataQueue)>,
    pub full: Option<unsafe extern "C" fn(*mut GstDataQueue)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstDataQueueItem {
    pub object: *mut gst::GstMiniObject,
    pub size: c_uint,
    pub duration: u64,
    pub visible: gboolean,
    pub destroy: glib::GDestroyNotify,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstDataQueuePrivate(c_void);

#[repr(C)]
pub struct GstDataQueueSize {
    pub visible: c_uint,
    pub bytes: c_uint,
    pub time: u64,
}

#[repr(C)]
pub struct GstFlowCombiner(c_void);

#[repr(C)]
pub struct GstPushSrcClass {
    pub parent_class: GstBaseSrcClass,
    pub create: Option<unsafe extern "C" fn(*mut GstPushSrc, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub alloc: Option<unsafe extern "C" fn(*mut GstPushSrc, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub fill: Option<unsafe extern "C" fn(*mut GstPushSrc, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstQueueArray(c_void);

// Classes
#[repr(C)]
pub struct GstAdapter(c_void);

#[repr(C)]
pub struct GstBaseParse {
    pub element: gst::GstElement,
    pub sinkpad: *mut gst::GstPad,
    pub srcpad: *mut gst::GstPad,
    pub flags: c_uint,
    pub segment: gst::GstSegment,
    pub _gst_reserved: [gpointer; 20],
    pub priv_: *mut GstBaseParsePrivate,
}

#[repr(C)]
pub struct GstBaseSink {
    pub element: gst::GstElement,
    pub sinkpad: *mut gst::GstPad,
    pub pad_mode: gst::GstPadMode,
    pub offset: u64,
    pub can_activate_pull: gboolean,
    pub can_activate_push: gboolean,
    pub preroll_lock: glib::GMutex,
    pub preroll_cond: glib::GCond,
    pub eos: gboolean,
    pub need_preroll: gboolean,
    pub have_preroll: gboolean,
    pub playing_async: gboolean,
    pub have_newsegment: gboolean,
    pub segment: gst::GstSegment,
    pub clock_id: gst::GstClockID,
    pub sync: gboolean,
    pub flushing: gboolean,
    pub running: gboolean,
    pub max_lateness: i64,
    pub priv_: *mut GstBaseSinkPrivate,
    pub _gst_reserved: [gpointer; 20],
}

#[repr(C)]
pub struct GstBaseSrc {
    pub element: gst::GstElement,
    pub srcpad: *mut gst::GstPad,
    pub live_lock: glib::GMutex,
    pub live_cond: glib::GCond,
    pub is_live: gboolean,
    pub live_running: gboolean,
    pub blocksize: c_uint,
    pub can_activate_push: gboolean,
    pub random_access: gboolean,
    pub clock_id: gst::GstClockID,
    pub segment: gst::GstSegment,
    pub need_newsegment: gboolean,
    pub num_buffers: c_int,
    pub num_buffers_left: c_int,
    pub typefind: gboolean,
    pub running: gboolean,
    pub pending_seek: *mut gst::GstEvent,
    pub priv_: *mut GstBaseSrcPrivate,
    pub _gst_reserved: [gpointer; 20],
}

#[repr(C)]
pub struct GstBaseTransform {
    pub element: gst::GstElement,
    pub sinkpad: *mut gst::GstPad,
    pub srcpad: *mut gst::GstPad,
    pub have_segment: gboolean,
    pub segment: gst::GstSegment,
    pub queued_buf: *mut gst::GstBuffer,
    pub priv_: *mut GstBaseTransformPrivate,
    pub _gst_reserved: [gpointer; 19],
}

#[repr(C)]
pub struct GstCollectPads {
    pub object: gst::GstObject,
    pub data: *mut glib::GSList,
    pub stream_lock: glib::GRecMutex,
    pub priv_: *mut GstCollectPadsPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstDataQueue {
    pub object: gobject::GObject,
    pub priv_: *mut GstDataQueuePrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstPushSrc {
    pub parent: GstBaseSrc,
    pub _gst_reserved: [gpointer; 4],
}

extern "C" {

    //=========================================================================
    // GstBaseParseFrame
    //=========================================================================
    pub fn gst_base_parse_frame_get_type() -> GType;
    pub fn gst_base_parse_frame_new(buffer: *mut gst::GstBuffer, flags: GstBaseParseFrameFlags, overhead: c_int) -> *mut GstBaseParseFrame;
    pub fn gst_base_parse_frame_free(frame: *mut GstBaseParseFrame);
    pub fn gst_base_parse_frame_init(frame: *mut GstBaseParseFrame);

    //=========================================================================
    // GstBitReader
    //=========================================================================
    pub fn gst_bit_reader_free(reader: *mut GstBitReader);
    pub fn gst_bit_reader_get_bits_uint16(reader: *mut GstBitReader, val: *mut u16, nbits: c_uint) -> gboolean;
    pub fn gst_bit_reader_get_bits_uint32(reader: *mut GstBitReader, val: *mut u32, nbits: c_uint) -> gboolean;
    pub fn gst_bit_reader_get_bits_uint64(reader: *mut GstBitReader, val: *mut u64, nbits: c_uint) -> gboolean;
    pub fn gst_bit_reader_get_bits_uint8(reader: *mut GstBitReader, val: *mut u8, nbits: c_uint) -> gboolean;
    pub fn gst_bit_reader_get_pos(reader: *const GstBitReader) -> c_uint;
    pub fn gst_bit_reader_get_remaining(reader: *const GstBitReader) -> c_uint;
    pub fn gst_bit_reader_get_size(reader: *const GstBitReader) -> c_uint;
    pub fn gst_bit_reader_init(reader: *mut GstBitReader, data: *mut u8, size: c_uint);
    pub fn gst_bit_reader_peek_bits_uint16(reader: *const GstBitReader, val: *mut u16, nbits: c_uint) -> gboolean;
    pub fn gst_bit_reader_peek_bits_uint32(reader: *const GstBitReader, val: *mut u32, nbits: c_uint) -> gboolean;
    pub fn gst_bit_reader_peek_bits_uint64(reader: *const GstBitReader, val: *mut u64, nbits: c_uint) -> gboolean;
    pub fn gst_bit_reader_peek_bits_uint8(reader: *const GstBitReader, val: *mut u8, nbits: c_uint) -> gboolean;
    pub fn gst_bit_reader_set_pos(reader: *mut GstBitReader, pos: c_uint) -> gboolean;
    pub fn gst_bit_reader_skip(reader: *mut GstBitReader, nbits: c_uint) -> gboolean;
    pub fn gst_bit_reader_skip_to_byte(reader: *mut GstBitReader) -> gboolean;
    pub fn gst_bit_reader_new(data: *mut u8, size: c_uint) -> *mut GstBitReader;

    //=========================================================================
    // GstByteReader
    //=========================================================================
    pub fn gst_byte_reader_dup_data(reader: *mut GstByteReader, size: c_uint, val: *mut *mut u8) -> gboolean;
    pub fn gst_byte_reader_dup_string_utf16(reader: *mut GstByteReader, str: *mut *mut u16) -> gboolean;
    pub fn gst_byte_reader_dup_string_utf32(reader: *mut GstByteReader, str: *mut *mut u32) -> gboolean;
    pub fn gst_byte_reader_dup_string_utf8(reader: *mut GstByteReader, str: *mut *mut c_char) -> gboolean;
    pub fn gst_byte_reader_free(reader: *mut GstByteReader);
    pub fn gst_byte_reader_get_data(reader: *mut GstByteReader, size: c_uint, val: *mut *mut u8) -> gboolean;
    pub fn gst_byte_reader_get_float32_be(reader: *mut GstByteReader, val: *mut c_float) -> gboolean;
    pub fn gst_byte_reader_get_float32_le(reader: *mut GstByteReader, val: *mut c_float) -> gboolean;
    pub fn gst_byte_reader_get_float64_be(reader: *mut GstByteReader, val: *mut c_double) -> gboolean;
    pub fn gst_byte_reader_get_float64_le(reader: *mut GstByteReader, val: *mut c_double) -> gboolean;
    pub fn gst_byte_reader_get_int16_be(reader: *mut GstByteReader, val: *mut i16) -> gboolean;
    pub fn gst_byte_reader_get_int16_le(reader: *mut GstByteReader, val: *mut i16) -> gboolean;
    pub fn gst_byte_reader_get_int24_be(reader: *mut GstByteReader, val: *mut i32) -> gboolean;
    pub fn gst_byte_reader_get_int24_le(reader: *mut GstByteReader, val: *mut i32) -> gboolean;
    pub fn gst_byte_reader_get_int32_be(reader: *mut GstByteReader, val: *mut i32) -> gboolean;
    pub fn gst_byte_reader_get_int32_le(reader: *mut GstByteReader, val: *mut i32) -> gboolean;
    pub fn gst_byte_reader_get_int64_be(reader: *mut GstByteReader, val: *mut i64) -> gboolean;
    pub fn gst_byte_reader_get_int64_le(reader: *mut GstByteReader, val: *mut i64) -> gboolean;
    pub fn gst_byte_reader_get_int8(reader: *mut GstByteReader, val: *mut i8) -> gboolean;
    pub fn gst_byte_reader_get_pos(reader: *const GstByteReader) -> c_uint;
    pub fn gst_byte_reader_get_remaining(reader: *const GstByteReader) -> c_uint;
    pub fn gst_byte_reader_get_size(reader: *const GstByteReader) -> c_uint;
    pub fn gst_byte_reader_get_string_utf8(reader: *mut GstByteReader, str: *mut *mut c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_byte_reader_get_sub_reader(reader: *mut GstByteReader, sub_reader: *mut GstByteReader, size: c_uint) -> gboolean;
    pub fn gst_byte_reader_get_uint16_be(reader: *mut GstByteReader, val: *mut u16) -> gboolean;
    pub fn gst_byte_reader_get_uint16_le(reader: *mut GstByteReader, val: *mut u16) -> gboolean;
    pub fn gst_byte_reader_get_uint24_be(reader: *mut GstByteReader, val: *mut u32) -> gboolean;
    pub fn gst_byte_reader_get_uint24_le(reader: *mut GstByteReader, val: *mut u32) -> gboolean;
    pub fn gst_byte_reader_get_uint32_be(reader: *mut GstByteReader, val: *mut u32) -> gboolean;
    pub fn gst_byte_reader_get_uint32_le(reader: *mut GstByteReader, val: *mut u32) -> gboolean;
    pub fn gst_byte_reader_get_uint64_be(reader: *mut GstByteReader, val: *mut u64) -> gboolean;
    pub fn gst_byte_reader_get_uint64_le(reader: *mut GstByteReader, val: *mut u64) -> gboolean;
    pub fn gst_byte_reader_get_uint8(reader: *mut GstByteReader, val: *mut u8) -> gboolean;
    pub fn gst_byte_reader_init(reader: *mut GstByteReader, data: *mut u8, size: c_uint);
    pub fn gst_byte_reader_masked_scan_uint32(reader: *const GstByteReader, mask: u32, pattern: u32, offset: c_uint, size: c_uint) -> c_uint;
    #[cfg(feature = "v1_6")]
    pub fn gst_byte_reader_masked_scan_uint32_peek(reader: *const GstByteReader, mask: u32, pattern: u32, offset: c_uint, size: c_uint, value: *mut u32) -> c_uint;
    pub fn gst_byte_reader_peek_data(reader: *const GstByteReader, size: c_uint, val: *mut *mut u8) -> gboolean;
    pub fn gst_byte_reader_peek_float32_be(reader: *const GstByteReader, val: *mut c_float) -> gboolean;
    pub fn gst_byte_reader_peek_float32_le(reader: *const GstByteReader, val: *mut c_float) -> gboolean;
    pub fn gst_byte_reader_peek_float64_be(reader: *const GstByteReader, val: *mut c_double) -> gboolean;
    pub fn gst_byte_reader_peek_float64_le(reader: *const GstByteReader, val: *mut c_double) -> gboolean;
    pub fn gst_byte_reader_peek_int16_be(reader: *const GstByteReader, val: *mut i16) -> gboolean;
    pub fn gst_byte_reader_peek_int16_le(reader: *const GstByteReader, val: *mut i16) -> gboolean;
    pub fn gst_byte_reader_peek_int24_be(reader: *const GstByteReader, val: *mut i32) -> gboolean;
    pub fn gst_byte_reader_peek_int24_le(reader: *const GstByteReader, val: *mut i32) -> gboolean;
    pub fn gst_byte_reader_peek_int32_be(reader: *const GstByteReader, val: *mut i32) -> gboolean;
    pub fn gst_byte_reader_peek_int32_le(reader: *const GstByteReader, val: *mut i32) -> gboolean;
    pub fn gst_byte_reader_peek_int64_be(reader: *const GstByteReader, val: *mut i64) -> gboolean;
    pub fn gst_byte_reader_peek_int64_le(reader: *const GstByteReader, val: *mut i64) -> gboolean;
    pub fn gst_byte_reader_peek_int8(reader: *const GstByteReader, val: *mut i8) -> gboolean;
    pub fn gst_byte_reader_peek_string_utf8(reader: *const GstByteReader, str: *mut *mut c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_byte_reader_peek_sub_reader(reader: *mut GstByteReader, sub_reader: *mut GstByteReader, size: c_uint) -> gboolean;
    pub fn gst_byte_reader_peek_uint16_be(reader: *const GstByteReader, val: *mut u16) -> gboolean;
    pub fn gst_byte_reader_peek_uint16_le(reader: *const GstByteReader, val: *mut u16) -> gboolean;
    pub fn gst_byte_reader_peek_uint24_be(reader: *const GstByteReader, val: *mut u32) -> gboolean;
    pub fn gst_byte_reader_peek_uint24_le(reader: *const GstByteReader, val: *mut u32) -> gboolean;
    pub fn gst_byte_reader_peek_uint32_be(reader: *const GstByteReader, val: *mut u32) -> gboolean;
    pub fn gst_byte_reader_peek_uint32_le(reader: *const GstByteReader, val: *mut u32) -> gboolean;
    pub fn gst_byte_reader_peek_uint64_be(reader: *const GstByteReader, val: *mut u64) -> gboolean;
    pub fn gst_byte_reader_peek_uint64_le(reader: *const GstByteReader, val: *mut u64) -> gboolean;
    pub fn gst_byte_reader_peek_uint8(reader: *const GstByteReader, val: *mut u8) -> gboolean;
    pub fn gst_byte_reader_set_pos(reader: *mut GstByteReader, pos: c_uint) -> gboolean;
    pub fn gst_byte_reader_skip(reader: *mut GstByteReader, nbytes: c_uint) -> gboolean;
    pub fn gst_byte_reader_skip_string_utf16(reader: *mut GstByteReader) -> gboolean;
    pub fn gst_byte_reader_skip_string_utf32(reader: *mut GstByteReader) -> gboolean;
    pub fn gst_byte_reader_skip_string_utf8(reader: *mut GstByteReader) -> gboolean;
    pub fn gst_byte_reader_new(data: *mut u8, size: c_uint) -> *mut GstByteReader;

    //=========================================================================
    // GstByteWriter
    //=========================================================================
    pub fn gst_byte_writer_ensure_free_space(writer: *mut GstByteWriter, size: c_uint) -> gboolean;
    pub fn gst_byte_writer_fill(writer: *mut GstByteWriter, value: u8, size: c_uint) -> gboolean;
    pub fn gst_byte_writer_free(writer: *mut GstByteWriter);
    pub fn gst_byte_writer_free_and_get_buffer(writer: *mut GstByteWriter) -> *mut gst::GstBuffer;
    pub fn gst_byte_writer_free_and_get_data(writer: *mut GstByteWriter) -> *mut u8;
    pub fn gst_byte_writer_get_remaining(writer: *const GstByteWriter) -> c_uint;
    pub fn gst_byte_writer_init(writer: *mut GstByteWriter);
    pub fn gst_byte_writer_init_with_data(writer: *mut GstByteWriter, data: *mut u8, size: c_uint, initialized: gboolean);
    pub fn gst_byte_writer_init_with_size(writer: *mut GstByteWriter, size: c_uint, fixed: gboolean);
    pub fn gst_byte_writer_put_buffer(writer: *mut GstByteWriter, buffer: *mut gst::GstBuffer, offset: size_t, size: ssize_t) -> gboolean;
    pub fn gst_byte_writer_put_data(writer: *mut GstByteWriter, data: *mut u8, size: c_uint) -> gboolean;
    pub fn gst_byte_writer_put_float32_be(writer: *mut GstByteWriter, val: c_float) -> gboolean;
    pub fn gst_byte_writer_put_float32_le(writer: *mut GstByteWriter, val: c_float) -> gboolean;
    pub fn gst_byte_writer_put_float64_be(writer: *mut GstByteWriter, val: c_double) -> gboolean;
    pub fn gst_byte_writer_put_float64_le(writer: *mut GstByteWriter, val: c_double) -> gboolean;
    pub fn gst_byte_writer_put_int16_be(writer: *mut GstByteWriter, val: i16) -> gboolean;
    pub fn gst_byte_writer_put_int16_le(writer: *mut GstByteWriter, val: i16) -> gboolean;
    pub fn gst_byte_writer_put_int24_be(writer: *mut GstByteWriter, val: i32) -> gboolean;
    pub fn gst_byte_writer_put_int24_le(writer: *mut GstByteWriter, val: i32) -> gboolean;
    pub fn gst_byte_writer_put_int32_be(writer: *mut GstByteWriter, val: i32) -> gboolean;
    pub fn gst_byte_writer_put_int32_le(writer: *mut GstByteWriter, val: i32) -> gboolean;
    pub fn gst_byte_writer_put_int64_be(writer: *mut GstByteWriter, val: i64) -> gboolean;
    pub fn gst_byte_writer_put_int64_le(writer: *mut GstByteWriter, val: i64) -> gboolean;
    pub fn gst_byte_writer_put_int8(writer: *mut GstByteWriter, val: i8) -> gboolean;
    pub fn gst_byte_writer_put_string_utf16(writer: *mut GstByteWriter, data: *mut u16) -> gboolean;
    pub fn gst_byte_writer_put_string_utf32(writer: *mut GstByteWriter, data: *mut u32) -> gboolean;
    pub fn gst_byte_writer_put_string_utf8(writer: *mut GstByteWriter, data: *mut c_char) -> gboolean;
    pub fn gst_byte_writer_put_uint16_be(writer: *mut GstByteWriter, val: u16) -> gboolean;
    pub fn gst_byte_writer_put_uint16_le(writer: *mut GstByteWriter, val: u16) -> gboolean;
    pub fn gst_byte_writer_put_uint24_be(writer: *mut GstByteWriter, val: u32) -> gboolean;
    pub fn gst_byte_writer_put_uint24_le(writer: *mut GstByteWriter, val: u32) -> gboolean;
    pub fn gst_byte_writer_put_uint32_be(writer: *mut GstByteWriter, val: u32) -> gboolean;
    pub fn gst_byte_writer_put_uint32_le(writer: *mut GstByteWriter, val: u32) -> gboolean;
    pub fn gst_byte_writer_put_uint64_be(writer: *mut GstByteWriter, val: u64) -> gboolean;
    pub fn gst_byte_writer_put_uint64_le(writer: *mut GstByteWriter, val: u64) -> gboolean;
    pub fn gst_byte_writer_put_uint8(writer: *mut GstByteWriter, val: u8) -> gboolean;
    pub fn gst_byte_writer_reset(writer: *mut GstByteWriter);
    pub fn gst_byte_writer_reset_and_get_buffer(writer: *mut GstByteWriter) -> *mut gst::GstBuffer;
    pub fn gst_byte_writer_reset_and_get_data(writer: *mut GstByteWriter) -> *mut u8;
    pub fn gst_byte_writer_new() -> *mut GstByteWriter;
    pub fn gst_byte_writer_new_with_data(data: *mut u8, size: c_uint, initialized: gboolean) -> *mut GstByteWriter;
    pub fn gst_byte_writer_new_with_size(size: c_uint, fixed: gboolean) -> *mut GstByteWriter;

    //=========================================================================
    // GstFlowCombiner
    //=========================================================================
    pub fn gst_flow_combiner_get_type() -> GType;
    #[cfg(feature = "v1_4")]
    pub fn gst_flow_combiner_new() -> *mut GstFlowCombiner;
    #[cfg(feature = "v1_4")]
    pub fn gst_flow_combiner_add_pad(combiner: *mut GstFlowCombiner, pad: *mut gst::GstPad);
    #[cfg(feature = "v1_6")]
    pub fn gst_flow_combiner_clear(combiner: *mut GstFlowCombiner);
    #[cfg(feature = "v1_4")]
    pub fn gst_flow_combiner_free(combiner: *mut GstFlowCombiner);
    #[cfg(feature = "v1_4")]
    pub fn gst_flow_combiner_remove_pad(combiner: *mut GstFlowCombiner, pad: *mut gst::GstPad);
    #[cfg(feature = "v1_6")]
    pub fn gst_flow_combiner_reset(combiner: *mut GstFlowCombiner);
    #[cfg(feature = "v1_4")]
    pub fn gst_flow_combiner_update_flow(combiner: *mut GstFlowCombiner, fret: gst::GstFlowReturn) -> gst::GstFlowReturn;
    #[cfg(feature = "v1_6")]
    pub fn gst_flow_combiner_update_pad_flow(combiner: *mut GstFlowCombiner, pad: *mut gst::GstPad, fret: gst::GstFlowReturn) -> gst::GstFlowReturn;

    //=========================================================================
    // GstQueueArray
    //=========================================================================
    #[cfg(feature = "v1_2")]
    pub fn gst_queue_array_drop_element(array: *mut GstQueueArray, idx: c_uint) -> gpointer;
    #[cfg(feature = "v1_6")]
    pub fn gst_queue_array_drop_struct(array: *mut GstQueueArray, idx: c_uint, p_struct: gpointer) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_queue_array_find(array: *mut GstQueueArray, func: glib::GCompareFunc, data: gpointer) -> c_uint;
    #[cfg(feature = "v1_2")]
    pub fn gst_queue_array_free(array: *mut GstQueueArray);
    #[cfg(feature = "v1_2")]
    pub fn gst_queue_array_get_length(array: *mut GstQueueArray) -> c_uint;
    #[cfg(feature = "v1_2")]
    pub fn gst_queue_array_is_empty(array: *mut GstQueueArray) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_queue_array_peek_head(array: *mut GstQueueArray) -> gpointer;
    #[cfg(feature = "v1_6")]
    pub fn gst_queue_array_peek_head_struct(array: *mut GstQueueArray) -> gpointer;
    #[cfg(feature = "v1_2")]
    pub fn gst_queue_array_pop_head(array: *mut GstQueueArray) -> gpointer;
    #[cfg(feature = "v1_6")]
    pub fn gst_queue_array_pop_head_struct(array: *mut GstQueueArray) -> gpointer;
    #[cfg(feature = "v1_2")]
    pub fn gst_queue_array_push_tail(array: *mut GstQueueArray, data: gpointer);
    pub fn gst_queue_array_push_tail_struct(array: *mut GstQueueArray, p_struct: gpointer);
    #[cfg(feature = "v1_2")]
    pub fn gst_queue_array_new(initial_size: c_uint) -> *mut GstQueueArray;
    #[cfg(feature = "v1_6")]
    pub fn gst_queue_array_new_for_struct(struct_size: size_t, initial_size: c_uint) -> *mut GstQueueArray;

    //=========================================================================
    // GstAdapter
    //=========================================================================
    pub fn gst_adapter_get_type() -> GType;
    pub fn gst_adapter_new() -> *mut GstAdapter;
    pub fn gst_adapter_available(adapter: *mut GstAdapter) -> size_t;
    pub fn gst_adapter_available_fast(adapter: *mut GstAdapter) -> size_t;
    pub fn gst_adapter_clear(adapter: *mut GstAdapter);
    pub fn gst_adapter_copy(adapter: *mut GstAdapter, dest: gpointer, offset: size_t, size: size_t);
    #[cfg(feature = "v1_4")]
    pub fn gst_adapter_copy_bytes(adapter: *mut GstAdapter, offset: size_t, size: size_t) -> *mut glib::GBytes;
    pub fn gst_adapter_distance_from_discont(adapter: *mut GstAdapter) -> u64;
    #[cfg(feature = "v1_10")]
    pub fn gst_adapter_dts_at_discont(adapter: *mut GstAdapter) -> gst::GstClockTime;
    pub fn gst_adapter_flush(adapter: *mut GstAdapter, flush: size_t);
    #[cfg(feature = "v1_6")]
    pub fn gst_adapter_get_buffer(adapter: *mut GstAdapter, nbytes: size_t) -> *mut gst::GstBuffer;
    #[cfg(feature = "v1_6")]
    pub fn gst_adapter_get_buffer_fast(adapter: *mut GstAdapter, nbytes: size_t) -> *mut gst::GstBuffer;
    #[cfg(feature = "v1_6")]
    pub fn gst_adapter_get_buffer_list(adapter: *mut GstAdapter, nbytes: size_t) -> *mut gst::GstBufferList;
    #[cfg(feature = "v1_6")]
    pub fn gst_adapter_get_list(adapter: *mut GstAdapter, nbytes: size_t) -> *mut glib::GList;
    pub fn gst_adapter_map(adapter: *mut GstAdapter, size: size_t) -> gconstpointer;
    pub fn gst_adapter_masked_scan_uint32(adapter: *mut GstAdapter, mask: u32, pattern: u32, offset: size_t, size: size_t) -> ssize_t;
    pub fn gst_adapter_masked_scan_uint32_peek(adapter: *mut GstAdapter, mask: u32, pattern: u32, offset: size_t, size: size_t, value: *mut u32) -> ssize_t;
    #[cfg(feature = "v1_10")]
    pub fn gst_adapter_offset_at_discont(adapter: *mut GstAdapter) -> u64;
    pub fn gst_adapter_prev_dts(adapter: *mut GstAdapter, distance: *mut u64) -> gst::GstClockTime;
    #[cfg(feature = "v1_2")]
    pub fn gst_adapter_prev_dts_at_offset(adapter: *mut GstAdapter, offset: size_t, distance: *mut u64) -> gst::GstClockTime;
    #[cfg(feature = "v1_10")]
    pub fn gst_adapter_prev_offset(adapter: *mut GstAdapter, distance: *mut u64) -> u64;
    pub fn gst_adapter_prev_pts(adapter: *mut GstAdapter, distance: *mut u64) -> gst::GstClockTime;
    #[cfg(feature = "v1_2")]
    pub fn gst_adapter_prev_pts_at_offset(adapter: *mut GstAdapter, offset: size_t, distance: *mut u64) -> gst::GstClockTime;
    #[cfg(feature = "v1_10")]
    pub fn gst_adapter_pts_at_discont(adapter: *mut GstAdapter) -> gst::GstClockTime;
    pub fn gst_adapter_push(adapter: *mut GstAdapter, buf: *mut gst::GstBuffer);
    pub fn gst_adapter_take(adapter: *mut GstAdapter, nbytes: size_t) -> gpointer;
    pub fn gst_adapter_take_buffer(adapter: *mut GstAdapter, nbytes: size_t) -> *mut gst::GstBuffer;
    #[cfg(feature = "v1_2")]
    pub fn gst_adapter_take_buffer_fast(adapter: *mut GstAdapter, nbytes: size_t) -> *mut gst::GstBuffer;
    #[cfg(feature = "v1_6")]
    pub fn gst_adapter_take_buffer_list(adapter: *mut GstAdapter, nbytes: size_t) -> *mut gst::GstBufferList;
    pub fn gst_adapter_take_list(adapter: *mut GstAdapter, nbytes: size_t) -> *mut glib::GList;
    pub fn gst_adapter_unmap(adapter: *mut GstAdapter);

    //=========================================================================
    // GstBaseParse
    //=========================================================================
    pub fn gst_base_parse_get_type() -> GType;
    pub fn gst_base_parse_add_index_entry(parse: *mut GstBaseParse, offset: u64, ts: gst::GstClockTime, key: gboolean, force: gboolean) -> gboolean;
    pub fn gst_base_parse_convert_default(parse: *mut GstBaseParse, src_format: gst::GstFormat, src_value: i64, dest_format: gst::GstFormat, dest_value: *mut i64) -> gboolean;
    #[cfg(feature = "v1_12")]
    pub fn gst_base_parse_drain(parse: *mut GstBaseParse);
    pub fn gst_base_parse_finish_frame(parse: *mut GstBaseParse, frame: *mut GstBaseParseFrame, size: c_int) -> gst::GstFlowReturn;
    #[cfg(feature = "v1_6")]
    pub fn gst_base_parse_merge_tags(parse: *mut GstBaseParse, tags: *mut gst::GstTagList, mode: gst::GstTagMergeMode);
    pub fn gst_base_parse_push_frame(parse: *mut GstBaseParse, frame: *mut GstBaseParseFrame) -> gst::GstFlowReturn;
    pub fn gst_base_parse_set_average_bitrate(parse: *mut GstBaseParse, bitrate: c_uint);
    pub fn gst_base_parse_set_duration(parse: *mut GstBaseParse, fmt: gst::GstFormat, duration: i64, interval: c_int);
    pub fn gst_base_parse_set_frame_rate(parse: *mut GstBaseParse, fps_num: c_uint, fps_den: c_uint, lead_in: c_uint, lead_out: c_uint);
    pub fn gst_base_parse_set_has_timing_info(parse: *mut GstBaseParse, has_timing: gboolean);
    pub fn gst_base_parse_set_infer_ts(parse: *mut GstBaseParse, infer_ts: gboolean);
    pub fn gst_base_parse_set_latency(parse: *mut GstBaseParse, min_latency: gst::GstClockTime, max_latency: gst::GstClockTime);
    pub fn gst_base_parse_set_min_frame_size(parse: *mut GstBaseParse, min_size: c_uint);
    pub fn gst_base_parse_set_passthrough(parse: *mut GstBaseParse, passthrough: gboolean);
    pub fn gst_base_parse_set_pts_interpolation(parse: *mut GstBaseParse, pts_interpolate: gboolean);
    pub fn gst_base_parse_set_syncable(parse: *mut GstBaseParse, syncable: gboolean);
    #[cfg(feature = "v1_2")]
    pub fn gst_base_parse_set_ts_at_offset(parse: *mut GstBaseParse, offset: size_t);

    //=========================================================================
    // GstBaseSink
    //=========================================================================
    pub fn gst_base_sink_get_type() -> GType;
    pub fn gst_base_sink_do_preroll(sink: *mut GstBaseSink, obj: *mut gst::GstMiniObject) -> gst::GstFlowReturn;
    pub fn gst_base_sink_get_blocksize(sink: *mut GstBaseSink) -> c_uint;
    #[cfg(feature = "v1_12")]
    pub fn gst_base_sink_get_drop_out_of_segment(sink: *mut GstBaseSink) -> gboolean;
    pub fn gst_base_sink_get_last_sample(sink: *mut GstBaseSink) -> *mut gst::GstSample;
    pub fn gst_base_sink_get_latency(sink: *mut GstBaseSink) -> gst::GstClockTime;
    #[cfg(feature = "v1_2")]
    pub fn gst_base_sink_get_max_bitrate(sink: *mut GstBaseSink) -> u64;
    pub fn gst_base_sink_get_max_lateness(sink: *mut GstBaseSink) -> i64;
    pub fn gst_base_sink_get_render_delay(sink: *mut GstBaseSink) -> gst::GstClockTime;
    pub fn gst_base_sink_get_sync(sink: *mut GstBaseSink) -> gboolean;
    pub fn gst_base_sink_get_throttle_time(sink: *mut GstBaseSink) -> u64;
    pub fn gst_base_sink_get_ts_offset(sink: *mut GstBaseSink) -> gst::GstClockTimeDiff;
    pub fn gst_base_sink_is_async_enabled(sink: *mut GstBaseSink) -> gboolean;
    pub fn gst_base_sink_is_last_sample_enabled(sink: *mut GstBaseSink) -> gboolean;
    pub fn gst_base_sink_is_qos_enabled(sink: *mut GstBaseSink) -> gboolean;
    pub fn gst_base_sink_query_latency(sink: *mut GstBaseSink, live: *mut gboolean, upstream_live: *mut gboolean, min_latency: *mut gst::GstClockTime, max_latency: *mut gst::GstClockTime) -> gboolean;
    pub fn gst_base_sink_set_async_enabled(sink: *mut GstBaseSink, enabled: gboolean);
    pub fn gst_base_sink_set_blocksize(sink: *mut GstBaseSink, blocksize: c_uint);
    #[cfg(feature = "v1_12")]
    pub fn gst_base_sink_set_drop_out_of_segment(sink: *mut GstBaseSink, drop_out_of_segment: gboolean);
    pub fn gst_base_sink_set_last_sample_enabled(sink: *mut GstBaseSink, enabled: gboolean);
    #[cfg(feature = "v1_2")]
    pub fn gst_base_sink_set_max_bitrate(sink: *mut GstBaseSink, max_bitrate: u64);
    pub fn gst_base_sink_set_max_lateness(sink: *mut GstBaseSink, max_lateness: i64);
    pub fn gst_base_sink_set_qos_enabled(sink: *mut GstBaseSink, enabled: gboolean);
    pub fn gst_base_sink_set_render_delay(sink: *mut GstBaseSink, delay: gst::GstClockTime);
    pub fn gst_base_sink_set_sync(sink: *mut GstBaseSink, sync: gboolean);
    pub fn gst_base_sink_set_throttle_time(sink: *mut GstBaseSink, throttle: u64);
    pub fn gst_base_sink_set_ts_offset(sink: *mut GstBaseSink, offset: gst::GstClockTimeDiff);
    pub fn gst_base_sink_wait(sink: *mut GstBaseSink, time: gst::GstClockTime, jitter: *mut gst::GstClockTimeDiff) -> gst::GstFlowReturn;
    pub fn gst_base_sink_wait_clock(sink: *mut GstBaseSink, time: gst::GstClockTime, jitter: *mut gst::GstClockTimeDiff) -> gst::GstClockReturn;
    pub fn gst_base_sink_wait_preroll(sink: *mut GstBaseSink) -> gst::GstFlowReturn;

    //=========================================================================
    // GstBaseSrc
    //=========================================================================
    pub fn gst_base_src_get_type() -> GType;
    pub fn gst_base_src_get_allocator(src: *mut GstBaseSrc, allocator: *mut *mut gst::GstAllocator, params: *mut gst::GstAllocationParams);
    pub fn gst_base_src_get_blocksize(src: *mut GstBaseSrc) -> c_uint;
    pub fn gst_base_src_get_buffer_pool(src: *mut GstBaseSrc) -> *mut gst::GstBufferPool;
    pub fn gst_base_src_get_do_timestamp(src: *mut GstBaseSrc) -> gboolean;
    pub fn gst_base_src_is_async(src: *mut GstBaseSrc) -> gboolean;
    pub fn gst_base_src_is_live(src: *mut GstBaseSrc) -> gboolean;
    pub fn gst_base_src_new_seamless_segment(src: *mut GstBaseSrc, start: i64, stop: i64, time: i64) -> gboolean;
    pub fn gst_base_src_query_latency(src: *mut GstBaseSrc, live: *mut gboolean, min_latency: *mut gst::GstClockTime, max_latency: *mut gst::GstClockTime) -> gboolean;
    pub fn gst_base_src_set_async(src: *mut GstBaseSrc, async: gboolean);
    #[cfg(feature = "v1_4")]
    pub fn gst_base_src_set_automatic_eos(src: *mut GstBaseSrc, automatic_eos: gboolean);
    pub fn gst_base_src_set_blocksize(src: *mut GstBaseSrc, blocksize: c_uint);
    pub fn gst_base_src_set_caps(src: *mut GstBaseSrc, caps: *mut gst::GstCaps) -> gboolean;
    pub fn gst_base_src_set_do_timestamp(src: *mut GstBaseSrc, timestamp: gboolean);
    pub fn gst_base_src_set_dynamic_size(src: *mut GstBaseSrc, dynamic: gboolean);
    pub fn gst_base_src_set_format(src: *mut GstBaseSrc, format: gst::GstFormat);
    pub fn gst_base_src_set_live(src: *mut GstBaseSrc, live: gboolean);
    pub fn gst_base_src_start_complete(basesrc: *mut GstBaseSrc, ret: gst::GstFlowReturn);
    pub fn gst_base_src_start_wait(basesrc: *mut GstBaseSrc) -> gst::GstFlowReturn;
    pub fn gst_base_src_wait_playing(src: *mut GstBaseSrc) -> gst::GstFlowReturn;

    //=========================================================================
    // GstBaseTransform
    //=========================================================================
    pub fn gst_base_transform_get_type() -> GType;
    pub fn gst_base_transform_get_allocator(trans: *mut GstBaseTransform, allocator: *mut *mut gst::GstAllocator, params: *mut gst::GstAllocationParams);
    pub fn gst_base_transform_get_buffer_pool(trans: *mut GstBaseTransform) -> *mut gst::GstBufferPool;
    pub fn gst_base_transform_is_in_place(trans: *mut GstBaseTransform) -> gboolean;
    pub fn gst_base_transform_is_passthrough(trans: *mut GstBaseTransform) -> gboolean;
    pub fn gst_base_transform_is_qos_enabled(trans: *mut GstBaseTransform) -> gboolean;
    pub fn gst_base_transform_reconfigure_sink(trans: *mut GstBaseTransform);
    pub fn gst_base_transform_reconfigure_src(trans: *mut GstBaseTransform);
    pub fn gst_base_transform_set_gap_aware(trans: *mut GstBaseTransform, gap_aware: gboolean);
    pub fn gst_base_transform_set_in_place(trans: *mut GstBaseTransform, in_place: gboolean);
    pub fn gst_base_transform_set_passthrough(trans: *mut GstBaseTransform, passthrough: gboolean);
    #[cfg(feature = "v1_0_1")]
    pub fn gst_base_transform_set_prefer_passthrough(trans: *mut GstBaseTransform, prefer_passthrough: gboolean);
    pub fn gst_base_transform_set_qos_enabled(trans: *mut GstBaseTransform, enabled: gboolean);
    pub fn gst_base_transform_update_qos(trans: *mut GstBaseTransform, proportion: c_double, diff: gst::GstClockTimeDiff, timestamp: gst::GstClockTime);
    #[cfg(feature = "v1_6")]
    pub fn gst_base_transform_update_src_caps(trans: *mut GstBaseTransform, updated_caps: *mut gst::GstCaps) -> gboolean;

    //=========================================================================
    // GstCollectPads
    //=========================================================================
    pub fn gst_collect_pads_get_type() -> GType;
    pub fn gst_collect_pads_new() -> *mut GstCollectPads;
    pub fn gst_collect_pads_add_pad(pads: *mut GstCollectPads, pad: *mut gst::GstPad, size: c_uint, destroy_notify: GstCollectDataDestroyNotify, lock: gboolean) -> *mut GstCollectData;
    pub fn gst_collect_pads_available(pads: *mut GstCollectPads) -> c_uint;
    pub fn gst_collect_pads_clip_running_time(pads: *mut GstCollectPads, cdata: *mut GstCollectData, buf: *mut gst::GstBuffer, outbuf: *mut *mut gst::GstBuffer, user_data: gpointer) -> gst::GstFlowReturn;
    pub fn gst_collect_pads_event_default(pads: *mut GstCollectPads, data: *mut GstCollectData, event: *mut gst::GstEvent, discard: gboolean) -> gboolean;
    pub fn gst_collect_pads_flush(pads: *mut GstCollectPads, data: *mut GstCollectData, size: c_uint) -> c_uint;
    pub fn gst_collect_pads_peek(pads: *mut GstCollectPads, data: *mut GstCollectData) -> *mut gst::GstBuffer;
    pub fn gst_collect_pads_pop(pads: *mut GstCollectPads, data: *mut GstCollectData) -> *mut gst::GstBuffer;
    pub fn gst_collect_pads_query_default(pads: *mut GstCollectPads, data: *mut GstCollectData, query: *mut gst::GstQuery, discard: gboolean) -> gboolean;
    pub fn gst_collect_pads_read_buffer(pads: *mut GstCollectPads, data: *mut GstCollectData, size: c_uint) -> *mut gst::GstBuffer;
    pub fn gst_collect_pads_remove_pad(pads: *mut GstCollectPads, pad: *mut gst::GstPad) -> gboolean;
    pub fn gst_collect_pads_set_buffer_function(pads: *mut GstCollectPads, func: GstCollectPadsBufferFunction, user_data: gpointer);
    pub fn gst_collect_pads_set_clip_function(pads: *mut GstCollectPads, clipfunc: GstCollectPadsClipFunction, user_data: gpointer);
    pub fn gst_collect_pads_set_compare_function(pads: *mut GstCollectPads, func: GstCollectPadsCompareFunction, user_data: gpointer);
    pub fn gst_collect_pads_set_event_function(pads: *mut GstCollectPads, func: GstCollectPadsEventFunction, user_data: gpointer);
    #[cfg(feature = "v1_4")]
    pub fn gst_collect_pads_set_flush_function(pads: *mut GstCollectPads, func: GstCollectPadsFlushFunction, user_data: gpointer);
    pub fn gst_collect_pads_set_flushing(pads: *mut GstCollectPads, flushing: gboolean);
    pub fn gst_collect_pads_set_function(pads: *mut GstCollectPads, func: GstCollectPadsFunction, user_data: gpointer);
    pub fn gst_collect_pads_set_query_function(pads: *mut GstCollectPads, func: GstCollectPadsQueryFunction, user_data: gpointer);
    pub fn gst_collect_pads_set_waiting(pads: *mut GstCollectPads, data: *mut GstCollectData, waiting: gboolean);
    #[cfg(feature = "v1_4")]
    pub fn gst_collect_pads_src_event_default(pads: *mut GstCollectPads, pad: *mut gst::GstPad, event: *mut gst::GstEvent) -> gboolean;
    pub fn gst_collect_pads_start(pads: *mut GstCollectPads);
    pub fn gst_collect_pads_stop(pads: *mut GstCollectPads);
    pub fn gst_collect_pads_take_buffer(pads: *mut GstCollectPads, data: *mut GstCollectData, size: c_uint) -> *mut gst::GstBuffer;

    //=========================================================================
    // GstDataQueue
    //=========================================================================
    pub fn gst_data_queue_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_new(checkfull: GstDataQueueCheckFullFunction, fullcallback: GstDataQueueFullCallback, emptycallback: GstDataQueueEmptyCallback, checkdata: gpointer) -> *mut GstDataQueue;
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_drop_head(queue: *mut GstDataQueue, type_: GType) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_flush(queue: *mut GstDataQueue);
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_get_level(queue: *mut GstDataQueue, level: *mut GstDataQueueSize);
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_is_empty(queue: *mut GstDataQueue) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_is_full(queue: *mut GstDataQueue) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_limits_changed(queue: *mut GstDataQueue);
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_peek(queue: *mut GstDataQueue, item: *mut *mut GstDataQueueItem) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_pop(queue: *mut GstDataQueue, item: *mut *mut GstDataQueueItem) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_push(queue: *mut GstDataQueue, item: *mut GstDataQueueItem) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_push_force(queue: *mut GstDataQueue, item: *mut GstDataQueueItem) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_data_queue_set_flushing(queue: *mut GstDataQueue, flushing: gboolean);

    //=========================================================================
    // GstPushSrc
    //=========================================================================
    pub fn gst_push_src_get_type() -> GType;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gst_type_find_helper(src: *mut gst::GstPad, size: u64) -> *mut gst::GstCaps;
    pub fn gst_type_find_helper_for_buffer(obj: *mut gst::GstObject, buf: *mut gst::GstBuffer, prob: *mut gst::GstTypeFindProbability) -> *mut gst::GstCaps;
    pub fn gst_type_find_helper_for_data(obj: *mut gst::GstObject, data: *const u8, size: size_t, prob: *mut gst::GstTypeFindProbability) -> *mut gst::GstCaps;
    pub fn gst_type_find_helper_for_extension(obj: *mut gst::GstObject, extension: *const c_char) -> *mut gst::GstCaps;
    pub fn gst_type_find_helper_get_range(obj: *mut gst::GstObject, parent: *mut gst::GstObject, func: GstTypeFindHelperGetRangeFunction, size: u64, extension: *const c_char, prob: *mut gst::GstTypeFindProbability) -> *mut gst::GstCaps;

}
