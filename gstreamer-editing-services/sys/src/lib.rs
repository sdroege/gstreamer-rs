// Generated by gir (https://github.com/gtk-rs/gir @ 78e3d3c22343)
// from gir-files (https://github.com/gtk-rs/gir-files @ 3ff4d3275258)
// from gst-gir-files (https://gitlab.freedesktop.org/gstreamer/gir-files-rs.git @ 233e3205cb17)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal,
    clippy::upper_case_acronyms
)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]

#[allow(unused_imports)]
use libc::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
    intptr_t, size_t, ssize_t, uintptr_t, FILE,
};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Aliases
pub type GESFrameNumber = i64;

// Enums
pub type GESAssetLoadingReturn = c_int;
pub const GES_ASSET_LOADING_ERROR: GESAssetLoadingReturn = 0;
pub const GES_ASSET_LOADING_ASYNC: GESAssetLoadingReturn = 1;
pub const GES_ASSET_LOADING_OK: GESAssetLoadingReturn = 2;

pub type GESChildrenControlMode = c_int;
pub const GES_CHILDREN_UPDATE: GESChildrenControlMode = 0;
pub const GES_CHILDREN_IGNORE_NOTIFIES: GESChildrenControlMode = 1;
pub const GES_CHILDREN_UPDATE_OFFSETS: GESChildrenControlMode = 2;
pub const GES_CHILDREN_UPDATE_ALL_VALUES: GESChildrenControlMode = 3;
pub const GES_CHILDREN_LAST: GESChildrenControlMode = 4;

pub type GESEdge = c_int;
pub const GES_EDGE_START: GESEdge = 0;
pub const GES_EDGE_END: GESEdge = 1;
pub const GES_EDGE_NONE: GESEdge = 2;

pub type GESEditMode = c_int;
pub const GES_EDIT_MODE_NORMAL: GESEditMode = 0;
pub const GES_EDIT_MODE_RIPPLE: GESEditMode = 1;
pub const GES_EDIT_MODE_ROLL: GESEditMode = 2;
pub const GES_EDIT_MODE_TRIM: GESEditMode = 3;
pub const GES_EDIT_MODE_SLIDE: GESEditMode = 4;

pub type GESError = c_int;
pub const GES_ERROR_ASSET_WRONG_ID: GESError = 0;
pub const GES_ERROR_ASSET_LOADING: GESError = 1;
pub const GES_ERROR_FORMATTER_MALFORMED_INPUT_FILE: GESError = 2;
pub const GES_ERROR_INVALID_FRAME_NUMBER: GESError = 3;
pub const GES_ERROR_NEGATIVE_LAYER: GESError = 4;
pub const GES_ERROR_NEGATIVE_TIME: GESError = 5;
pub const GES_ERROR_NOT_ENOUGH_INTERNAL_CONTENT: GESError = 6;
pub const GES_ERROR_INVALID_OVERLAP_IN_TRACK: GESError = 7;
pub const GES_ERROR_INVALID_EFFECT_BIN_DESCRIPTION: GESError = 8;

pub type GESTextHAlign = c_int;
pub const GES_TEXT_HALIGN_LEFT: GESTextHAlign = 0;
pub const GES_TEXT_HALIGN_CENTER: GESTextHAlign = 1;
pub const GES_TEXT_HALIGN_RIGHT: GESTextHAlign = 2;
pub const GES_TEXT_HALIGN_POSITION: GESTextHAlign = 4;
pub const GES_TEXT_HALIGN_ABSOLUTE: GESTextHAlign = 5;

pub type GESTextVAlign = c_int;
pub const GES_TEXT_VALIGN_BASELINE: GESTextVAlign = 0;
pub const GES_TEXT_VALIGN_BOTTOM: GESTextVAlign = 1;
pub const GES_TEXT_VALIGN_TOP: GESTextVAlign = 2;
pub const GES_TEXT_VALIGN_POSITION: GESTextVAlign = 3;
pub const GES_TEXT_VALIGN_CENTER: GESTextVAlign = 4;
pub const GES_TEXT_VALIGN_ABSOLUTE: GESTextVAlign = 5;

pub type GESVideoStandardTransitionType = c_int;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_NONE: GESVideoStandardTransitionType = 0;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BAR_WIPE_LR: GESVideoStandardTransitionType = 1;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BAR_WIPE_TB: GESVideoStandardTransitionType = 2;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_TL: GESVideoStandardTransitionType = 3;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_TR: GESVideoStandardTransitionType = 4;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_BR: GESVideoStandardTransitionType = 5;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_BL: GESVideoStandardTransitionType = 6;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_FOUR_BOX_WIPE_CI: GESVideoStandardTransitionType = 7;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_FOUR_BOX_WIPE_CO: GESVideoStandardTransitionType = 8;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNDOOR_V: GESVideoStandardTransitionType = 21;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNDOOR_H: GESVideoStandardTransitionType = 22;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_TC: GESVideoStandardTransitionType = 23;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_RC: GESVideoStandardTransitionType = 24;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_BC: GESVideoStandardTransitionType = 25;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BOX_WIPE_LC: GESVideoStandardTransitionType = 26;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DIAGONAL_TL: GESVideoStandardTransitionType = 41;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DIAGONAL_TR: GESVideoStandardTransitionType = 42;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BOWTIE_V: GESVideoStandardTransitionType = 43;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BOWTIE_H: GESVideoStandardTransitionType = 44;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNDOOR_DBL: GESVideoStandardTransitionType = 45;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNDOOR_DTL: GESVideoStandardTransitionType = 46;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_MISC_DIAGONAL_DBD: GESVideoStandardTransitionType = 47;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_MISC_DIAGONAL_DD: GESVideoStandardTransitionType = 48;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_VEE_D: GESVideoStandardTransitionType = 61;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_VEE_L: GESVideoStandardTransitionType = 62;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_VEE_U: GESVideoStandardTransitionType = 63;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_VEE_R: GESVideoStandardTransitionType = 64;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNVEE_D: GESVideoStandardTransitionType = 65;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNVEE_L: GESVideoStandardTransitionType = 66;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNVEE_U: GESVideoStandardTransitionType = 67;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_BARNVEE_R: GESVideoStandardTransitionType = 68;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_IRIS_RECT: GESVideoStandardTransitionType = 101;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_CLOCK_CW12: GESVideoStandardTransitionType = 201;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_CLOCK_CW3: GESVideoStandardTransitionType = 202;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_CLOCK_CW6: GESVideoStandardTransitionType = 203;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_CLOCK_CW9: GESVideoStandardTransitionType = 204;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_PINWHEEL_TBV: GESVideoStandardTransitionType = 205;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_PINWHEEL_TBH: GESVideoStandardTransitionType = 206;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_PINWHEEL_FB: GESVideoStandardTransitionType = 207;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_CT: GESVideoStandardTransitionType = 211;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_CR: GESVideoStandardTransitionType = 212;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLEFAN_FOV: GESVideoStandardTransitionType = 213;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLEFAN_FOH: GESVideoStandardTransitionType = 214;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWT: GESVideoStandardTransitionType = 221;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWR: GESVideoStandardTransitionType = 222;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWB: GESVideoStandardTransitionType = 223;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWL: GESVideoStandardTransitionType = 224;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_PV: GESVideoStandardTransitionType = 225;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_PD: GESVideoStandardTransitionType = 226;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_OV: GESVideoStandardTransitionType = 227;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_OH: GESVideoStandardTransitionType = 228;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_T: GESVideoStandardTransitionType = 231;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_R: GESVideoStandardTransitionType = 232;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_B: GESVideoStandardTransitionType = 233;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_FAN_L: GESVideoStandardTransitionType = 234;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLEFAN_FIV: GESVideoStandardTransitionType = 235;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLEFAN_FIH: GESVideoStandardTransitionType = 236;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWTL: GESVideoStandardTransitionType = 241;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWBL: GESVideoStandardTransitionType = 242;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWBR: GESVideoStandardTransitionType = 243;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SINGLESWEEP_CWTR: GESVideoStandardTransitionType = 244;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_PDTL: GESVideoStandardTransitionType = 245;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_DOUBLESWEEP_PDBL: GESVideoStandardTransitionType = 246;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SALOONDOOR_T: GESVideoStandardTransitionType = 251;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SALOONDOOR_L: GESVideoStandardTransitionType = 252;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SALOONDOOR_B: GESVideoStandardTransitionType = 253;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_SALOONDOOR_R: GESVideoStandardTransitionType = 254;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_WINDSHIELD_R: GESVideoStandardTransitionType = 261;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_WINDSHIELD_U: GESVideoStandardTransitionType = 262;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_WINDSHIELD_V: GESVideoStandardTransitionType = 263;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_WINDSHIELD_H: GESVideoStandardTransitionType = 264;
pub const GES_VIDEO_STANDARD_TRANSITION_TYPE_CROSSFADE: GESVideoStandardTransitionType = 512;

pub type GESVideoTestPattern = c_int;
pub const GES_VIDEO_TEST_PATTERN_SMPTE: GESVideoTestPattern = 0;
pub const GES_VIDEO_TEST_PATTERN_SNOW: GESVideoTestPattern = 1;
pub const GES_VIDEO_TEST_PATTERN_BLACK: GESVideoTestPattern = 2;
pub const GES_VIDEO_TEST_PATTERN_WHITE: GESVideoTestPattern = 3;
pub const GES_VIDEO_TEST_PATTERN_RED: GESVideoTestPattern = 4;
pub const GES_VIDEO_TEST_PATTERN_GREEN: GESVideoTestPattern = 5;
pub const GES_VIDEO_TEST_PATTERN_BLUE: GESVideoTestPattern = 6;
pub const GES_VIDEO_TEST_PATTERN_CHECKERS1: GESVideoTestPattern = 7;
pub const GES_VIDEO_TEST_PATTERN_CHECKERS2: GESVideoTestPattern = 8;
pub const GES_VIDEO_TEST_PATTERN_CHECKERS4: GESVideoTestPattern = 9;
pub const GES_VIDEO_TEST_PATTERN_CHECKERS8: GESVideoTestPattern = 10;
pub const GES_VIDEO_TEST_PATTERN_CIRCULAR: GESVideoTestPattern = 11;
pub const GES_VIDEO_TEST_PATTERN_BLINK: GESVideoTestPattern = 12;
pub const GES_VIDEO_TEST_PATTERN_SMPTE75: GESVideoTestPattern = 13;
pub const GES_VIDEO_TEST_ZONE_PLATE: GESVideoTestPattern = 14;
pub const GES_VIDEO_TEST_GAMUT: GESVideoTestPattern = 15;
pub const GES_VIDEO_TEST_CHROMA_ZONE_PLATE: GESVideoTestPattern = 16;
pub const GES_VIDEO_TEST_PATTERN_SOLID: GESVideoTestPattern = 17;

// Constants
pub const GES_FRAME_NUMBER_NONE: i64 = 9223372036854775807;
pub const GES_META_DESCRIPTION: *const c_char = b"description\0" as *const u8 as *const c_char;
pub const GES_META_FORMATTER_EXTENSION: *const c_char =
    b"extension\0" as *const u8 as *const c_char;
pub const GES_META_FORMATTER_MIMETYPE: *const c_char = b"mimetype\0" as *const u8 as *const c_char;
pub const GES_META_FORMATTER_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const GES_META_FORMATTER_RANK: *const c_char = b"rank\0" as *const u8 as *const c_char;
pub const GES_META_FORMATTER_VERSION: *const c_char = b"version\0" as *const u8 as *const c_char;
pub const GES_META_FORMAT_VERSION: *const c_char =
    b"format-version\0" as *const u8 as *const c_char;
pub const GES_META_MARKER_COLOR: *const c_char = b"marker-color\0" as *const u8 as *const c_char;
pub const GES_META_VOLUME: *const c_char = b"volume\0" as *const u8 as *const c_char;
pub const GES_META_VOLUME_DEFAULT: c_double = 1.000000;
pub const GES_MULTI_FILE_URI_PREFIX: *const c_char =
    b"multifile://\0" as *const u8 as *const c_char;
pub const GES_PADDING: c_int = 4;
pub const GES_PADDING_LARGE: c_int = 20;
pub const GES_TIMELINE_ELEMENT_NO_LAYER_PRIORITY: u32 = 4294967295;
pub const GES_VERSION_MAJOR: c_int = 1;
pub const GES_VERSION_MICRO: c_int = 0;
pub const GES_VERSION_MINOR: c_int = 20;
pub const GES_VERSION_NANO: c_int = 0;

// Flags
pub type GESMarkerFlags = c_uint;
pub const GES_MARKER_FLAG_NONE: GESMarkerFlags = 0;
pub const GES_MARKER_FLAG_SNAPPABLE: GESMarkerFlags = 1;

pub type GESMetaFlag = c_uint;
pub const GES_META_READABLE: GESMetaFlag = 1;
pub const GES_META_WRITABLE: GESMetaFlag = 2;
pub const GES_META_READ_WRITE: GESMetaFlag = 3;

pub type GESPipelineFlags = c_uint;
pub const GES_PIPELINE_MODE_PREVIEW_AUDIO: GESPipelineFlags = 1;
pub const GES_PIPELINE_MODE_PREVIEW_VIDEO: GESPipelineFlags = 2;
pub const GES_PIPELINE_MODE_PREVIEW: GESPipelineFlags = 3;
pub const GES_PIPELINE_MODE_RENDER: GESPipelineFlags = 4;
pub const GES_PIPELINE_MODE_SMART_RENDER: GESPipelineFlags = 8;

pub type GESTrackType = c_uint;
pub const GES_TRACK_TYPE_UNKNOWN: GESTrackType = 1;
pub const GES_TRACK_TYPE_AUDIO: GESTrackType = 2;
pub const GES_TRACK_TYPE_VIDEO: GESTrackType = 4;
pub const GES_TRACK_TYPE_TEXT: GESTrackType = 8;
pub const GES_TRACK_TYPE_CUSTOM: GESTrackType = 16;

// Unions
#[derive(Copy, Clone)]
#[repr(C)]
pub union GESClipClass_ABI {
    pub _ges_reserved: [gpointer; 20],
    pub abi: GESClipClass_ABI_abi,
}

impl ::std::fmt::Debug for GESClipClass_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESClipClass_ABI @ {:p}", self))
            .field("_ges_reserved", unsafe { &self._ges_reserved })
            .field("abi", unsafe { &self.abi })
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub union GESTrackElementClass_ABI {
    pub _ges_reserved: [gpointer; 20],
    pub abi: GESTrackElementClass_ABI_abi,
}

impl ::std::fmt::Debug for GESTrackElementClass_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTrackElementClass_ABI @ {:p}", self))
            .field("_ges_reserved", unsafe { &self._ges_reserved })
            .field("abi", unsafe { &self.abi })
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub union GESVideoSourceClass_ABI {
    pub _ges_reserved: [gpointer; 4],
    pub abi: GESVideoSourceClass_ABI_abi,
}

impl ::std::fmt::Debug for GESVideoSourceClass_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoSourceClass_ABI @ {:p}", self))
            .field("_ges_reserved", unsafe { &self._ges_reserved })
            .field("abi", unsafe { &self.abi })
            .finish()
    }
}

// Callbacks
pub type GESBaseEffectTimeTranslationFunc = Option<
    unsafe extern "C" fn(
        *mut GESBaseEffect,
        gst::GstClockTime,
        *mut glib::GHashTable,
        gpointer,
    ) -> gst::GstClockTime,
>;
pub type GESCreateElementForGapFunc =
    Option<unsafe extern "C" fn(*mut GESTrack) -> *mut gst::GstElement>;
pub type GESCreateTrackElementFunc =
    Option<unsafe extern "C" fn(*mut GESClip, GESTrackType) -> *mut GESTrackElement>;
pub type GESCreateTrackElementsFunc =
    Option<unsafe extern "C" fn(*mut GESClip, GESTrackType) -> *mut glib::GList>;
pub type GESExtractableCheckId =
    Option<unsafe extern "C" fn(GType, *const c_char, *mut *mut glib::GError) -> *mut c_char>;
pub type GESFillTrackElementFunc = Option<
    unsafe extern "C" fn(*mut GESClip, *mut GESTrackElement, *mut gst::GstElement) -> gboolean,
>;
pub type GESFormatterCanLoadURIMethod = Option<
    unsafe extern "C" fn(*mut GESFormatter, *const c_char, *mut *mut glib::GError) -> gboolean,
>;
pub type GESFormatterLoadFromURIMethod = Option<
    unsafe extern "C" fn(
        *mut GESFormatter,
        *mut GESTimeline,
        *const c_char,
        *mut *mut glib::GError,
    ) -> gboolean,
>;
pub type GESFormatterSaveToURIMethod = Option<
    unsafe extern "C" fn(
        *mut GESFormatter,
        *mut GESTimeline,
        *const c_char,
        gboolean,
        *mut *mut glib::GError,
    ) -> gboolean,
>;
pub type GESMetaForeachFunc = Option<
    unsafe extern "C" fn(*const GESMetaContainer, *const c_char, *const gobject::GValue, gpointer),
>;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAssetClass {
    pub parent: gobject::GObjectClass,
    pub start_loading: Option<
        unsafe extern "C" fn(*mut GESAsset, *mut *mut glib::GError) -> GESAssetLoadingReturn,
    >,
    pub extract:
        Option<unsafe extern "C" fn(*mut GESAsset, *mut *mut glib::GError) -> *mut GESExtractable>,
    pub inform_proxy: Option<unsafe extern "C" fn(*mut GESAsset, *const c_char)>,
    pub proxied: Option<unsafe extern "C" fn(*mut GESAsset, *mut GESAsset)>,
    pub request_id_update: Option<
        unsafe extern "C" fn(*mut GESAsset, *mut *mut c_char, *mut glib::GError) -> gboolean,
    >,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAssetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAssetClass @ {:p}", self))
            .field("parent", &self.parent)
            .field("start_loading", &self.start_loading)
            .field("extract", &self.extract)
            .field("inform_proxy", &self.inform_proxy)
            .field("proxied", &self.proxied)
            .field("request_id_update", &self.request_id_update)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESAssetPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESAssetPrivate = *mut _GESAssetPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAudioSourceClass {
    pub parent_class: GESSourceClass,
    pub create_source: Option<unsafe extern "C" fn(*mut GESTrackElement) -> *mut gst::GstElement>,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAudioSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAudioSourceClass @ {:p}", self))
            .field("create_source", &self.create_source)
            .finish()
    }
}

#[repr(C)]
pub struct _GESAudioSourcePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESAudioSourcePrivate = *mut _GESAudioSourcePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAudioTestSourceClass {
    pub parent_class: GESAudioSourceClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAudioTestSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAudioTestSourceClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESAudioTestSourcePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESAudioTestSourcePrivate = *mut _GESAudioTestSourcePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAudioTrackClass {
    pub parent_class: GESTrackClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAudioTrackClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAudioTrackClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESAudioTrackPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESAudioTrackPrivate = *mut _GESAudioTrackPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAudioTransitionClass {
    pub parent_class: GESTransitionClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAudioTransitionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAudioTransitionClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESAudioTransitionPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESAudioTransitionPrivate = *mut _GESAudioTransitionPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAudioUriSourceClass {
    pub parent_class: GESAudioSourceClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAudioUriSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAudioUriSourceClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESAudioUriSourcePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESAudioUriSourcePrivate = *mut _GESAudioUriSourcePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESBaseEffectClass {
    pub parent_class: GESOperationClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESBaseEffectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESBaseEffectClass @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESBaseEffectClipClass {
    pub parent_class: GESOperationClipClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESBaseEffectClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESBaseEffectClipClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESBaseEffectClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESBaseEffectClipPrivate = *mut _GESBaseEffectClipPrivate;

#[repr(C)]
pub struct _GESBaseEffectPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESBaseEffectPrivate = *mut _GESBaseEffectPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESBaseTransitionClipClass {
    pub parent_class: GESOperationClipClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESBaseTransitionClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESBaseTransitionClipClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESBaseTransitionClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESBaseTransitionClipPrivate = *mut _GESBaseTransitionClipPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESBaseXmlFormatterClass {
    pub parent: GESFormatterClass,
    pub content_parser: glib::GMarkupParser,
    pub save: Option<
        unsafe extern "C" fn(
            *mut GESFormatter,
            *mut GESTimeline,
            *mut *mut glib::GError,
        ) -> *mut glib::GString,
    >,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESBaseXmlFormatterClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESBaseXmlFormatterClass @ {:p}", self))
            .field("parent", &self.parent)
            .field("content_parser", &self.content_parser)
            .field("save", &self.save)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESBaseXmlFormatterPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESBaseXmlFormatterPrivate = *mut _GESBaseXmlFormatterPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESClipAssetClass {
    pub parent: GESAssetClass,
    pub get_natural_framerate:
        Option<unsafe extern "C" fn(*mut GESClipAsset, *mut c_int, *mut c_int) -> gboolean>,
    pub _ges_reserved: [gpointer; 3],
}

impl ::std::fmt::Debug for GESClipAssetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESClipAssetClass @ {:p}", self))
            .field("parent", &self.parent)
            .field("get_natural_framerate", &self.get_natural_framerate)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESClipAssetPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESClipAssetPrivate = *mut _GESClipAssetPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESClipClass {
    pub parent_class: GESContainerClass,
    pub create_track_element: GESCreateTrackElementFunc,
    pub create_track_elements: GESCreateTrackElementsFunc,
    pub ABI: GESClipClass_ABI,
}

impl ::std::fmt::Debug for GESClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESClipClass @ {:p}", self))
            .field("create_track_element", &self.create_track_element)
            .field("create_track_elements", &self.create_track_elements)
            .field("ABI", &self.ABI)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESClipClass_ABI_abi {
    pub can_add_effects: gboolean,
}

impl ::std::fmt::Debug for GESClipClass_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESClipClass_ABI_abi @ {:p}", self))
            .field("can_add_effects", &self.can_add_effects)
            .finish()
    }
}

#[repr(C)]
pub struct _GESClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESClipPrivate = *mut _GESClipPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESCommandLineFormatterClass {
    pub parent_class: GESFormatterClass,
}

impl ::std::fmt::Debug for GESCommandLineFormatterClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESCommandLineFormatterClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GESCommandLineFormatterPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESCommandLineFormatterPrivate = *mut _GESCommandLineFormatterPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESContainerClass {
    pub parent_class: GESTimelineElementClass,
    pub child_added: Option<unsafe extern "C" fn(*mut GESContainer, *mut GESTimelineElement)>,
    pub child_removed: Option<unsafe extern "C" fn(*mut GESContainer, *mut GESTimelineElement)>,
    pub add_child:
        Option<unsafe extern "C" fn(*mut GESContainer, *mut GESTimelineElement) -> gboolean>,
    pub remove_child:
        Option<unsafe extern "C" fn(*mut GESContainer, *mut GESTimelineElement) -> gboolean>,
    pub ungroup: Option<unsafe extern "C" fn(*mut GESContainer, gboolean) -> *mut glib::GList>,
    pub group: Option<unsafe extern "C" fn(*mut glib::GList) -> *mut GESContainer>,
    pub edit: Option<
        unsafe extern "C" fn(
            *mut GESContainer,
            *mut glib::GList,
            c_int,
            GESEditMode,
            GESEdge,
            u64,
        ) -> gboolean,
    >,
    pub grouping_priority: c_uint,
    pub _ges_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GESContainerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESContainerClass @ {:p}", self))
            .field("child_added", &self.child_added)
            .field("child_removed", &self.child_removed)
            .field("add_child", &self.add_child)
            .field("remove_child", &self.remove_child)
            .field("ungroup", &self.ungroup)
            .field("group", &self.group)
            .field("edit", &self.edit)
            .finish()
    }
}

#[repr(C)]
pub struct _GESContainerPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESContainerPrivate = *mut _GESContainerPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESEffectAssetClass {
    pub parent_class: GESTrackElementAssetClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESEffectAssetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESEffectAssetClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESEffectAssetPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESEffectAssetPrivate = *mut _GESEffectAssetPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESEffectClass {
    pub parent_class: GESBaseEffectClass,
    pub rate_properties: *mut glib::GList,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESEffectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESEffectClass @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESEffectClipClass {
    pub parent_class: GESBaseEffectClipClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESEffectClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESEffectClipClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESEffectClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESEffectClipPrivate = *mut _GESEffectClipPrivate;

#[repr(C)]
pub struct _GESEffectPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESEffectPrivate = *mut _GESEffectPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESExtractableInterface {
    pub parent: gobject::GTypeInterface,
    pub asset_type: GType,
    pub check_id: GESExtractableCheckId,
    pub can_update_asset: gboolean,
    pub set_asset: Option<unsafe extern "C" fn(*mut GESExtractable, *mut GESAsset)>,
    pub set_asset_full:
        Option<unsafe extern "C" fn(*mut GESExtractable, *mut GESAsset) -> gboolean>,
    pub get_parameters_from_id:
        Option<unsafe extern "C" fn(*const c_char, *mut c_uint) -> *mut gobject::GParameter>,
    pub get_id: Option<unsafe extern "C" fn(*mut GESExtractable) -> *mut c_char>,
    pub get_real_extractable_type: Option<unsafe extern "C" fn(GType, *const c_char) -> GType>,
    pub register_metas: Option<
        unsafe extern "C" fn(
            *mut GESExtractableInterface,
            *mut gobject::GObjectClass,
            *mut GESAsset,
        ) -> gboolean,
    >,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESExtractableInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESExtractableInterface @ {:p}", self))
            .field("parent", &self.parent)
            .field("asset_type", &self.asset_type)
            .field("check_id", &self.check_id)
            .field("can_update_asset", &self.can_update_asset)
            .field("set_asset", &self.set_asset)
            .field("set_asset_full", &self.set_asset_full)
            .field("get_parameters_from_id", &self.get_parameters_from_id)
            .field("get_id", &self.get_id)
            .field("get_real_extractable_type", &self.get_real_extractable_type)
            .field("register_metas", &self.register_metas)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESFormatterClass {
    pub parent_class: gobject::GInitiallyUnownedClass,
    pub can_load_uri: GESFormatterCanLoadURIMethod,
    pub load_from_uri: GESFormatterLoadFromURIMethod,
    pub save_to_uri: GESFormatterSaveToURIMethod,
    pub name: *mut c_char,
    pub description: *mut c_char,
    pub extension: *mut c_char,
    pub mimetype: *mut c_char,
    pub version: c_double,
    pub rank: gst::GstRank,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESFormatterClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESFormatterClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("can_load_uri", &self.can_load_uri)
            .field("load_from_uri", &self.load_from_uri)
            .field("save_to_uri", &self.save_to_uri)
            .finish()
    }
}

#[repr(C)]
pub struct _GESFormatterPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESFormatterPrivate = *mut _GESFormatterPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESGroupClass {
    pub parent_class: GESContainerClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESGroupClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESGroupClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESGroupPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESGroupPrivate = *mut _GESGroupPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESImageSourceClass {
    pub parent_class: GESVideoSourceClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESImageSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESImageSourceClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESImageSourcePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESImageSourcePrivate = *mut _GESImageSourcePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESLayerClass {
    pub parent_class: gobject::GInitiallyUnownedClass,
    pub get_objects: Option<unsafe extern "C" fn(*mut GESLayer) -> *mut glib::GList>,
    pub object_added: Option<unsafe extern "C" fn(*mut GESLayer, *mut GESClip)>,
    pub object_removed: Option<unsafe extern "C" fn(*mut GESLayer, *mut GESClip)>,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESLayerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESLayerClass @ {:p}", self))
            .field("get_objects", &self.get_objects)
            .field("object_added", &self.object_added)
            .field("object_removed", &self.object_removed)
            .finish()
    }
}

#[repr(C)]
pub struct _GESLayerPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESLayerPrivate = *mut _GESLayerPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESMarkerClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GESMarkerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESMarkerClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESMarkerListClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GESMarkerListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESMarkerListClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESMetaContainerInterface {
    pub parent_iface: gobject::GTypeInterface,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESMetaContainerInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESMetaContainerInterface @ {:p}", self))
            .field("parent_iface", &self.parent_iface)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESMultiFileSourceClass {
    pub parent_class: GESVideoSourceClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESMultiFileSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESMultiFileSourceClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESMultiFileSourcePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESMultiFileSourcePrivate = *mut _GESMultiFileSourcePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESOperationClass {
    pub parent_class: GESTrackElementClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESOperationClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESOperationClass @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESOperationClipClass {
    pub parent_class: GESClipClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESOperationClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESOperationClipClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESOperationClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESOperationClipPrivate = *mut _GESOperationClipPrivate;

#[repr(C)]
pub struct _GESOperationPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESOperationPrivate = *mut _GESOperationPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESOverlayClipClass {
    pub parent_class: GESOperationClipClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESOverlayClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESOverlayClipClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GESOverlayClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESOverlayClipPrivate = *mut _GESOverlayClipPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESPipelineClass {
    pub parent_class: gst::GstPipelineClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESPipelineClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESPipelineClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESPipelinePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESPipelinePrivate = *mut _GESPipelinePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESPitiviFormatterClass {
    pub parent_class: GESFormatterClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESPitiviFormatterClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESPitiviFormatterClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESPitiviFormatterPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESPitiviFormatterPrivate = *mut _GESPitiviFormatterPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESProjectClass {
    pub parent_class: GESAssetClass,
    pub asset_added: Option<unsafe extern "C" fn(*mut GESProject, *mut GESAsset)>,
    pub asset_loading: Option<unsafe extern "C" fn(*mut GESProject, *mut GESAsset)>,
    pub asset_removed: Option<unsafe extern "C" fn(*mut GESProject, *mut GESAsset)>,
    pub missing_uri: Option<
        unsafe extern "C" fn(*mut GESProject, *mut glib::GError, *mut GESAsset) -> *mut c_char,
    >,
    pub loading_error: Option<
        unsafe extern "C" fn(*mut GESProject, *mut glib::GError, *mut c_char, GType) -> gboolean,
    >,
    pub loaded: Option<unsafe extern "C" fn(*mut GESProject, *mut GESTimeline) -> gboolean>,
    pub loading: Option<unsafe extern "C" fn(*mut GESProject, *mut GESTimeline)>,
    pub _ges_reserved: [gpointer; 3],
}

impl ::std::fmt::Debug for GESProjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESProjectClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("asset_added", &self.asset_added)
            .field("asset_loading", &self.asset_loading)
            .field("asset_removed", &self.asset_removed)
            .field("missing_uri", &self.missing_uri)
            .field("loading_error", &self.loading_error)
            .field("loaded", &self.loaded)
            .field("loading", &self.loading)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESProjectPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESProjectPrivate = *mut _GESProjectPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESSourceClass {
    pub parent_class: GESTrackElementClass,
    pub select_pad: Option<unsafe extern "C" fn(*mut GESSource, *mut gst::GstPad) -> gboolean>,
    pub create_source: Option<unsafe extern "C" fn(*mut GESSource) -> *mut gst::GstElement>,
    pub _ges_reserved: [gpointer; 2],
}

impl ::std::fmt::Debug for GESSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESSourceClass @ {:p}", self))
            .field("select_pad", &self.select_pad)
            .field("create_source", &self.create_source)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESSourceClipAssetClass {
    pub parent_class: GESClipAssetClass,
}

impl ::std::fmt::Debug for GESSourceClipAssetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESSourceClipAssetClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESSourceClipClass {
    pub parent_class: GESClipClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESSourceClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESSourceClipClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESSourceClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESSourceClipPrivate = *mut _GESSourceClipPrivate;

#[repr(C)]
pub struct _GESSourcePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESSourcePrivate = *mut _GESSourcePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTestClipClass {
    pub parent_class: GESSourceClipClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTestClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTestClipClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESTestClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTestClipPrivate = *mut _GESTestClipPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTextOverlayClass {
    pub parent_class: GESOperationClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTextOverlayClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTextOverlayClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTextOverlayClipClass {
    pub parent_class: GESOverlayClipClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTextOverlayClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTextOverlayClipClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESTextOverlayClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTextOverlayClipPrivate = *mut _GESTextOverlayClipPrivate;

#[repr(C)]
pub struct _GESTextOverlayPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTextOverlayPrivate = *mut _GESTextOverlayPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTimelineClass {
    pub parent_class: gst::GstBinClass,
    pub track_added: Option<unsafe extern "C" fn(*mut GESTimeline, *mut GESTrack)>,
    pub track_removed: Option<unsafe extern "C" fn(*mut GESTimeline, *mut GESTrack)>,
    pub layer_added: Option<unsafe extern "C" fn(*mut GESTimeline, *mut GESLayer)>,
    pub layer_removed: Option<unsafe extern "C" fn(*mut GESTimeline, *mut GESLayer)>,
    pub group_added: Option<unsafe extern "C" fn(*mut GESTimeline, *mut GESGroup)>,
    pub group_removed:
        Option<unsafe extern "C" fn(*mut GESTimeline, *mut GESGroup, *mut glib::GPtrArray)>,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTimelineClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTimelineClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("track_added", &self.track_added)
            .field("track_removed", &self.track_removed)
            .field("layer_added", &self.layer_added)
            .field("layer_removed", &self.layer_removed)
            .field("group_added", &self.group_added)
            .field("group_removed", &self.group_removed)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTimelineElementClass {
    pub parent_class: gobject::GInitiallyUnownedClass,
    pub set_parent:
        Option<unsafe extern "C" fn(*mut GESTimelineElement, *mut GESTimelineElement) -> gboolean>,
    pub set_start:
        Option<unsafe extern "C" fn(*mut GESTimelineElement, gst::GstClockTime) -> gboolean>,
    pub set_inpoint:
        Option<unsafe extern "C" fn(*mut GESTimelineElement, gst::GstClockTime) -> gboolean>,
    pub set_duration:
        Option<unsafe extern "C" fn(*mut GESTimelineElement, gst::GstClockTime) -> gboolean>,
    pub set_max_duration:
        Option<unsafe extern "C" fn(*mut GESTimelineElement, gst::GstClockTime) -> gboolean>,
    pub set_priority: Option<unsafe extern "C" fn(*mut GESTimelineElement, u32) -> gboolean>,
    pub ripple: Option<unsafe extern "C" fn(*mut GESTimelineElement, u64) -> gboolean>,
    pub ripple_end: Option<unsafe extern "C" fn(*mut GESTimelineElement, u64) -> gboolean>,
    pub roll_start: Option<unsafe extern "C" fn(*mut GESTimelineElement, u64) -> gboolean>,
    pub roll_end: Option<unsafe extern "C" fn(*mut GESTimelineElement, u64) -> gboolean>,
    pub trim: Option<unsafe extern "C" fn(*mut GESTimelineElement, u64) -> gboolean>,
    pub deep_copy: Option<unsafe extern "C" fn(*mut GESTimelineElement, *mut GESTimelineElement)>,
    pub paste: Option<
        unsafe extern "C" fn(
            *mut GESTimelineElement,
            *mut GESTimelineElement,
            gst::GstClockTime,
        ) -> *mut GESTimelineElement,
    >,
    pub list_children_properties: Option<
        unsafe extern "C" fn(*mut GESTimelineElement, *mut c_uint) -> *mut *mut gobject::GParamSpec,
    >,
    pub lookup_child: Option<
        unsafe extern "C" fn(
            *mut GESTimelineElement,
            *const c_char,
            *mut *mut gobject::GObject,
            *mut *mut gobject::GParamSpec,
        ) -> gboolean,
    >,
    pub get_track_types: Option<unsafe extern "C" fn(*mut GESTimelineElement) -> GESTrackType>,
    pub set_child_property: Option<
        unsafe extern "C" fn(
            *mut GESTimelineElement,
            *mut gobject::GObject,
            *mut gobject::GParamSpec,
            *mut gobject::GValue,
        ),
    >,
    pub get_layer_priority: Option<unsafe extern "C" fn(*mut GESTimelineElement) -> u32>,
    pub get_natural_framerate:
        Option<unsafe extern "C" fn(*mut GESTimelineElement, *mut c_int, *mut c_int) -> gboolean>,
    pub set_child_property_full: Option<
        unsafe extern "C" fn(
            *mut GESTimelineElement,
            *mut gobject::GObject,
            *mut gobject::GParamSpec,
            *const gobject::GValue,
            *mut *mut glib::GError,
        ) -> gboolean,
    >,
    pub _ges_reserved: [gpointer; 14],
}

impl ::std::fmt::Debug for GESTimelineElementClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTimelineElementClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("set_parent", &self.set_parent)
            .field("set_start", &self.set_start)
            .field("set_inpoint", &self.set_inpoint)
            .field("set_duration", &self.set_duration)
            .field("set_max_duration", &self.set_max_duration)
            .field("set_priority", &self.set_priority)
            .field("ripple", &self.ripple)
            .field("ripple_end", &self.ripple_end)
            .field("roll_start", &self.roll_start)
            .field("roll_end", &self.roll_end)
            .field("trim", &self.trim)
            .field("deep_copy", &self.deep_copy)
            .field("paste", &self.paste)
            .field("list_children_properties", &self.list_children_properties)
            .field("lookup_child", &self.lookup_child)
            .field("get_track_types", &self.get_track_types)
            .field("set_child_property", &self.set_child_property)
            .field("get_layer_priority", &self.get_layer_priority)
            .field("get_natural_framerate", &self.get_natural_framerate)
            .field("set_child_property_full", &self.set_child_property_full)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESTimelineElementPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTimelineElementPrivate = *mut _GESTimelineElementPrivate;

#[repr(C)]
pub struct _GESTimelinePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTimelinePrivate = *mut _GESTimelinePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTitleClipClass {
    pub parent_class: GESSourceClipClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTitleClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTitleClipClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESTitleClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTitleClipPrivate = *mut _GESTitleClipPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTitleSourceClass {
    pub parent_class: GESVideoSourceClass,
    pub _ges_reserved: [gpointer; 3],
}

impl ::std::fmt::Debug for GESTitleSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTitleSourceClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GESTitleSourcePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTitleSourcePrivate = *mut _GESTitleSourcePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTrackClass {
    pub parent_class: gst::GstBinClass,
    pub get_mixing_element: Option<unsafe extern "C" fn(*mut GESTrack) -> *mut gst::GstElement>,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTrackClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTrackClass @ {:p}", self))
            .field("get_mixing_element", &self.get_mixing_element)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTrackElementAssetClass {
    pub parent_class: GESAssetClass,
    pub get_natural_framerate:
        Option<unsafe extern "C" fn(*mut GESTrackElementAsset, *mut c_int, *mut c_int) -> gboolean>,
    pub _ges_reserved: [gpointer; 3],
}

impl ::std::fmt::Debug for GESTrackElementAssetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTrackElementAssetClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("get_natural_framerate", &self.get_natural_framerate)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESTrackElementAssetPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTrackElementAssetPrivate = *mut _GESTrackElementAssetPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTrackElementClass {
    pub parent_class: GESTimelineElementClass,
    pub nleobject_factorytype: *const c_char,
    pub create_gnl_object:
        Option<unsafe extern "C" fn(*mut GESTrackElement) -> *mut gst::GstElement>,
    pub create_element: Option<unsafe extern "C" fn(*mut GESTrackElement) -> *mut gst::GstElement>,
    pub active_changed: Option<unsafe extern "C" fn(*mut GESTrackElement, gboolean)>,
    pub changed: Option<unsafe extern "C" fn(*mut GESTrackElement)>,
    pub list_children_properties: Option<
        unsafe extern "C" fn(*mut GESTrackElement, *mut c_uint) -> *mut *mut gobject::GParamSpec,
    >,
    pub lookup_child: Option<
        unsafe extern "C" fn(
            *mut GESTrackElement,
            *const c_char,
            *mut *mut gst::GstElement,
            *mut *mut gobject::GParamSpec,
        ) -> gboolean,
    >,
    pub ABI: GESTrackElementClass_ABI,
}

impl ::std::fmt::Debug for GESTrackElementClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTrackElementClass @ {:p}", self))
            .field("nleobject_factorytype", &self.nleobject_factorytype)
            .field("create_gnl_object", &self.create_gnl_object)
            .field("create_element", &self.create_element)
            .field("active_changed", &self.active_changed)
            .field("changed", &self.changed)
            .field("list_children_properties", &self.list_children_properties)
            .field("lookup_child", &self.lookup_child)
            .field("ABI", &self.ABI)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTrackElementClass_ABI_abi {
    pub default_has_internal_source: gboolean,
    pub default_track_type: GESTrackType,
}

impl ::std::fmt::Debug for GESTrackElementClass_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTrackElementClass_ABI_abi @ {:p}", self))
            .field(
                "default_has_internal_source",
                &self.default_has_internal_source,
            )
            .field("default_track_type", &self.default_track_type)
            .finish()
    }
}

#[repr(C)]
pub struct _GESTrackElementPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTrackElementPrivate = *mut _GESTrackElementPrivate;

#[repr(C)]
pub struct _GESTrackPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTrackPrivate = *mut _GESTrackPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTransitionClass {
    pub parent_class: GESOperationClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTransitionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTransitionClass @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTransitionClipClass {
    pub parent_class: GESBaseTransitionClipClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTransitionClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTransitionClipClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESTransitionClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTransitionClipPrivate = *mut _GESTransitionClipPrivate;

#[repr(C)]
pub struct _GESTransitionPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESTransitionPrivate = *mut _GESTransitionPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESUriClipAssetClass {
    pub parent_class: GESSourceClipAssetClass,
    pub discoverer: *mut gst_pbutils::GstDiscoverer,
    pub sync_discoverer: *mut gst_pbutils::GstDiscoverer,
    pub discovered: Option<
        unsafe extern "C" fn(
            *mut gst_pbutils::GstDiscoverer,
            *mut gst_pbutils::GstDiscovererInfo,
            *mut glib::GError,
            gpointer,
        ),
    >,
    pub _ges_reserved: [gpointer; 3],
}

impl ::std::fmt::Debug for GESUriClipAssetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESUriClipAssetClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("discovered", &self.discovered)
            .finish()
    }
}

#[repr(C)]
pub struct _GESUriClipAssetPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESUriClipAssetPrivate = *mut _GESUriClipAssetPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESUriClipClass {
    pub parent_class: GESSourceClipClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESUriClipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESUriClipClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESUriClipPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESUriClipPrivate = *mut _GESUriClipPrivate;

#[repr(C)]
pub struct _GESUriSource {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESUriSource = *mut _GESUriSource;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESUriSourceAssetClass {
    pub parent_class: GESTrackElementAssetClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESUriSourceAssetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESUriSourceAssetClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESUriSourceAssetPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESUriSourceAssetPrivate = *mut _GESUriSourceAssetPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESVideoSourceClass {
    pub parent_class: GESSourceClass,
    pub create_source: Option<unsafe extern "C" fn(*mut GESTrackElement) -> *mut gst::GstElement>,
    pub ABI: GESVideoSourceClass_ABI,
}

impl ::std::fmt::Debug for GESVideoSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoSourceClass @ {:p}", self))
            .field("create_source", &self.create_source)
            .field("ABI", &self.ABI)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESVideoSourceClass_ABI_abi {
    pub disable_scale_in_compositor: gboolean,
    pub needs_converters: Option<unsafe extern "C" fn(*mut GESVideoSource) -> gboolean>,
    pub get_natural_size:
        Option<unsafe extern "C" fn(*mut GESVideoSource, *mut c_int, *mut c_int) -> gboolean>,
    pub create_filters: Option<
        unsafe extern "C" fn(*mut GESVideoSource, *mut glib::GPtrArray, gboolean) -> gboolean,
    >,
}

impl ::std::fmt::Debug for GESVideoSourceClass_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoSourceClass_ABI_abi @ {:p}", self))
            .field(
                "disable_scale_in_compositor",
                &self.disable_scale_in_compositor,
            )
            .field("needs_converters", &self.needs_converters)
            .field("get_natural_size", &self.get_natural_size)
            .field("create_filters", &self.create_filters)
            .finish()
    }
}

#[repr(C)]
pub struct _GESVideoSourcePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESVideoSourcePrivate = *mut _GESVideoSourcePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESVideoTestSourceClass {
    pub parent_class: GESVideoSourceClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESVideoTestSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoTestSourceClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESVideoTestSourcePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESVideoTestSourcePrivate = *mut _GESVideoTestSourcePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESVideoTrackClass {
    pub parent_class: GESTrackClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESVideoTrackClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoTrackClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESVideoTrackPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESVideoTrackPrivate = *mut _GESVideoTrackPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESVideoTransitionClass {
    pub parent_class: GESTransitionClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESVideoTransitionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoTransitionClass @ {:p}", self))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
pub struct _GESVideoTransitionPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESVideoTransitionPrivate = *mut _GESVideoTransitionPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESVideoUriSourceClass {
    pub parent_class: GESVideoSourceClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESVideoUriSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoUriSourceClass @ {:p}", self))
            .finish()
    }
}

#[repr(C)]
pub struct _GESVideoUriSourcePrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESVideoUriSourcePrivate = *mut _GESVideoUriSourcePrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESXmlFormatterClass {
    pub parent: GESBaseXmlFormatterClass,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESXmlFormatterClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESXmlFormatterClass @ {:p}", self))
            .field("parent", &self.parent)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct _GESXmlFormatterPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GESXmlFormatterPrivate = *mut _GESXmlFormatterPrivate;

// Classes
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAsset {
    pub parent: gobject::GObject,
    pub priv_: *mut GESAssetPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAsset @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAudioSource {
    pub parent: GESSource,
    pub priv_: *mut GESAudioSourcePrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAudioSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAudioSource @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAudioTestSource {
    pub parent: GESAudioSource,
    pub priv_: *mut GESAudioTestSourcePrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAudioTestSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAudioTestSource @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAudioTrack {
    pub parent_instance: GESTrack,
    pub priv_: *mut GESAudioTrackPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAudioTrack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAudioTrack @ {:p}", self))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAudioTransition {
    pub parent: GESTransition,
    pub priv_: *mut GESAudioTransitionPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAudioTransition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAudioTransition @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESAudioUriSource {
    pub parent: GESAudioSource,
    pub uri: *mut c_char,
    pub priv_: *mut GESUriSource,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESAudioUriSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESAudioUriSource @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESBaseEffect {
    pub parent: GESOperation,
    pub priv_: *mut GESBaseEffectPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESBaseEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESBaseEffect @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESBaseEffectClip {
    pub parent: GESOperationClip,
    pub priv_: *mut GESBaseEffectClipPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESBaseEffectClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESBaseEffectClip @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESBaseTransitionClip {
    pub parent: GESOperationClip,
    pub priv_: *mut GESBaseTransitionClipPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESBaseTransitionClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESBaseTransitionClip @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESBaseXmlFormatter {
    pub parent: GESFormatter,
    pub priv_: *mut GESBaseXmlFormatterPrivate,
    pub xmlcontent: *mut c_char,
    pub _ges_reserved: [gpointer; 3],
}

impl ::std::fmt::Debug for GESBaseXmlFormatter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESBaseXmlFormatter @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESClip {
    pub parent: GESContainer,
    pub priv_: *mut GESClipPrivate,
    pub _ges_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GESClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESClip @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESClipAsset {
    pub parent: GESAsset,
    pub priv_: *mut GESClipAssetPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESClipAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESClipAsset @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESCommandLineFormatter {
    pub parent_instance: GESFormatter,
    pub priv_: *mut GESCommandLineFormatterPrivate,
}

impl ::std::fmt::Debug for GESCommandLineFormatter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESCommandLineFormatter @ {:p}", self))
            .field("parent_instance", &self.parent_instance)
            .field("priv_", &self.priv_)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESContainer {
    pub parent: GESTimelineElement,
    pub children: *mut glib::GList,
    pub height: u32,
    pub children_control_mode: GESChildrenControlMode,
    pub initiated_move: *mut GESTimelineElement,
    pub priv_: *mut GESContainerPrivate,
    pub _ges_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GESContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESContainer @ {:p}", self))
            .field("parent", &self.parent)
            .field("children", &self.children)
            .field("height", &self.height)
            .field("children_control_mode", &self.children_control_mode)
            .field("initiated_move", &self.initiated_move)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESEffect {
    pub parent: GESBaseEffect,
    pub priv_: *mut GESEffectPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESEffect @ {:p}", self)).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESEffectAsset {
    pub parent_instance: GESTrackElementAsset,
    pub priv_: *mut GESEffectAssetPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESEffectAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESEffectAsset @ {:p}", self))
            .field("parent_instance", &self.parent_instance)
            .field("priv_", &self.priv_)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESEffectClip {
    pub parent: GESBaseEffectClip,
    pub priv_: *mut GESEffectClipPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESEffectClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESEffectClip @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESFormatter {
    pub parent: gobject::GInitiallyUnowned,
    pub priv_: *mut GESFormatterPrivate,
    pub project: *mut GESProject,
    pub timeline: *mut GESTimeline,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESFormatter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESFormatter @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESGroup {
    pub parent: GESContainer,
    pub priv_: *mut GESGroupPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESGroup @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESImageSource {
    pub parent: GESVideoSource,
    pub uri: *mut c_char,
    pub priv_: *mut GESImageSourcePrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESImageSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESImageSource @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESLayer {
    pub parent: gobject::GInitiallyUnowned,
    pub timeline: *mut GESTimeline,
    pub min_nle_priority: u32,
    pub max_nle_priority: u32,
    pub priv_: *mut GESLayerPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESLayer @ {:p}", self))
            .field("parent", &self.parent)
            .field("timeline", &self.timeline)
            .field("min_nle_priority", &self.min_nle_priority)
            .field("max_nle_priority", &self.max_nle_priority)
            .field("priv_", &self.priv_)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

#[repr(C)]
pub struct GESMarker {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GESMarker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESMarker @ {:p}", self)).finish()
    }
}

#[repr(C)]
pub struct GESMarkerList {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GESMarkerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESMarkerList @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESMultiFileSource {
    pub parent: GESVideoSource,
    pub uri: *mut c_char,
    pub priv_: *mut GESMultiFileSourcePrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESMultiFileSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESMultiFileSource @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESOperation {
    pub parent: GESTrackElement,
    pub priv_: *mut GESOperationPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESOperation @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESOperationClip {
    pub parent: GESClip,
    pub priv_: *mut GESOperationClipPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESOperationClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESOperationClip @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESOverlayClip {
    pub parent: GESOperationClip,
    pub priv_: *mut GESOverlayClipPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESOverlayClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESOverlayClip @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESPipeline {
    pub parent: gst::GstPipeline,
    pub priv_: *mut GESPipelinePrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESPipeline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESPipeline @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESPitiviFormatter {
    pub parent: GESFormatter,
    pub priv_: *mut GESPitiviFormatterPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESPitiviFormatter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESPitiviFormatter @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESProject {
    pub parent: GESAsset,
    pub priv_: *mut GESProjectPrivate,
    pub __ges_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GESProject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESProject @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESSource {
    pub parent: GESTrackElement,
    pub priv_: *mut GESSourcePrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESSource @ {:p}", self)).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESSourceClip {
    pub parent: GESClip,
    pub priv_: *mut GESSourceClipPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESSourceClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESSourceClip @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESSourceClipAsset {
    pub parent_instance: GESClipAsset,
}

impl ::std::fmt::Debug for GESSourceClipAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESSourceClipAsset @ {:p}", self))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTestClip {
    pub parent: GESSourceClip,
    pub priv_: *mut GESTestClipPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTestClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTestClip @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTextOverlay {
    pub parent: GESOperation,
    pub priv_: *mut GESTextOverlayPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTextOverlay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTextOverlay @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTextOverlayClip {
    pub parent: GESOverlayClip,
    pub priv_: *mut GESTextOverlayClipPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTextOverlayClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTextOverlayClip @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTimeline {
    pub parent: gst::GstBin,
    pub layers: *mut glib::GList,
    pub tracks: *mut glib::GList,
    pub priv_: *mut GESTimelinePrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTimeline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTimeline @ {:p}", self))
            .field("parent", &self.parent)
            .field("layers", &self.layers)
            .field("tracks", &self.tracks)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTimelineElement {
    pub parent_instance: gobject::GInitiallyUnowned,
    pub parent: *mut GESTimelineElement,
    pub asset: *mut GESAsset,
    pub start: gst::GstClockTime,
    pub inpoint: gst::GstClockTime,
    pub duration: gst::GstClockTime,
    pub maxduration: gst::GstClockTime,
    pub priority: u32,
    pub timeline: *mut GESTimeline,
    pub name: *mut c_char,
    pub priv_: *mut GESTimelineElementPrivate,
    pub _ges_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GESTimelineElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTimelineElement @ {:p}", self))
            .field("parent_instance", &self.parent_instance)
            .field("parent", &self.parent)
            .field("asset", &self.asset)
            .field("start", &self.start)
            .field("inpoint", &self.inpoint)
            .field("duration", &self.duration)
            .field("maxduration", &self.maxduration)
            .field("priority", &self.priority)
            .field("timeline", &self.timeline)
            .field("name", &self.name)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTitleClip {
    pub parent: GESSourceClip,
    pub priv_: *mut GESTitleClipPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTitleClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTitleClip @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTitleSource {
    pub parent: GESVideoSource,
    pub priv_: *mut GESTitleSourcePrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTitleSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTitleSource @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTrack {
    pub parent: gst::GstBin,
    pub type_: GESTrackType,
    pub priv_: *mut GESTrackPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTrack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTrack @ {:p}", self))
            .field("parent", &self.parent)
            .field("type_", &self.type_)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTrackElement {
    pub parent: GESTimelineElement,
    pub active: gboolean,
    pub priv_: *mut GESTrackElementPrivate,
    pub asset: *mut GESAsset,
    pub _ges_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GESTrackElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTrackElement @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTrackElementAsset {
    pub parent: GESAsset,
    pub priv_: *mut GESTrackElementAssetPrivate,
    pub __ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTrackElementAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTrackElementAsset @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTransition {
    pub parent: GESOperation,
    pub priv_: *mut GESTransitionPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTransition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTransition @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESTransitionClip {
    pub parent: GESBaseTransitionClip,
    pub vtype: GESVideoStandardTransitionType,
    pub priv_: *mut GESTransitionClipPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESTransitionClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESTransitionClip @ {:p}", self))
            .field("vtype", &self.vtype)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESUriClip {
    pub parent: GESSourceClip,
    pub priv_: *mut GESUriClipPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESUriClip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESUriClip @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESUriClipAsset {
    pub parent: GESSourceClipAsset,
    pub priv_: *mut GESUriClipAssetPrivate,
    pub __ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESUriClipAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESUriClipAsset @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESUriSourceAsset {
    pub parent: GESTrackElementAsset,
    pub priv_: *mut GESUriSourceAssetPrivate,
    pub __ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESUriSourceAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESUriSourceAsset @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESVideoSource {
    pub parent: GESSource,
    pub priv_: *mut GESVideoSourcePrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESVideoSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoSource @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESVideoTestSource {
    pub parent: GESVideoSource,
    pub priv_: *mut GESVideoTestSourcePrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESVideoTestSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoTestSource @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESVideoTrack {
    pub parent_instance: GESTrack,
    pub priv_: *mut GESVideoTrackPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESVideoTrack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoTrack @ {:p}", self))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESVideoTransition {
    pub parent: GESTransition,
    pub priv_: *mut GESVideoTransitionPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESVideoTransition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoTransition @ {:p}", self))
            .field("parent", &self.parent)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESVideoUriSource {
    pub parent: GESVideoSource,
    pub uri: *mut c_char,
    pub priv_: *mut GESUriSource,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESVideoUriSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESVideoUriSource @ {:p}", self))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GESXmlFormatter {
    pub parent: GESBaseXmlFormatter,
    pub priv_: *mut GESXmlFormatterPrivate,
    pub _ges_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GESXmlFormatter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GESXmlFormatter @ {:p}", self))
            .field("parent", &self.parent)
            .field("priv_", &self.priv_)
            .field("_ges_reserved", &self._ges_reserved)
            .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct GESExtractable {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GESExtractable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GESExtractable @ {:p}", self)
    }
}

#[repr(C)]
pub struct GESMetaContainer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GESMetaContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GESMetaContainer @ {:p}", self)
    }
}

#[link(name = "ges-1.0")]
extern "C" {

    //=========================================================================
    // GESEdge
    //=========================================================================
    pub fn ges_edge_get_type() -> GType;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn ges_edge_name(edge: GESEdge) -> *const c_char;

    //=========================================================================
    // GESEditMode
    //=========================================================================
    pub fn ges_edit_mode_get_type() -> GType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_edit_mode_name(mode: GESEditMode) -> *const c_char;

    //=========================================================================
    // GESTextHAlign
    //=========================================================================
    pub fn ges_text_halign_get_type() -> GType;

    //=========================================================================
    // GESTextVAlign
    //=========================================================================
    pub fn ges_text_valign_get_type() -> GType;

    //=========================================================================
    // GESVideoStandardTransitionType
    //=========================================================================
    pub fn ges_video_standard_transition_type_get_type() -> GType;

    //=========================================================================
    // GESVideoTestPattern
    //=========================================================================
    pub fn ges_video_test_pattern_get_type() -> GType;

    //=========================================================================
    // GESMarkerFlags
    //=========================================================================
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn ges_marker_flags_get_type() -> GType;

    //=========================================================================
    // GESMetaFlag
    //=========================================================================
    pub fn ges_meta_flag_get_type() -> GType;

    //=========================================================================
    // GESPipelineFlags
    //=========================================================================
    pub fn ges_pipeline_flags_get_type() -> GType;

    //=========================================================================
    // GESTrackType
    //=========================================================================
    pub fn ges_track_type_get_type() -> GType;
    pub fn ges_track_type_name(type_: GESTrackType) -> *const c_char;

    //=========================================================================
    // GESEffectClass
    //=========================================================================
    pub fn ges_effect_class_register_rate_property(
        klass: *mut GESEffectClass,
        element_name: *const c_char,
        property_name: *const c_char,
    ) -> gboolean;

    //=========================================================================
    // GESFormatterClass
    //=========================================================================
    pub fn ges_formatter_class_register_metas(
        klass: *mut GESFormatterClass,
        name: *const c_char,
        description: *const c_char,
        extensions: *const c_char,
        caps: *const c_char,
        version: c_double,
        rank: gst::GstRank,
    );

    //=========================================================================
    // GESUriClipAssetClass
    //=========================================================================
    pub fn ges_uri_clip_asset_class_set_timeout(
        klass: *mut GESUriClipAssetClass,
        timeout: gst::GstClockTime,
    );

    //=========================================================================
    // GESAsset
    //=========================================================================
    pub fn ges_asset_get_type() -> GType;
    pub fn ges_asset_needs_reload(extractable_type: GType, id: *const c_char) -> gboolean;
    pub fn ges_asset_request(
        extractable_type: GType,
        id: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut GESAsset;
    pub fn ges_asset_request_async(
        extractable_type: GType,
        id: *const c_char,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    pub fn ges_asset_request_finish(
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> *mut GESAsset;
    pub fn ges_asset_extract(
        self_: *mut GESAsset,
        error: *mut *mut glib::GError,
    ) -> *mut GESExtractable;
    pub fn ges_asset_get_error(self_: *mut GESAsset) -> *mut glib::GError;
    pub fn ges_asset_get_extractable_type(self_: *mut GESAsset) -> GType;
    pub fn ges_asset_get_id(self_: *mut GESAsset) -> *const c_char;
    pub fn ges_asset_get_proxy(asset: *mut GESAsset) -> *mut GESAsset;
    pub fn ges_asset_get_proxy_target(proxy: *mut GESAsset) -> *mut GESAsset;
    pub fn ges_asset_list_proxies(asset: *mut GESAsset) -> *mut glib::GList;
    pub fn ges_asset_set_proxy(asset: *mut GESAsset, proxy: *mut GESAsset) -> gboolean;
    pub fn ges_asset_unproxy(asset: *mut GESAsset, proxy: *mut GESAsset) -> gboolean;

    //=========================================================================
    // GESAudioSource
    //=========================================================================
    pub fn ges_audio_source_get_type() -> GType;

    //=========================================================================
    // GESAudioTestSource
    //=========================================================================
    pub fn ges_audio_test_source_get_type() -> GType;
    pub fn ges_audio_test_source_get_freq(self_: *mut GESAudioTestSource) -> c_double;
    pub fn ges_audio_test_source_get_volume(self_: *mut GESAudioTestSource) -> c_double;
    pub fn ges_audio_test_source_set_freq(self_: *mut GESAudioTestSource, freq: c_double);
    pub fn ges_audio_test_source_set_volume(self_: *mut GESAudioTestSource, volume: c_double);

    //=========================================================================
    // GESAudioTrack
    //=========================================================================
    pub fn ges_audio_track_get_type() -> GType;
    pub fn ges_audio_track_new() -> *mut GESAudioTrack;

    //=========================================================================
    // GESAudioTransition
    //=========================================================================
    pub fn ges_audio_transition_get_type() -> GType;
    pub fn ges_audio_transition_new() -> *mut GESAudioTransition;

    //=========================================================================
    // GESAudioUriSource
    //=========================================================================
    pub fn ges_audio_uri_source_get_type() -> GType;

    //=========================================================================
    // GESBaseEffect
    //=========================================================================
    pub fn ges_base_effect_get_type() -> GType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_base_effect_is_time_effect(effect: *mut GESBaseEffect) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_base_effect_register_time_property(
        effect: *mut GESBaseEffect,
        child_property_name: *const c_char,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_base_effect_set_time_translation_funcs(
        effect: *mut GESBaseEffect,
        source_to_sink_func: GESBaseEffectTimeTranslationFunc,
        sink_to_source_func: GESBaseEffectTimeTranslationFunc,
        user_data: gpointer,
        destroy: glib::GDestroyNotify,
    ) -> gboolean;

    //=========================================================================
    // GESBaseEffectClip
    //=========================================================================
    pub fn ges_base_effect_clip_get_type() -> GType;

    //=========================================================================
    // GESBaseTransitionClip
    //=========================================================================
    pub fn ges_base_transition_clip_get_type() -> GType;

    //=========================================================================
    // GESBaseXmlFormatter
    //=========================================================================
    pub fn ges_base_xml_formatter_get_type() -> GType;

    //=========================================================================
    // GESClip
    //=========================================================================
    pub fn ges_clip_get_type() -> GType;
    pub fn ges_clip_add_asset(clip: *mut GESClip, asset: *mut GESAsset) -> *mut GESTrackElement;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_add_child_to_track(
        clip: *mut GESClip,
        child: *mut GESTrackElement,
        track: *mut GESTrack,
        error: *mut *mut glib::GError,
    ) -> *mut GESTrackElement;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_add_top_effect(
        clip: *mut GESClip,
        effect: *mut GESBaseEffect,
        index: c_int,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_clip_find_track_element(
        clip: *mut GESClip,
        track: *mut GESTrack,
        type_: GType,
    ) -> *mut GESTrackElement;
    pub fn ges_clip_find_track_elements(
        clip: *mut GESClip,
        track: *mut GESTrack,
        track_type: GESTrackType,
        type_: GType,
    ) -> *mut glib::GList;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_get_duration_limit(clip: *mut GESClip) -> gst::GstClockTime;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_get_internal_time_from_timeline_time(
        clip: *mut GESClip,
        child: *mut GESTrackElement,
        timeline_time: gst::GstClockTime,
        error: *mut *mut glib::GError,
    ) -> gst::GstClockTime;
    pub fn ges_clip_get_layer(clip: *mut GESClip) -> *mut GESLayer;
    pub fn ges_clip_get_supported_formats(clip: *mut GESClip) -> GESTrackType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_get_timeline_time_from_internal_time(
        clip: *mut GESClip,
        child: *mut GESTrackElement,
        internal_time: gst::GstClockTime,
        error: *mut *mut glib::GError,
    ) -> gst::GstClockTime;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_get_timeline_time_from_source_frame(
        clip: *mut GESClip,
        frame_number: GESFrameNumber,
        error: *mut *mut glib::GError,
    ) -> gst::GstClockTime;
    pub fn ges_clip_get_top_effect_index(clip: *mut GESClip, effect: *mut GESBaseEffect) -> c_int;
    pub fn ges_clip_get_top_effect_position(
        clip: *mut GESClip,
        effect: *mut GESBaseEffect,
    ) -> c_int;
    pub fn ges_clip_get_top_effects(clip: *mut GESClip) -> *mut glib::GList;
    pub fn ges_clip_move_to_layer(clip: *mut GESClip, layer: *mut GESLayer) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_move_to_layer_full(
        clip: *mut GESClip,
        layer: *mut GESLayer,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_remove_top_effect(
        clip: *mut GESClip,
        effect: *mut GESBaseEffect,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_clip_set_supported_formats(clip: *mut GESClip, supportedformats: GESTrackType);
    pub fn ges_clip_set_top_effect_index(
        clip: *mut GESClip,
        effect: *mut GESBaseEffect,
        newindex: c_uint,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_set_top_effect_index_full(
        clip: *mut GESClip,
        effect: *mut GESBaseEffect,
        newindex: c_uint,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_clip_set_top_effect_priority(
        clip: *mut GESClip,
        effect: *mut GESBaseEffect,
        newpriority: c_uint,
    ) -> gboolean;
    pub fn ges_clip_split(clip: *mut GESClip, position: u64) -> *mut GESClip;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_split_full(
        clip: *mut GESClip,
        position: u64,
        error: *mut *mut glib::GError,
    ) -> *mut GESClip;

    //=========================================================================
    // GESClipAsset
    //=========================================================================
    pub fn ges_clip_asset_get_type() -> GType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_asset_get_frame_time(
        self_: *mut GESClipAsset,
        frame_number: GESFrameNumber,
    ) -> gst::GstClockTime;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_clip_asset_get_natural_framerate(
        self_: *mut GESClipAsset,
        framerate_n: *mut c_int,
        framerate_d: *mut c_int,
    ) -> gboolean;
    pub fn ges_clip_asset_get_supported_formats(self_: *mut GESClipAsset) -> GESTrackType;
    pub fn ges_clip_asset_set_supported_formats(
        self_: *mut GESClipAsset,
        supportedformats: GESTrackType,
    );

    //=========================================================================
    // GESCommandLineFormatter
    //=========================================================================
    pub fn ges_command_line_formatter_get_type() -> GType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn ges_command_line_formatter_get_help(
        nargs: c_int,
        commands: *mut *mut c_char,
    ) -> *mut c_char;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_10")))]
    pub fn ges_command_line_formatter_get_timeline_uri(timeline: *mut GESTimeline) -> *mut c_char;

    //=========================================================================
    // GESContainer
    //=========================================================================
    pub fn ges_container_get_type() -> GType;
    pub fn ges_container_group(containers: *mut glib::GList) -> *mut GESContainer;
    pub fn ges_container_add(
        container: *mut GESContainer,
        child: *mut GESTimelineElement,
    ) -> gboolean;
    pub fn ges_container_edit(
        container: *mut GESContainer,
        layers: *mut glib::GList,
        new_layer_priority: c_int,
        mode: GESEditMode,
        edge: GESEdge,
        position: u64,
    ) -> gboolean;
    pub fn ges_container_get_children(
        container: *mut GESContainer,
        recursive: gboolean,
    ) -> *mut glib::GList;
    pub fn ges_container_remove(
        container: *mut GESContainer,
        child: *mut GESTimelineElement,
    ) -> gboolean;
    pub fn ges_container_ungroup(
        container: *mut GESContainer,
        recursive: gboolean,
    ) -> *mut glib::GList;

    //=========================================================================
    // GESEffect
    //=========================================================================
    pub fn ges_effect_get_type() -> GType;
    pub fn ges_effect_new(bin_description: *const c_char) -> *mut GESEffect;

    //=========================================================================
    // GESEffectAsset
    //=========================================================================
    pub fn ges_effect_asset_get_type() -> GType;

    //=========================================================================
    // GESEffectClip
    //=========================================================================
    pub fn ges_effect_clip_get_type() -> GType;
    pub fn ges_effect_clip_new(
        video_bin_description: *const c_char,
        audio_bin_description: *const c_char,
    ) -> *mut GESEffectClip;

    //=========================================================================
    // GESFormatter
    //=========================================================================
    pub fn ges_formatter_get_type() -> GType;
    pub fn ges_formatter_can_load_uri(
        uri: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_formatter_can_save_uri(
        uri: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_formatter_get_default() -> *mut GESAsset;
    pub fn ges_formatter_load_from_uri(
        formatter: *mut GESFormatter,
        timeline: *mut GESTimeline,
        uri: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_formatter_save_to_uri(
        formatter: *mut GESFormatter,
        timeline: *mut GESTimeline,
        uri: *const c_char,
        overwrite: gboolean,
        error: *mut *mut glib::GError,
    ) -> gboolean;

    //=========================================================================
    // GESGroup
    //=========================================================================
    pub fn ges_group_get_type() -> GType;
    pub fn ges_group_new() -> *mut GESGroup;

    //=========================================================================
    // GESImageSource
    //=========================================================================
    pub fn ges_image_source_get_type() -> GType;

    //=========================================================================
    // GESLayer
    //=========================================================================
    pub fn ges_layer_get_type() -> GType;
    pub fn ges_layer_new() -> *mut GESLayer;
    pub fn ges_layer_add_asset(
        layer: *mut GESLayer,
        asset: *mut GESAsset,
        start: gst::GstClockTime,
        inpoint: gst::GstClockTime,
        duration: gst::GstClockTime,
        track_types: GESTrackType,
    ) -> *mut GESClip;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_layer_add_asset_full(
        layer: *mut GESLayer,
        asset: *mut GESAsset,
        start: gst::GstClockTime,
        inpoint: gst::GstClockTime,
        duration: gst::GstClockTime,
        track_types: GESTrackType,
        error: *mut *mut glib::GError,
    ) -> *mut GESClip;
    pub fn ges_layer_add_clip(layer: *mut GESLayer, clip: *mut GESClip) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_layer_add_clip_full(
        layer: *mut GESLayer,
        clip: *mut GESClip,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_layer_get_active_for_track(layer: *mut GESLayer, track: *mut GESTrack) -> gboolean;
    pub fn ges_layer_get_auto_transition(layer: *mut GESLayer) -> gboolean;
    pub fn ges_layer_get_clips(layer: *mut GESLayer) -> *mut glib::GList;
    pub fn ges_layer_get_clips_in_interval(
        layer: *mut GESLayer,
        start: gst::GstClockTime,
        end: gst::GstClockTime,
    ) -> *mut glib::GList;
    pub fn ges_layer_get_duration(layer: *mut GESLayer) -> gst::GstClockTime;
    pub fn ges_layer_get_priority(layer: *mut GESLayer) -> c_uint;
    pub fn ges_layer_get_timeline(layer: *mut GESLayer) -> *mut GESTimeline;
    pub fn ges_layer_is_empty(layer: *mut GESLayer) -> gboolean;
    pub fn ges_layer_remove_clip(layer: *mut GESLayer, clip: *mut GESClip) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_layer_set_active_for_tracks(
        layer: *mut GESLayer,
        active: gboolean,
        tracks: *mut glib::GList,
    ) -> gboolean;
    pub fn ges_layer_set_auto_transition(layer: *mut GESLayer, auto_transition: gboolean);
    pub fn ges_layer_set_priority(layer: *mut GESLayer, priority: c_uint);
    pub fn ges_layer_set_timeline(layer: *mut GESLayer, timeline: *mut GESTimeline);

    //=========================================================================
    // GESMarker
    //=========================================================================
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_marker_get_type() -> GType;

    //=========================================================================
    // GESMarkerList
    //=========================================================================
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_marker_list_get_type() -> GType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_marker_list_new() -> *mut GESMarkerList;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_marker_list_add(
        list: *mut GESMarkerList,
        position: gst::GstClockTime,
    ) -> *mut GESMarker;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_marker_list_get_markers(list: *mut GESMarkerList) -> *mut glib::GList;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_marker_list_move(
        list: *mut GESMarkerList,
        marker: *mut GESMarker,
        position: gst::GstClockTime,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_marker_list_remove(list: *mut GESMarkerList, marker: *mut GESMarker) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_marker_list_size(list: *mut GESMarkerList) -> c_uint;

    //=========================================================================
    // GESMultiFileSource
    //=========================================================================
    pub fn ges_multi_file_source_get_type() -> GType;
    pub fn ges_multi_file_source_new(uri: *mut c_char) -> *mut GESMultiFileSource;

    //=========================================================================
    // GESOperation
    //=========================================================================
    pub fn ges_operation_get_type() -> GType;

    //=========================================================================
    // GESOperationClip
    //=========================================================================
    pub fn ges_operation_clip_get_type() -> GType;

    //=========================================================================
    // GESOverlayClip
    //=========================================================================
    pub fn ges_overlay_clip_get_type() -> GType;

    //=========================================================================
    // GESPipeline
    //=========================================================================
    pub fn ges_pipeline_get_type() -> GType;
    pub fn ges_pipeline_new() -> *mut GESPipeline;
    pub fn ges_pipeline_get_mode(pipeline: *mut GESPipeline) -> GESPipelineFlags;
    pub fn ges_pipeline_get_thumbnail(
        self_: *mut GESPipeline,
        caps: *mut gst::GstCaps,
    ) -> *mut gst::GstSample;
    pub fn ges_pipeline_get_thumbnail_rgb24(
        self_: *mut GESPipeline,
        width: c_int,
        height: c_int,
    ) -> *mut gst::GstSample;
    pub fn ges_pipeline_preview_get_audio_sink(self_: *mut GESPipeline) -> *mut gst::GstElement;
    pub fn ges_pipeline_preview_get_video_sink(self_: *mut GESPipeline) -> *mut gst::GstElement;
    pub fn ges_pipeline_preview_set_audio_sink(self_: *mut GESPipeline, sink: *mut gst::GstElement);
    pub fn ges_pipeline_preview_set_video_sink(self_: *mut GESPipeline, sink: *mut gst::GstElement);
    pub fn ges_pipeline_save_thumbnail(
        self_: *mut GESPipeline,
        width: c_int,
        height: c_int,
        format: *const c_char,
        location: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_pipeline_set_mode(pipeline: *mut GESPipeline, mode: GESPipelineFlags) -> gboolean;
    pub fn ges_pipeline_set_render_settings(
        pipeline: *mut GESPipeline,
        output_uri: *const c_char,
        profile: *mut gst_pbutils::GstEncodingProfile,
    ) -> gboolean;
    pub fn ges_pipeline_set_timeline(
        pipeline: *mut GESPipeline,
        timeline: *mut GESTimeline,
    ) -> gboolean;

    //=========================================================================
    // GESPitiviFormatter
    //=========================================================================
    pub fn ges_pitivi_formatter_get_type() -> GType;
    pub fn ges_pitivi_formatter_new() -> *mut GESPitiviFormatter;

    //=========================================================================
    // GESProject
    //=========================================================================
    pub fn ges_project_get_type() -> GType;
    pub fn ges_project_new(uri: *const c_char) -> *mut GESProject;
    pub fn ges_project_add_asset(project: *mut GESProject, asset: *mut GESAsset) -> gboolean;
    pub fn ges_project_add_encoding_profile(
        project: *mut GESProject,
        profile: *mut gst_pbutils::GstEncodingProfile,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_project_add_formatter(project: *mut GESProject, formatter: *mut GESFormatter);
    pub fn ges_project_create_asset(
        project: *mut GESProject,
        id: *const c_char,
        extractable_type: GType,
    ) -> gboolean;
    pub fn ges_project_create_asset_sync(
        project: *mut GESProject,
        id: *const c_char,
        extractable_type: GType,
        error: *mut *mut glib::GError,
    ) -> *mut GESAsset;
    pub fn ges_project_get_asset(
        project: *mut GESProject,
        id: *const c_char,
        extractable_type: GType,
    ) -> *mut GESAsset;
    pub fn ges_project_get_loading_assets(project: *mut GESProject) -> *mut glib::GList;
    pub fn ges_project_get_uri(project: *mut GESProject) -> *mut c_char;
    pub fn ges_project_list_assets(project: *mut GESProject, filter: GType) -> *mut glib::GList;
    pub fn ges_project_list_encoding_profiles(project: *mut GESProject) -> *const glib::GList;
    pub fn ges_project_load(
        project: *mut GESProject,
        timeline: *mut GESTimeline,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_project_remove_asset(project: *mut GESProject, asset: *mut GESAsset) -> gboolean;
    pub fn ges_project_save(
        project: *mut GESProject,
        timeline: *mut GESTimeline,
        uri: *const c_char,
        formatter_asset: *mut GESAsset,
        overwrite: gboolean,
        error: *mut *mut glib::GError,
    ) -> gboolean;

    //=========================================================================
    // GESSource
    //=========================================================================
    pub fn ges_source_get_type() -> GType;

    //=========================================================================
    // GESSourceClip
    //=========================================================================
    pub fn ges_source_clip_get_type() -> GType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_source_clip_new_time_overlay() -> *mut GESSourceClip;

    //=========================================================================
    // GESSourceClipAsset
    //=========================================================================
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_source_clip_asset_get_type() -> GType;

    //=========================================================================
    // GESTestClip
    //=========================================================================
    pub fn ges_test_clip_get_type() -> GType;
    pub fn ges_test_clip_new() -> *mut GESTestClip;
    pub fn ges_test_clip_new_for_nick(nick: *mut c_char) -> *mut GESTestClip;
    pub fn ges_test_clip_get_frequency(self_: *mut GESTestClip) -> c_double;
    pub fn ges_test_clip_get_volume(self_: *mut GESTestClip) -> c_double;
    pub fn ges_test_clip_get_vpattern(self_: *mut GESTestClip) -> GESVideoTestPattern;
    pub fn ges_test_clip_is_muted(self_: *mut GESTestClip) -> gboolean;
    pub fn ges_test_clip_set_frequency(self_: *mut GESTestClip, freq: c_double);
    pub fn ges_test_clip_set_mute(self_: *mut GESTestClip, mute: gboolean);
    pub fn ges_test_clip_set_volume(self_: *mut GESTestClip, volume: c_double);
    pub fn ges_test_clip_set_vpattern(self_: *mut GESTestClip, vpattern: GESVideoTestPattern);

    //=========================================================================
    // GESTextOverlay
    //=========================================================================
    pub fn ges_text_overlay_get_type() -> GType;
    pub fn ges_text_overlay_new() -> *mut GESTextOverlay;
    pub fn ges_text_overlay_get_color(self_: *mut GESTextOverlay) -> u32;
    pub fn ges_text_overlay_get_font_desc(self_: *mut GESTextOverlay) -> *const c_char;
    pub fn ges_text_overlay_get_halignment(self_: *mut GESTextOverlay) -> GESTextHAlign;
    pub fn ges_text_overlay_get_text(self_: *mut GESTextOverlay) -> *const c_char;
    pub fn ges_text_overlay_get_valignment(self_: *mut GESTextOverlay) -> GESTextVAlign;
    pub fn ges_text_overlay_get_xpos(self_: *mut GESTextOverlay) -> c_double;
    pub fn ges_text_overlay_get_ypos(self_: *mut GESTextOverlay) -> c_double;
    pub fn ges_text_overlay_set_color(self_: *mut GESTextOverlay, color: u32);
    pub fn ges_text_overlay_set_font_desc(self_: *mut GESTextOverlay, font_desc: *const c_char);
    pub fn ges_text_overlay_set_halignment(self_: *mut GESTextOverlay, halign: GESTextHAlign);
    pub fn ges_text_overlay_set_text(self_: *mut GESTextOverlay, text: *const c_char);
    pub fn ges_text_overlay_set_valignment(self_: *mut GESTextOverlay, valign: GESTextVAlign);
    pub fn ges_text_overlay_set_xpos(self_: *mut GESTextOverlay, position: c_double);
    pub fn ges_text_overlay_set_ypos(self_: *mut GESTextOverlay, position: c_double);

    //=========================================================================
    // GESTextOverlayClip
    //=========================================================================
    pub fn ges_text_overlay_clip_get_type() -> GType;
    pub fn ges_text_overlay_clip_new() -> *mut GESTextOverlayClip;
    pub fn ges_text_overlay_clip_get_color(self_: *mut GESTextOverlayClip) -> u32;
    pub fn ges_text_overlay_clip_get_font_desc(self_: *mut GESTextOverlayClip) -> *const c_char;
    pub fn ges_text_overlay_clip_get_halignment(self_: *mut GESTextOverlayClip) -> GESTextHAlign;
    pub fn ges_text_overlay_clip_get_text(self_: *mut GESTextOverlayClip) -> *const c_char;
    pub fn ges_text_overlay_clip_get_valignment(self_: *mut GESTextOverlayClip) -> GESTextVAlign;
    pub fn ges_text_overlay_clip_get_xpos(self_: *mut GESTextOverlayClip) -> c_double;
    pub fn ges_text_overlay_clip_get_ypos(self_: *mut GESTextOverlayClip) -> c_double;
    pub fn ges_text_overlay_clip_set_color(self_: *mut GESTextOverlayClip, color: u32);
    pub fn ges_text_overlay_clip_set_font_desc(
        self_: *mut GESTextOverlayClip,
        font_desc: *const c_char,
    );
    pub fn ges_text_overlay_clip_set_halign(self_: *mut GESTextOverlayClip, halign: GESTextHAlign);
    pub fn ges_text_overlay_clip_set_text(self_: *mut GESTextOverlayClip, text: *const c_char);
    pub fn ges_text_overlay_clip_set_valign(self_: *mut GESTextOverlayClip, valign: GESTextVAlign);
    pub fn ges_text_overlay_clip_set_xpos(self_: *mut GESTextOverlayClip, position: c_double);
    pub fn ges_text_overlay_clip_set_ypos(self_: *mut GESTextOverlayClip, position: c_double);

    //=========================================================================
    // GESTimeline
    //=========================================================================
    pub fn ges_timeline_get_type() -> GType;
    pub fn ges_timeline_new() -> *mut GESTimeline;
    pub fn ges_timeline_new_audio_video() -> *mut GESTimeline;
    pub fn ges_timeline_new_from_uri(
        uri: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut GESTimeline;
    pub fn ges_timeline_add_layer(timeline: *mut GESTimeline, layer: *mut GESLayer) -> gboolean;
    pub fn ges_timeline_add_track(timeline: *mut GESTimeline, track: *mut GESTrack) -> gboolean;
    pub fn ges_timeline_append_layer(timeline: *mut GESTimeline) -> *mut GESLayer;
    pub fn ges_timeline_commit(timeline: *mut GESTimeline) -> gboolean;
    pub fn ges_timeline_commit_sync(timeline: *mut GESTimeline) -> gboolean;
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn ges_timeline_freeze_commit(timeline: *mut GESTimeline);
    pub fn ges_timeline_get_auto_transition(timeline: *mut GESTimeline) -> gboolean;
    pub fn ges_timeline_get_duration(timeline: *mut GESTimeline) -> gst::GstClockTime;
    pub fn ges_timeline_get_element(
        timeline: *mut GESTimeline,
        name: *const c_char,
    ) -> *mut GESTimelineElement;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_timeline_get_frame_at(
        self_: *mut GESTimeline,
        timestamp: gst::GstClockTime,
    ) -> GESFrameNumber;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_timeline_get_frame_time(
        self_: *mut GESTimeline,
        frame_number: GESFrameNumber,
    ) -> gst::GstClockTime;
    pub fn ges_timeline_get_groups(timeline: *mut GESTimeline) -> *mut glib::GList;
    pub fn ges_timeline_get_layer(timeline: *mut GESTimeline, priority: c_uint) -> *mut GESLayer;
    pub fn ges_timeline_get_layers(timeline: *mut GESTimeline) -> *mut glib::GList;
    pub fn ges_timeline_get_pad_for_track(
        timeline: *mut GESTimeline,
        track: *mut GESTrack,
    ) -> *mut gst::GstPad;
    pub fn ges_timeline_get_snapping_distance(timeline: *mut GESTimeline) -> gst::GstClockTime;
    pub fn ges_timeline_get_track_for_pad(
        timeline: *mut GESTimeline,
        pad: *mut gst::GstPad,
    ) -> *mut GESTrack;
    pub fn ges_timeline_get_tracks(timeline: *mut GESTimeline) -> *mut glib::GList;
    pub fn ges_timeline_is_empty(timeline: *mut GESTimeline) -> gboolean;
    pub fn ges_timeline_load_from_uri(
        timeline: *mut GESTimeline,
        uri: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn ges_timeline_move_layer(
        timeline: *mut GESTimeline,
        layer: *mut GESLayer,
        new_layer_priority: c_uint,
    ) -> gboolean;
    pub fn ges_timeline_paste_element(
        timeline: *mut GESTimeline,
        element: *mut GESTimelineElement,
        position: gst::GstClockTime,
        layer_priority: c_int,
    ) -> *mut GESTimelineElement;
    pub fn ges_timeline_remove_layer(timeline: *mut GESTimeline, layer: *mut GESLayer) -> gboolean;
    pub fn ges_timeline_remove_track(timeline: *mut GESTimeline, track: *mut GESTrack) -> gboolean;
    pub fn ges_timeline_save_to_uri(
        timeline: *mut GESTimeline,
        uri: *const c_char,
        formatter_asset: *mut GESAsset,
        overwrite: gboolean,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_timeline_set_auto_transition(timeline: *mut GESTimeline, auto_transition: gboolean);
    pub fn ges_timeline_set_snapping_distance(
        timeline: *mut GESTimeline,
        snapping_distance: gst::GstClockTime,
    );
    #[cfg(any(feature = "v1_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_20")))]
    pub fn ges_timeline_thaw_commit(timeline: *mut GESTimeline);

    //=========================================================================
    // GESTimelineElement
    //=========================================================================
    pub fn ges_timeline_element_get_type() -> GType;
    pub fn ges_timeline_element_add_child_property(
        self_: *mut GESTimelineElement,
        pspec: *mut gobject::GParamSpec,
        child: *mut gobject::GObject,
    ) -> gboolean;
    pub fn ges_timeline_element_copy(
        self_: *mut GESTimelineElement,
        deep: gboolean,
    ) -> *mut GESTimelineElement;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_timeline_element_edit(
        self_: *mut GESTimelineElement,
        layers: *mut glib::GList,
        new_layer_priority: i64,
        mode: GESEditMode,
        edge: GESEdge,
        position: u64,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_timeline_element_edit_full(
        self_: *mut GESTimelineElement,
        new_layer_priority: i64,
        mode: GESEditMode,
        edge: GESEdge,
        position: u64,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_timeline_element_get_child_properties(
        self_: *mut GESTimelineElement,
        first_property_name: *const c_char,
        ...
    );
    pub fn ges_timeline_element_get_child_property(
        self_: *mut GESTimelineElement,
        property_name: *const c_char,
        value: *mut gobject::GValue,
    ) -> gboolean;
    pub fn ges_timeline_element_get_child_property_by_pspec(
        self_: *mut GESTimelineElement,
        pspec: *mut gobject::GParamSpec,
        value: *mut gobject::GValue,
    );
    //pub fn ges_timeline_element_get_child_property_valist(self_: *mut GESTimelineElement, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn ges_timeline_element_get_duration(self_: *mut GESTimelineElement) -> gst::GstClockTime;
    pub fn ges_timeline_element_get_inpoint(self_: *mut GESTimelineElement) -> gst::GstClockTime;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn ges_timeline_element_get_layer_priority(self_: *mut GESTimelineElement) -> u32;
    pub fn ges_timeline_element_get_max_duration(
        self_: *mut GESTimelineElement,
    ) -> gst::GstClockTime;
    pub fn ges_timeline_element_get_name(self_: *mut GESTimelineElement) -> *mut c_char;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_timeline_element_get_natural_framerate(
        self_: *mut GESTimelineElement,
        framerate_n: *mut c_int,
        framerate_d: *mut c_int,
    ) -> gboolean;
    pub fn ges_timeline_element_get_parent(
        self_: *mut GESTimelineElement,
    ) -> *mut GESTimelineElement;
    pub fn ges_timeline_element_get_priority(self_: *mut GESTimelineElement) -> u32;
    pub fn ges_timeline_element_get_start(self_: *mut GESTimelineElement) -> gst::GstClockTime;
    pub fn ges_timeline_element_get_timeline(self_: *mut GESTimelineElement) -> *mut GESTimeline;
    pub fn ges_timeline_element_get_toplevel_parent(
        self_: *mut GESTimelineElement,
    ) -> *mut GESTimelineElement;
    pub fn ges_timeline_element_get_track_types(self_: *mut GESTimelineElement) -> GESTrackType;
    pub fn ges_timeline_element_list_children_properties(
        self_: *mut GESTimelineElement,
        n_properties: *mut c_uint,
    ) -> *mut *mut gobject::GParamSpec;
    pub fn ges_timeline_element_lookup_child(
        self_: *mut GESTimelineElement,
        prop_name: *const c_char,
        child: *mut *mut gobject::GObject,
        pspec: *mut *mut gobject::GParamSpec,
    ) -> gboolean;
    pub fn ges_timeline_element_paste(
        self_: *mut GESTimelineElement,
        paste_position: gst::GstClockTime,
    ) -> *mut GESTimelineElement;
    pub fn ges_timeline_element_remove_child_property(
        self_: *mut GESTimelineElement,
        pspec: *mut gobject::GParamSpec,
    ) -> gboolean;
    pub fn ges_timeline_element_ripple(
        self_: *mut GESTimelineElement,
        start: gst::GstClockTime,
    ) -> gboolean;
    pub fn ges_timeline_element_ripple_end(
        self_: *mut GESTimelineElement,
        end: gst::GstClockTime,
    ) -> gboolean;
    pub fn ges_timeline_element_roll_end(
        self_: *mut GESTimelineElement,
        end: gst::GstClockTime,
    ) -> gboolean;
    pub fn ges_timeline_element_roll_start(
        self_: *mut GESTimelineElement,
        start: gst::GstClockTime,
    ) -> gboolean;
    pub fn ges_timeline_element_set_child_properties(
        self_: *mut GESTimelineElement,
        first_property_name: *const c_char,
        ...
    );
    pub fn ges_timeline_element_set_child_property(
        self_: *mut GESTimelineElement,
        property_name: *const c_char,
        value: *const gobject::GValue,
    ) -> gboolean;
    pub fn ges_timeline_element_set_child_property_by_pspec(
        self_: *mut GESTimelineElement,
        pspec: *mut gobject::GParamSpec,
        value: *const gobject::GValue,
    );
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_timeline_element_set_child_property_full(
        self_: *mut GESTimelineElement,
        property_name: *const c_char,
        value: *const gobject::GValue,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    //pub fn ges_timeline_element_set_child_property_valist(self_: *mut GESTimelineElement, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn ges_timeline_element_set_duration(
        self_: *mut GESTimelineElement,
        duration: gst::GstClockTime,
    ) -> gboolean;
    pub fn ges_timeline_element_set_inpoint(
        self_: *mut GESTimelineElement,
        inpoint: gst::GstClockTime,
    ) -> gboolean;
    pub fn ges_timeline_element_set_max_duration(
        self_: *mut GESTimelineElement,
        maxduration: gst::GstClockTime,
    ) -> gboolean;
    pub fn ges_timeline_element_set_name(
        self_: *mut GESTimelineElement,
        name: *const c_char,
    ) -> gboolean;
    pub fn ges_timeline_element_set_parent(
        self_: *mut GESTimelineElement,
        parent: *mut GESTimelineElement,
    ) -> gboolean;
    pub fn ges_timeline_element_set_priority(
        self_: *mut GESTimelineElement,
        priority: u32,
    ) -> gboolean;
    pub fn ges_timeline_element_set_start(
        self_: *mut GESTimelineElement,
        start: gst::GstClockTime,
    ) -> gboolean;
    pub fn ges_timeline_element_set_timeline(
        self_: *mut GESTimelineElement,
        timeline: *mut GESTimeline,
    ) -> gboolean;
    pub fn ges_timeline_element_trim(
        self_: *mut GESTimelineElement,
        start: gst::GstClockTime,
    ) -> gboolean;

    //=========================================================================
    // GESTitleClip
    //=========================================================================
    pub fn ges_title_clip_get_type() -> GType;
    pub fn ges_title_clip_new() -> *mut GESTitleClip;
    pub fn ges_title_clip_get_background_color(self_: *mut GESTitleClip) -> u32;
    pub fn ges_title_clip_get_font_desc(self_: *mut GESTitleClip) -> *const c_char;
    pub fn ges_title_clip_get_halignment(self_: *mut GESTitleClip) -> GESTextHAlign;
    pub fn ges_title_clip_get_text(self_: *mut GESTitleClip) -> *const c_char;
    pub fn ges_title_clip_get_text_color(self_: *mut GESTitleClip) -> u32;
    pub fn ges_title_clip_get_valignment(self_: *mut GESTitleClip) -> GESTextVAlign;
    pub fn ges_title_clip_get_xpos(self_: *mut GESTitleClip) -> c_double;
    pub fn ges_title_clip_get_ypos(self_: *mut GESTitleClip) -> c_double;
    pub fn ges_title_clip_set_background(self_: *mut GESTitleClip, background: u32);
    pub fn ges_title_clip_set_color(self_: *mut GESTitleClip, color: u32);
    pub fn ges_title_clip_set_font_desc(self_: *mut GESTitleClip, font_desc: *const c_char);
    pub fn ges_title_clip_set_halignment(self_: *mut GESTitleClip, halign: GESTextHAlign);
    pub fn ges_title_clip_set_text(self_: *mut GESTitleClip, text: *const c_char);
    pub fn ges_title_clip_set_valignment(self_: *mut GESTitleClip, valign: GESTextVAlign);
    pub fn ges_title_clip_set_xpos(self_: *mut GESTitleClip, position: c_double);
    pub fn ges_title_clip_set_ypos(self_: *mut GESTitleClip, position: c_double);

    //=========================================================================
    // GESTitleSource
    //=========================================================================
    pub fn ges_title_source_get_type() -> GType;
    pub fn ges_title_source_get_background_color(source: *mut GESTitleSource) -> u32;
    pub fn ges_title_source_get_font_desc(source: *mut GESTitleSource) -> *const c_char;
    pub fn ges_title_source_get_halignment(source: *mut GESTitleSource) -> GESTextHAlign;
    pub fn ges_title_source_get_text(source: *mut GESTitleSource) -> *const c_char;
    pub fn ges_title_source_get_text_color(source: *mut GESTitleSource) -> u32;
    pub fn ges_title_source_get_valignment(source: *mut GESTitleSource) -> GESTextVAlign;
    pub fn ges_title_source_get_xpos(source: *mut GESTitleSource) -> c_double;
    pub fn ges_title_source_get_ypos(source: *mut GESTitleSource) -> c_double;
    pub fn ges_title_source_set_background_color(self_: *mut GESTitleSource, color: u32);
    pub fn ges_title_source_set_font_desc(self_: *mut GESTitleSource, font_desc: *const c_char);
    pub fn ges_title_source_set_halignment(self_: *mut GESTitleSource, halign: GESTextHAlign);
    pub fn ges_title_source_set_text(self_: *mut GESTitleSource, text: *const c_char);
    pub fn ges_title_source_set_text_color(self_: *mut GESTitleSource, color: u32);
    pub fn ges_title_source_set_valignment(self_: *mut GESTitleSource, valign: GESTextVAlign);
    pub fn ges_title_source_set_xpos(self_: *mut GESTitleSource, position: c_double);
    pub fn ges_title_source_set_ypos(self_: *mut GESTitleSource, position: c_double);

    //=========================================================================
    // GESTrack
    //=========================================================================
    pub fn ges_track_get_type() -> GType;
    pub fn ges_track_new(type_: GESTrackType, caps: *mut gst::GstCaps) -> *mut GESTrack;
    pub fn ges_track_add_element(track: *mut GESTrack, object: *mut GESTrackElement) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_track_add_element_full(
        track: *mut GESTrack,
        object: *mut GESTrackElement,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_track_commit(track: *mut GESTrack) -> gboolean;
    pub fn ges_track_get_caps(track: *mut GESTrack) -> *const gst::GstCaps;
    pub fn ges_track_get_elements(track: *mut GESTrack) -> *mut glib::GList;
    pub fn ges_track_get_mixing(track: *mut GESTrack) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_track_get_restriction_caps(track: *mut GESTrack) -> *mut gst::GstCaps;
    pub fn ges_track_get_timeline(track: *mut GESTrack) -> *const GESTimeline;
    pub fn ges_track_remove_element(track: *mut GESTrack, object: *mut GESTrackElement)
        -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_track_remove_element_full(
        track: *mut GESTrack,
        object: *mut GESTrackElement,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_track_set_create_element_for_gap_func(
        track: *mut GESTrack,
        func: GESCreateElementForGapFunc,
    );
    pub fn ges_track_set_mixing(track: *mut GESTrack, mixing: gboolean);
    pub fn ges_track_set_restriction_caps(track: *mut GESTrack, caps: *const gst::GstCaps);
    pub fn ges_track_set_timeline(track: *mut GESTrack, timeline: *mut GESTimeline);
    pub fn ges_track_update_restriction_caps(track: *mut GESTrack, caps: *const gst::GstCaps);

    //=========================================================================
    // GESTrackElement
    //=========================================================================
    pub fn ges_track_element_get_type() -> GType;
    pub fn ges_track_element_add_children_props(
        self_: *mut GESTrackElement,
        element: *mut gst::GstElement,
        wanted_categories: *mut *const c_char,
        blacklist: *mut *const c_char,
        whitelist: *mut *const c_char,
    );
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_track_element_clamp_control_source(
        object: *mut GESTrackElement,
        property_name: *const c_char,
    );
    pub fn ges_track_element_edit(
        object: *mut GESTrackElement,
        layers: *mut glib::GList,
        mode: GESEditMode,
        edge: GESEdge,
        position: u64,
    ) -> gboolean;
    pub fn ges_track_element_get_all_control_bindings(
        trackelement: *mut GESTrackElement,
    ) -> *mut glib::GHashTable;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_track_element_get_auto_clamp_control_sources(
        object: *mut GESTrackElement,
    ) -> gboolean;
    pub fn ges_track_element_get_child_properties(
        object: *mut GESTrackElement,
        first_property_name: *const c_char,
        ...
    );
    pub fn ges_track_element_get_child_property(
        object: *mut GESTrackElement,
        property_name: *const c_char,
        value: *mut gobject::GValue,
    ) -> gboolean;
    pub fn ges_track_element_get_child_property_by_pspec(
        object: *mut GESTrackElement,
        pspec: *mut gobject::GParamSpec,
        value: *mut gobject::GValue,
    );
    //pub fn ges_track_element_get_child_property_valist(object: *mut GESTrackElement, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn ges_track_element_get_control_binding(
        object: *mut GESTrackElement,
        property_name: *const c_char,
    ) -> *mut gst::GstControlBinding;
    pub fn ges_track_element_get_element(object: *mut GESTrackElement) -> *mut gst::GstElement;
    pub fn ges_track_element_get_gnlobject(object: *mut GESTrackElement) -> *mut gst::GstElement;
    pub fn ges_track_element_get_nleobject(object: *mut GESTrackElement) -> *mut gst::GstElement;
    pub fn ges_track_element_get_track(object: *mut GESTrackElement) -> *mut GESTrack;
    pub fn ges_track_element_get_track_type(object: *mut GESTrackElement) -> GESTrackType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_track_element_has_internal_source(object: *mut GESTrackElement) -> gboolean;
    pub fn ges_track_element_is_active(object: *mut GESTrackElement) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_track_element_is_core(object: *mut GESTrackElement) -> gboolean;
    pub fn ges_track_element_list_children_properties(
        object: *mut GESTrackElement,
        n_properties: *mut c_uint,
    ) -> *mut *mut gobject::GParamSpec;
    pub fn ges_track_element_lookup_child(
        object: *mut GESTrackElement,
        prop_name: *const c_char,
        element: *mut *mut gst::GstElement,
        pspec: *mut *mut gobject::GParamSpec,
    ) -> gboolean;
    pub fn ges_track_element_remove_control_binding(
        object: *mut GESTrackElement,
        property_name: *const c_char,
    ) -> gboolean;
    pub fn ges_track_element_set_active(object: *mut GESTrackElement, active: gboolean)
        -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_track_element_set_auto_clamp_control_sources(
        object: *mut GESTrackElement,
        auto_clamp: gboolean,
    );
    pub fn ges_track_element_set_child_properties(
        object: *mut GESTrackElement,
        first_property_name: *const c_char,
        ...
    );
    pub fn ges_track_element_set_child_property(
        object: *mut GESTrackElement,
        property_name: *const c_char,
        value: *mut gobject::GValue,
    ) -> gboolean;
    pub fn ges_track_element_set_child_property_by_pspec(
        object: *mut GESTrackElement,
        pspec: *mut gobject::GParamSpec,
        value: *mut gobject::GValue,
    );
    //pub fn ges_track_element_set_child_property_valist(object: *mut GESTrackElement, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn ges_track_element_set_control_source(
        object: *mut GESTrackElement,
        source: *mut gst::GstControlSource,
        property_name: *const c_char,
        binding_type: *const c_char,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_track_element_set_has_internal_source(
        object: *mut GESTrackElement,
        has_internal_source: gboolean,
    ) -> gboolean;
    pub fn ges_track_element_set_track_type(object: *mut GESTrackElement, type_: GESTrackType);

    //=========================================================================
    // GESTrackElementAsset
    //=========================================================================
    pub fn ges_track_element_asset_get_type() -> GType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_track_element_asset_get_natural_framerate(
        self_: *mut GESTrackElementAsset,
        framerate_n: *mut c_int,
        framerate_d: *mut c_int,
    ) -> gboolean;
    pub fn ges_track_element_asset_get_track_type(asset: *mut GESTrackElementAsset)
        -> GESTrackType;
    pub fn ges_track_element_asset_set_track_type(
        asset: *mut GESTrackElementAsset,
        type_: GESTrackType,
    );

    //=========================================================================
    // GESTransition
    //=========================================================================
    pub fn ges_transition_get_type() -> GType;

    //=========================================================================
    // GESTransitionClip
    //=========================================================================
    pub fn ges_transition_clip_get_type() -> GType;
    pub fn ges_transition_clip_new(vtype: GESVideoStandardTransitionType)
        -> *mut GESTransitionClip;
    pub fn ges_transition_clip_new_for_nick(nick: *mut c_char) -> *mut GESTransitionClip;

    //=========================================================================
    // GESUriClip
    //=========================================================================
    pub fn ges_uri_clip_get_type() -> GType;
    pub fn ges_uri_clip_new(uri: *const c_char) -> *mut GESUriClip;
    pub fn ges_uri_clip_get_uri(self_: *mut GESUriClip) -> *const c_char;
    pub fn ges_uri_clip_is_image(self_: *mut GESUriClip) -> gboolean;
    pub fn ges_uri_clip_is_muted(self_: *mut GESUriClip) -> gboolean;
    pub fn ges_uri_clip_set_is_image(self_: *mut GESUriClip, is_image: gboolean);
    pub fn ges_uri_clip_set_mute(self_: *mut GESUriClip, mute: gboolean);

    //=========================================================================
    // GESUriClipAsset
    //=========================================================================
    pub fn ges_uri_clip_asset_get_type() -> GType;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn ges_uri_clip_asset_finish(
        res: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> *mut GESUriClipAsset;
    pub fn ges_uri_clip_asset_new(
        uri: *const c_char,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    pub fn ges_uri_clip_asset_request_sync(
        uri: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut GESUriClipAsset;
    pub fn ges_uri_clip_asset_get_duration(self_: *mut GESUriClipAsset) -> gst::GstClockTime;
    pub fn ges_uri_clip_asset_get_info(
        self_: *const GESUriClipAsset,
    ) -> *mut gst_pbutils::GstDiscovererInfo;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_uri_clip_asset_get_max_duration(self_: *mut GESUriClipAsset) -> gst::GstClockTime;
    pub fn ges_uri_clip_asset_get_stream_assets(self_: *mut GESUriClipAsset) -> *const glib::GList;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_uri_clip_asset_is_image(self_: *mut GESUriClipAsset) -> gboolean;

    //=========================================================================
    // GESUriSourceAsset
    //=========================================================================
    pub fn ges_uri_source_asset_get_type() -> GType;
    pub fn ges_uri_source_asset_get_filesource_asset(
        asset: *mut GESUriSourceAsset,
    ) -> *const GESUriClipAsset;
    pub fn ges_uri_source_asset_get_stream_info(
        asset: *mut GESUriSourceAsset,
    ) -> *mut gst_pbutils::GstDiscovererStreamInfo;
    pub fn ges_uri_source_asset_get_stream_uri(asset: *mut GESUriSourceAsset) -> *const c_char;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_uri_source_asset_is_image(asset: *mut GESUriSourceAsset) -> gboolean;

    //=========================================================================
    // GESVideoSource
    //=========================================================================
    pub fn ges_video_source_get_type() -> GType;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_video_source_get_natural_size(
        self_: *mut GESVideoSource,
        width: *mut c_int,
        height: *mut c_int,
    ) -> gboolean;

    //=========================================================================
    // GESVideoTestSource
    //=========================================================================
    pub fn ges_video_test_source_get_type() -> GType;
    pub fn ges_video_test_source_get_pattern(
        source: *mut GESVideoTestSource,
    ) -> GESVideoTestPattern;
    pub fn ges_video_test_source_set_pattern(
        self_: *mut GESVideoTestSource,
        pattern: GESVideoTestPattern,
    );

    //=========================================================================
    // GESVideoTrack
    //=========================================================================
    pub fn ges_video_track_get_type() -> GType;
    pub fn ges_video_track_new() -> *mut GESVideoTrack;

    //=========================================================================
    // GESVideoTransition
    //=========================================================================
    pub fn ges_video_transition_get_type() -> GType;
    pub fn ges_video_transition_new() -> *mut GESVideoTransition;
    pub fn ges_video_transition_get_border(self_: *mut GESVideoTransition) -> c_int;
    pub fn ges_video_transition_get_transition_type(
        trans: *mut GESVideoTransition,
    ) -> GESVideoStandardTransitionType;
    pub fn ges_video_transition_is_inverted(self_: *mut GESVideoTransition) -> gboolean;
    pub fn ges_video_transition_set_border(self_: *mut GESVideoTransition, value: c_uint);
    pub fn ges_video_transition_set_inverted(self_: *mut GESVideoTransition, inverted: gboolean);
    pub fn ges_video_transition_set_transition_type(
        self_: *mut GESVideoTransition,
        type_: GESVideoStandardTransitionType,
    ) -> gboolean;

    //=========================================================================
    // GESVideoUriSource
    //=========================================================================
    pub fn ges_video_uri_source_get_type() -> GType;

    //=========================================================================
    // GESXmlFormatter
    //=========================================================================
    pub fn ges_xml_formatter_get_type() -> GType;

    //=========================================================================
    // GESExtractable
    //=========================================================================
    pub fn ges_extractable_get_type() -> GType;
    pub fn ges_extractable_get_asset(self_: *mut GESExtractable) -> *mut GESAsset;
    pub fn ges_extractable_get_id(self_: *mut GESExtractable) -> *mut c_char;
    pub fn ges_extractable_set_asset(self_: *mut GESExtractable, asset: *mut GESAsset) -> gboolean;

    //=========================================================================
    // GESMetaContainer
    //=========================================================================
    pub fn ges_meta_container_get_type() -> GType;
    pub fn ges_meta_container_add_metas_from_string(
        container: *mut GESMetaContainer,
        str: *const c_char,
    ) -> gboolean;
    pub fn ges_meta_container_check_meta_registered(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        flags: *mut GESMetaFlag,
        type_: *mut GType,
    ) -> gboolean;
    pub fn ges_meta_container_foreach(
        container: *mut GESMetaContainer,
        func: GESMetaForeachFunc,
        user_data: gpointer,
    );
    pub fn ges_meta_container_get_boolean(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        dest: *mut gboolean,
    ) -> gboolean;
    pub fn ges_meta_container_get_date(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        dest: *mut *mut glib::GDate,
    ) -> gboolean;
    pub fn ges_meta_container_get_date_time(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        dest: *mut *mut gst::GstDateTime,
    ) -> gboolean;
    pub fn ges_meta_container_get_double(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        dest: *mut c_double,
    ) -> gboolean;
    pub fn ges_meta_container_get_float(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        dest: *mut c_float,
    ) -> gboolean;
    pub fn ges_meta_container_get_int(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        dest: *mut c_int,
    ) -> gboolean;
    pub fn ges_meta_container_get_int64(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        dest: *mut i64,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_meta_container_get_marker_list(
        container: *mut GESMetaContainer,
        key: *const c_char,
    ) -> *mut GESMarkerList;
    pub fn ges_meta_container_get_meta(
        container: *mut GESMetaContainer,
        key: *const c_char,
    ) -> *const gobject::GValue;
    pub fn ges_meta_container_get_string(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
    ) -> *const c_char;
    pub fn ges_meta_container_get_uint(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        dest: *mut c_uint,
    ) -> gboolean;
    pub fn ges_meta_container_get_uint64(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        dest: *mut u64,
    ) -> gboolean;
    pub fn ges_meta_container_metas_to_string(container: *mut GESMetaContainer) -> *mut c_char;
    pub fn ges_meta_container_register_meta(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        value: *const gobject::GValue,
    ) -> gboolean;
    pub fn ges_meta_container_register_meta_boolean(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        value: gboolean,
    ) -> gboolean;
    pub fn ges_meta_container_register_meta_date(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        value: *const glib::GDate,
    ) -> gboolean;
    pub fn ges_meta_container_register_meta_date_time(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        value: *const gst::GstDateTime,
    ) -> gboolean;
    pub fn ges_meta_container_register_meta_double(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        value: c_double,
    ) -> gboolean;
    pub fn ges_meta_container_register_meta_float(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        value: c_float,
    ) -> gboolean;
    pub fn ges_meta_container_register_meta_int(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        value: c_int,
    ) -> gboolean;
    pub fn ges_meta_container_register_meta_int64(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        value: i64,
    ) -> gboolean;
    pub fn ges_meta_container_register_meta_string(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        value: *const c_char,
    ) -> gboolean;
    pub fn ges_meta_container_register_meta_uint(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        value: c_uint,
    ) -> gboolean;
    pub fn ges_meta_container_register_meta_uint64(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        value: u64,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_meta_container_register_static_meta(
        container: *mut GESMetaContainer,
        flags: GESMetaFlag,
        meta_item: *const c_char,
        type_: GType,
    ) -> gboolean;
    pub fn ges_meta_container_set_boolean(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        value: gboolean,
    ) -> gboolean;
    pub fn ges_meta_container_set_date(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        value: *const glib::GDate,
    ) -> gboolean;
    pub fn ges_meta_container_set_date_time(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        value: *const gst::GstDateTime,
    ) -> gboolean;
    pub fn ges_meta_container_set_double(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        value: c_double,
    ) -> gboolean;
    pub fn ges_meta_container_set_float(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        value: c_float,
    ) -> gboolean;
    pub fn ges_meta_container_set_int(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        value: c_int,
    ) -> gboolean;
    pub fn ges_meta_container_set_int64(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        value: i64,
    ) -> gboolean;
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_meta_container_set_marker_list(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        list: *const GESMarkerList,
    ) -> gboolean;
    pub fn ges_meta_container_set_meta(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        value: *const gobject::GValue,
    ) -> gboolean;
    pub fn ges_meta_container_set_string(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        value: *const c_char,
    ) -> gboolean;
    pub fn ges_meta_container_set_uint(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        value: c_uint,
    ) -> gboolean;
    pub fn ges_meta_container_set_uint64(
        container: *mut GESMetaContainer,
        meta_item: *const c_char,
        value: u64,
    ) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn ges_add_missing_uri_relocation_uri(uri: *const c_char, recurse: gboolean) -> gboolean;
    pub fn ges_deinit();
    #[cfg(any(feature = "v1_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_18")))]
    pub fn ges_find_formatter_for_uri(uri: *const c_char) -> *mut GESAsset;
    pub fn ges_init() -> gboolean;
    pub fn ges_init_check(
        argc: *mut c_int,
        argv: *mut *mut *mut c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn ges_init_get_option_group() -> *mut glib::GOptionGroup;
    #[cfg(any(feature = "v1_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
    pub fn ges_is_initialized() -> gboolean;
    pub fn ges_list_assets(filter: GType) -> *mut glib::GList;
    pub fn ges_play_sink_convert_frame(
        playsink: *mut gst::GstElement,
        caps: *mut gst::GstCaps,
    ) -> *mut gst::GstSample;
    pub fn ges_pspec_equal(key_spec_1: gconstpointer, key_spec_2: gconstpointer) -> gboolean;
    pub fn ges_pspec_hash(key_spec: gconstpointer) -> c_uint;
    pub fn ges_validate_register_action_types() -> gboolean;
    pub fn ges_version(
        major: *mut c_uint,
        minor: *mut c_uint,
        micro: *mut c_uint,
        nano: *mut c_uint,
    );

}
